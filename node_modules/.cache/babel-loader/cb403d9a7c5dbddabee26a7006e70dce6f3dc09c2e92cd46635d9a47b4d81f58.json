{"ast":null,"code":"import { ABIAddressType, abiCheckTransactionType, ABIReferenceType, ABITupleType, abiTypeIsReference, abiTypeIsTransaction, ABIUintType } from './abi/index.js';\nimport { SimulateRequest, SimulateRequestTransactionGroup } from './client/v2/algod/models/types.js';\nimport * as encoding from './encoding/encoding.js';\nimport { assignGroupID } from './group.js';\nimport { makeApplicationCallTxnFromObject } from './makeTxn.js';\nimport { isTransactionWithSigner } from './signer.js';\nimport { Transaction } from './transaction.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport { OnApplicationComplete } from './types/transactions/base.js';\nimport { arrayEqual, stringifyJSON, ensureUint64 } from './utils/utils.js';\nimport { waitForConfirmation } from './wait.js';\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\nexport var AtomicTransactionComposerStatus;\n(function (AtomicTransactionComposerStatus) {\n  /** The atomic group is still under construction. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILDING\"] = 0] = \"BUILDING\";\n  /** The atomic group has been finalized, but not yet signed. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILT\"] = 1] = \"BUILT\";\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SIGNED\"] = 2] = \"SIGNED\";\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SUBMITTED\"] = 3] = \"SUBMITTED\";\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"COMMITTED\"] = 4] = \"COMMITTED\";\n})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray(valueToAdd, array, zeroValue) {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n  const offset = zeroValue == null ? 0 : 1;\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  constructor() {\n    this.status = AtomicTransactionComposerStatus.BUILDING;\n    this.transactions = [];\n    this.methodCalls = new Map();\n    this.signedTxns = [];\n    this.txIDs = [];\n  }\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus() {\n    return this.status;\n  }\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count() {\n    return this.transactions.length;\n  }\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone() {\n    const theClone = new AtomicTransactionComposer();\n    theClone.transactions = this.transactions.map(({\n      txn,\n      signer\n    }) => {\n      const txnMap = txn.toEncodingData();\n      // erase the group ID\n      txnMap.delete('grp');\n      return {\n        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n        txn: Transaction.fromEncodingData(txnMap),\n        signer\n      };\n    });\n    theClone.methodCalls = new Map(this.methodCalls);\n    return theClone;\n  }\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some(v => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n    this.transactions.push(txnAndSigner);\n  }\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer\n  }) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (BigInt(appID) === BigInt(0)) {\n      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {\n        throw new Error('One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices');\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error('One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram');\n      }\n      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n        throw new Error('One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n      }\n    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n      throw new Error('One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n    }\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);\n    }\n    let basicArgTypes = [];\n    let basicArgValues = [];\n    const txnArgs = [];\n    const refArgTypes = [];\n    const refArgValues = [];\n    const refArgIndexToBasicArgIndex = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences = !boxes ? [] : boxes;\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n      if (abiTypeIsTransaction(argType)) {\n        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {\n          throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i}`);\n        }\n        if (argValue.txn.group && argValue.txn.group.some(v => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(`Expected non-transaction value for argument at index ${i}`);\n      }\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n    const resolvedRefIndexes = [];\n    // Converting addresses to string form for easier comparison\n    const foreignAccounts = appAccounts == null ? [] : appAccounts.map(addr => addr.toString());\n    const foreignApps = appForeignApps == null ? [] : appForeignApps.map(ensureUint64);\n    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.map(ensureUint64);\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n      switch (refType) {\n        case ABIReferenceType.account:\n          {\n            const addressType = new ABIAddressType();\n            const address = addressType.decode(addressType.encode(refValue));\n            resolved = populateForeignArray(address, foreignAccounts, sender.toString());\n            break;\n          }\n        case ABIReferenceType.application:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAppID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for application value, got ${refAppID}`);\n            }\n            resolved = populateForeignArray(refAppID, foreignApps, ensureUint64(appID));\n            break;\n          }\n        case ABIReferenceType.asset:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAssetID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);\n            }\n            resolved = populateForeignArray(refAssetID, foreignAssets);\n            break;\n          }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n      resolvedRefIndexes.push(resolved);\n    }\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n    const appArgsEncoded = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams\n      }),\n      signer\n    };\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup() {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(this.transactions.map(txnWithSigner => txnWithSigner.txn));\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures() {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map(txnWithSigner => txnWithSigner.txn);\n    const indexesPerSigner = new Map();\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const {\n        signer\n      } = txnsWithSigners[i];\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n      indexesPerSigner.get(signer).push(i);\n    }\n    const orderedSigners = Array.from(indexesPerSigner);\n    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));\n    const signedTxns = txnsWithSigners.map(() => null);\n    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n    function fullyPopulated(a) {\n      return a.every(v => v != null);\n    }\n    if (!fullyPopulated(signedTxns)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return encoding.decodeMsgpack(stxn, SignedTransaction).txn.txID();\n      } catch (err) {\n        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);\n      }\n    });\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n    return signedTxns;\n  }\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n    const stxns = await this.gatherSignatures();\n    await client.sendRawTransaction(stxns).do();\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    return this.txIDs;\n  }\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   * @param request - SimulateRequest with options in simulation.\n   *   If provided, the request's transaction group will be overrwritten by the composer's group,\n   *   only simulation related options will be used.\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(client, request) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Simulated Transaction group has already been submitted to the network');\n    }\n    const stxns = await this.gatherSignatures();\n    const txnObjects = stxns.map(stxn => encoding.decodeMsgpack(stxn, SignedTransaction));\n    const currentRequest = request == null ? new SimulateRequest({\n      txnGroups: []\n    }) : request;\n    currentRequest.txnGroups = [new SimulateRequestTransactionGroup({\n      txns: txnObjects\n    })];\n    const simulateResponse = await client.simulateTransactions(currentRequest).do();\n    // Parse method response\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n      const methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      methodResults.push(AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo));\n    }\n    return {\n      methodResults,\n      simulateResponse\n    };\n  }\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(client, waitRounds) {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error('Transaction group has already been executed successfully');\n    }\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));\n    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n    const confirmedRound = confirmedTxnInfo.confirmedRound;\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n      let methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      try {\n        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo :\n        // eslint-disable-next-line no-await-in-loop\n        await client.pendingTransactionInformation(txID).do();\n        methodResult = AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n      methodResults.push(methodResult);\n    }\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults\n    };\n  }\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(method, methodResult, pendingInfo) {\n    const returnedResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error(`App call transaction did not log a return value ${stringifyJSON(pendingInfo)}`);\n        }\n        const lastLog = logs[logs.length - 1];\n        if (lastLog.byteLength < 4 || !arrayEqual(lastLog.slice(0, 4), RETURN_PREFIX)) {\n          throw new Error(`App call transaction did not log a ABI return value ${stringifyJSON(pendingInfo)}`);\n        }\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);\n      }\n    } catch (err) {\n      returnedResult.decodeError = err;\n    }\n    return returnedResult;\n  }\n}\n/** The maximum size of an atomic transaction group. */\nAtomicTransactionComposer.MAX_GROUP_SIZE = 16;","map":{"version":3,"names":["ABIAddressType","abiCheckTransactionType","ABIReferenceType","ABITupleType","abiTypeIsReference","abiTypeIsTransaction","ABIUintType","SimulateRequest","SimulateRequestTransactionGroup","encoding","assignGroupID","makeApplicationCallTxnFromObject","isTransactionWithSigner","Transaction","SignedTransaction","OnApplicationComplete","arrayEqual","stringifyJSON","ensureUint64","waitForConfirmation","RETURN_PREFIX","Uint8Array","MAX_APP_ARGS","AtomicTransactionComposerStatus","populateForeignArray","valueToAdd","array","zeroValue","offset","i","length","push","AtomicTransactionComposer","constructor","status","BUILDING","transactions","methodCalls","Map","signedTxns","txIDs","getStatus","count","clone","theClone","map","txn","signer","txnMap","toEncodingData","delete","fromEncodingData","addTransaction","txnAndSigner","Error","MAX_GROUP_SIZE","group","some","v","addMethodCall","appID","method","methodArgs","sender","suggestedParams","onComplete","approvalProgram","clearProgram","numGlobalInts","numGlobalByteSlices","numLocalInts","numLocalByteSlices","extraPages","appAccounts","appForeignApps","appForeignAssets","boxes","note","lease","rekeyTo","txnCount","BigInt","UpdateApplicationOC","args","basicArgTypes","basicArgValues","txnArgs","refArgTypes","refArgValues","refArgIndexToBasicArgIndex","boxReferences","argType","type","argValue","set","resolvedRefIndexes","foreignAccounts","addr","toString","foreignApps","foreignAssets","refType","refValue","resolved","account","addressType","address","decode","encode","application","uint64Type","refAppID","Number","MAX_SAFE_INTEGER","asset","refAssetID","basicArgIndex","get","lastArgTupleTypes","slice","lastArgTupleValues","appArgsEncoded","getSelector","appCall","appIndex","appArgs","accounts","NoOpOC","buildGroup","txnWithSigner","BUILT","gatherSignatures","SIGNED","txnsWithSigners","txnGroup","indexesPerSigner","has","orderedSigners","Array","from","batchedSigs","Promise","all","indexes","signerIndex","sigs","fullyPopulated","a","every","stxn","index","decodeMsgpack","txID","err","submit","client","SUBMITTED","stxns","sendRawTransaction","do","simulate","request","txnObjects","currentRequest","txnGroups","txns","simulateResponse","simulateTransactions","methodResults","txnIndex","pendingInfo","txnResults","txnResult","methodResult","rawReturnValue","parseMethodResponse","execute","waitRounds","COMMITTED","firstMethodCallIndex","findIndex","_","indexToWaitFor","confirmedTxnInfo","confirmedRound","pendingTransactionInformation","decodeError","returnedResult","txInfo","returns","logs","lastLog","byteLength","returnValue"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\composer.ts"],"sourcesContent":["import {\n  ABIAddressType,\n  abiCheckTransactionType,\n  ABIMethod,\n  ABIReferenceType,\n  ABITupleType,\n  ABIType,\n  abiTypeIsReference,\n  abiTypeIsTransaction,\n  ABIUintType,\n  ABIValue,\n} from './abi/index.js';\nimport { AlgodClient } from './client/v2/algod/algod.js';\nimport {\n  SimulateRequest,\n  SimulateRequestTransactionGroup,\n  PendingTransactionResponse,\n  SimulateResponse,\n} from './client/v2/algod/models/types.js';\nimport * as encoding from './encoding/encoding.js';\nimport { Address } from './encoding/address.js';\nimport { assignGroupID } from './group.js';\nimport { makeApplicationCallTxnFromObject } from './makeTxn.js';\nimport {\n  isTransactionWithSigner,\n  TransactionSigner,\n  TransactionWithSigner,\n} from './signer.js';\nimport { Transaction } from './transaction.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport {\n  BoxReference,\n  OnApplicationComplete,\n  SuggestedParams,\n} from './types/transactions/base.js';\nimport { arrayEqual, stringifyJSON, ensureUint64 } from './utils/utils.js';\nimport { waitForConfirmation } from './wait.js';\n\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);\n\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\n\nexport type ABIArgument = ABIValue | TransactionWithSigner;\n\n/** Represents the output from a successful ABI method call. */\nexport interface ABIResult {\n  /** The TxID of the transaction that invoked the ABI method call. */\n  txID: string;\n  /**\n   * The raw bytes of the return value from the ABI method call. This will be empty if the method\n   * does not return a value (return type \"void\").\n   */\n  rawReturnValue: Uint8Array;\n  /**\n   * The method that was called for this result\n   */\n  method: ABIMethod;\n  /**\n   * The return value from the ABI method call. This will be undefined if the method does not return\n   * a value (return type \"void\"), or if the SDK was unable to decode the returned value.\n   */\n  returnValue?: ABIValue;\n  /** If the SDK was unable to decode a return value, the error will be here. */\n  decodeError?: Error;\n  /** The pending transaction information from the method transaction */\n  txInfo?: PendingTransactionResponse;\n}\n\nexport enum AtomicTransactionComposerStatus {\n  /** The atomic group is still under construction. */\n  BUILDING,\n\n  /** The atomic group has been finalized, but not yet signed. */\n  BUILT,\n\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  SIGNED,\n\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  SUBMITTED,\n\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  COMMITTED,\n}\n\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray<Type>(\n  valueToAdd: Type,\n  array: Type[],\n  zeroValue?: Type\n): number {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n\n  const offset = zeroValue == null ? 0 : 1;\n\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  /** The maximum size of an atomic transaction group. */\n  static MAX_GROUP_SIZE: number = 16;\n\n  private status = AtomicTransactionComposerStatus.BUILDING;\n  private transactions: TransactionWithSigner[] = [];\n  private methodCalls: Map<number, ABIMethod> = new Map();\n  private signedTxns: Uint8Array[] = [];\n  private txIDs: string[] = [];\n\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus(): AtomicTransactionComposerStatus {\n    return this.status;\n  }\n\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count(): number {\n    return this.transactions.length;\n  }\n\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone(): AtomicTransactionComposer {\n    const theClone = new AtomicTransactionComposer();\n\n    theClone.transactions = this.transactions.map(({ txn, signer }) => {\n      const txnMap = txn.toEncodingData();\n      // erase the group ID\n      txnMap.delete('grp');\n      return {\n        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n        txn: Transaction.fromEncodingData(txnMap),\n        signer,\n      };\n    });\n    theClone.methodCalls = new Map(this.methodCalls);\n\n    return theClone;\n  }\n\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner: TransactionWithSigner): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(\n        `Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v) => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n\n    this.transactions.push(txnAndSigner);\n  }\n\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall({\n    appID,\n    method,\n    methodArgs,\n    sender,\n    suggestedParams,\n    onComplete,\n    approvalProgram,\n    clearProgram,\n    numGlobalInts,\n    numGlobalByteSlices,\n    numLocalInts,\n    numLocalByteSlices,\n    extraPages,\n    appAccounts,\n    appForeignApps,\n    appForeignAssets,\n    boxes,\n    note,\n    lease,\n    rekeyTo,\n    signer,\n  }: {\n    /** The ID of the smart contract to call. Set this to 0 to indicate an application creation call. */\n    appID: number | bigint;\n    /** The method to call on the smart contract */\n    method: ABIMethod;\n    /** The arguments to include in the method call. If omitted, no arguments will be passed to the method. */\n    methodArgs?: ABIArgument[];\n    /** The address of the sender of this application call */\n    sender: string | Address;\n    /** Transactions params to use for this application call */\n    suggestedParams: SuggestedParams;\n    /** The OnComplete action to take for this application call. If omitted, OnApplicationComplete.NoOpOC will be used. */\n    onComplete?: OnApplicationComplete;\n    /** The approval program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    approvalProgram?: Uint8Array;\n    /** The clear program for this application call. Only set this if this is an application creation call, or if onComplete is OnApplicationComplete.UpdateApplicationOC */\n    clearProgram?: Uint8Array;\n    /** The global integer schema size. Only set this if this is an application creation call. */\n    numGlobalInts?: number;\n    /** The global byte slice schema size. Only set this if this is an application creation call. */\n    numGlobalByteSlices?: number;\n    /** The local integer schema size. Only set this if this is an application creation call. */\n    numLocalInts?: number;\n    /** The local byte slice schema size. Only set this if this is an application creation call. */\n    numLocalByteSlices?: number;\n    /** The number of extra pages to allocate for the application's programs. Only set this if this is an application creation call. If omitted, defaults to 0. */\n    extraPages?: number;\n    /** Array of Address strings that represent external accounts supplied to this application. If accounts are provided here, the accounts specified in the method args will appear after these. */\n    appAccounts?: Array<string | Address>;\n    /** Array of App ID numbers that represent external apps supplied to this application. If apps are provided here, the apps specified in the method args will appear after these. */\n    appForeignApps?: Array<number | bigint>;\n    /** Array of Asset ID numbers that represent external assets supplied to this application. If assets are provided here, the assets specified in the method args will appear after these. */\n    appForeignAssets?: Array<number | bigint>;\n    /** The box references for this application call */\n    boxes?: BoxReference[];\n    /** The note value for this application call */\n    note?: Uint8Array;\n    /** The lease value for this application call */\n    lease?: Uint8Array;\n    /** If provided, the address that the sender will be rekeyed to at the conclusion of this application call */\n    rekeyTo?: string | Address;\n    /** A transaction signer that can authorize this application call from sender */\n    signer: TransactionSigner;\n  }): void {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error(\n        'Cannot add transactions when composer status is not BUILDING'\n      );\n    }\n\n    if (\n      this.transactions.length + method.txnCount() >\n      AtomicTransactionComposer.MAX_GROUP_SIZE\n    ) {\n      throw new Error(\n        `Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`\n      );\n    }\n\n    if (BigInt(appID) === BigInt(0)) {\n      if (\n        approvalProgram == null ||\n        clearProgram == null ||\n        numGlobalInts == null ||\n        numGlobalByteSlices == null ||\n        numLocalInts == null ||\n        numLocalByteSlices == null\n      ) {\n        throw new Error(\n          'One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices'\n        );\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error(\n          'One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram'\n        );\n      }\n      if (\n        numGlobalInts != null ||\n        numGlobalByteSlices != null ||\n        numLocalInts != null ||\n        numLocalByteSlices != null ||\n        extraPages != null\n      ) {\n        throw new Error(\n          'One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n        );\n      }\n    } else if (\n      approvalProgram != null ||\n      clearProgram != null ||\n      numGlobalInts != null ||\n      numGlobalByteSlices != null ||\n      numLocalInts != null ||\n      numLocalByteSlices != null ||\n      extraPages != null\n    ) {\n      throw new Error(\n        'One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages'\n      );\n    }\n\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(\n        `Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`\n      );\n    }\n\n    let basicArgTypes: ABIType[] = [];\n    let basicArgValues: ABIValue[] = [];\n    const txnArgs: TransactionWithSigner[] = [];\n    const refArgTypes: ABIReferenceType[] = [];\n    const refArgValues: ABIValue[] = [];\n    const refArgIndexToBasicArgIndex: Map<number, number> = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences: BoxReference[] = !boxes ? [] : boxes;\n\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n\n      if (abiTypeIsTransaction(argType)) {\n        if (\n          !isTransactionWithSigner(argValue) ||\n          !abiCheckTransactionType(argType, argValue.txn)\n        ) {\n          throw new Error(\n            `Expected ${argType} TransactionWithSigner for argument at index ${i}`\n          );\n        }\n        if (argValue.txn.group && argValue.txn.group.some((v) => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(\n          `Expected non-transaction value for argument at index ${i}`\n        );\n      }\n\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(\n          refArgTypes.length,\n          basicArgTypes.length\n        );\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n\n    const resolvedRefIndexes: number[] = [];\n    // Converting addresses to string form for easier comparison\n    const foreignAccounts: string[] =\n      appAccounts == null ? [] : appAccounts.map((addr) => addr.toString());\n    const foreignApps: bigint[] =\n      appForeignApps == null ? [] : appForeignApps.map(ensureUint64);\n    const foreignAssets: bigint[] =\n      appForeignAssets == null ? [] : appForeignAssets.map(ensureUint64);\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n\n      switch (refType) {\n        case ABIReferenceType.account: {\n          const addressType = new ABIAddressType();\n          const address = addressType.decode(addressType.encode(refValue));\n          resolved = populateForeignArray(\n            address,\n            foreignAccounts,\n            sender.toString()\n          );\n          break;\n        }\n        case ABIReferenceType.application: {\n          const uint64Type = new ABIUintType(64);\n          const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAppID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for application value, got ${refAppID}`\n            );\n          }\n          resolved = populateForeignArray(\n            refAppID,\n            foreignApps,\n            ensureUint64(appID)\n          );\n          break;\n        }\n        case ABIReferenceType.asset: {\n          const uint64Type = new ABIUintType(64);\n          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n          if (refAssetID > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\n              `Expected safe integer for asset value, got ${refAssetID}`\n            );\n          }\n          resolved = populateForeignArray(refAssetID, foreignAssets);\n          break;\n        }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n\n      resolvedRefIndexes.push(resolved);\n    }\n\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i)!;\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n\n    const appArgsEncoded: Uint8Array[] = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete:\n          onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams,\n      }),\n      signer,\n    };\n\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup(): TransactionWithSigner[] {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(\n          this.transactions.map((txnWithSigner) => txnWithSigner.txn)\n        );\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures(): Promise<Uint8Array[]> {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);\n\n    const indexesPerSigner: Map<TransactionSigner, number[]> = new Map();\n\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const { signer } = txnsWithSigners[i];\n\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n\n      indexesPerSigner.get(signer)!.push(i);\n    }\n\n    const orderedSigners = Array.from(indexesPerSigner);\n\n    const batchedSigs = await Promise.all(\n      orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes))\n    );\n\n    const signedTxns: Array<Uint8Array | null> = txnsWithSigners.map(\n      () => null\n    );\n\n    for (\n      let signerIndex = 0;\n      signerIndex < orderedSigners.length;\n      signerIndex++\n    ) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n\n    function fullyPopulated(a: Array<Uint8Array | null>): a is Uint8Array[] {\n      return a.every((v) => v != null);\n    }\n\n    if (!fullyPopulated(signedTxns)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return encoding.decodeMsgpack(stxn, SignedTransaction).txn.txID();\n      } catch (err) {\n        throw new Error(\n          `Cannot decode signed transaction at index ${index}. ${err}`\n        );\n      }\n    });\n\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n\n    return signedTxns;\n  }\n\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client: AlgodClient): Promise<string[]> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n\n    const stxns = await this.gatherSignatures();\n\n    await client.sendRawTransaction(stxns).do();\n\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    return this.txIDs;\n  }\n\n  /**\n   * Simulates the transaction group in the network.\n   *\n   * The composer will try to sign any transactions in the group, then simulate\n   * the results.\n   * Simulating the group will not change the composer's status.\n   *\n   * @param client - An Algodv2 client\n   * @param request - SimulateRequest with options in simulation.\n   *   If provided, the request's transaction group will be overrwritten by the composer's group,\n   *   only simulation related options will be used.\n   *\n   * @returns A promise that, upon success, resolves to an object containing an\n   *   array of results containing one element for each method call transaction\n   *   in this group (ABIResult[]) and the SimulateResponse object.\n   */\n  async simulate(\n    client: AlgodClient,\n    request?: SimulateRequest\n  ): Promise<{\n    methodResults: ABIResult[];\n    simulateResponse: SimulateResponse;\n  }> {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error(\n        'Simulated Transaction group has already been submitted to the network'\n      );\n    }\n\n    const stxns = await this.gatherSignatures();\n    const txnObjects: SignedTransaction[] = stxns.map((stxn) =>\n      encoding.decodeMsgpack(stxn, SignedTransaction)\n    );\n\n    const currentRequest: SimulateRequest =\n      request == null ? new SimulateRequest({ txnGroups: [] }) : request;\n\n    currentRequest.txnGroups = [\n      new SimulateRequestTransactionGroup({\n        txns: txnObjects,\n      }),\n    ];\n\n    const simulateResponse = await client\n      .simulateTransactions(currentRequest)\n      .do();\n\n    // Parse method response\n    const methodResults: ABIResult[] = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = this.txIDs[txnIndex];\n      const pendingInfo =\n        simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;\n\n      const methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      methodResults.push(\n        AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo\n        )\n      );\n    }\n\n    return { methodResults, simulateResponse };\n  }\n\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(\n    client: AlgodClient,\n    waitRounds: number\n  ): Promise<{\n    confirmedRound: bigint;\n    txIDs: string[];\n    methodResults: ABIResult[];\n  }> {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error(\n        'Transaction group has already been executed successfully'\n      );\n    }\n\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) =>\n      this.methodCalls.has(index)\n    );\n    const indexToWaitFor =\n      firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(\n      client,\n      txIDs[indexToWaitFor],\n      waitRounds\n    );\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n\n    const confirmedRound = confirmedTxnInfo.confirmedRound!;\n\n    const methodResults: ABIResult[] = [];\n\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n\n      let methodResult: ABIResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method,\n      };\n\n      try {\n        const pendingInfo =\n          txnIndex === firstMethodCallIndex\n            ? confirmedTxnInfo\n            : // eslint-disable-next-line no-await-in-loop\n              await client.pendingTransactionInformation(txID).do();\n\n        methodResult = AtomicTransactionComposer.parseMethodResponse(\n          method,\n          methodResult,\n          pendingInfo\n        );\n      } catch (err) {\n        methodResult.decodeError = err as Error;\n      }\n\n      methodResults.push(methodResult);\n    }\n\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults,\n    };\n  }\n\n  /**\n   * Parses a single ABI Method transaction log into a ABI result object.\n   *\n   * @param method\n   * @param methodResult\n   * @param pendingInfo\n   * @returns An ABIResult object\n   */\n  static parseMethodResponse(\n    method: ABIMethod,\n    methodResult: ABIResult,\n    pendingInfo: PendingTransactionResponse\n  ): ABIResult {\n    const returnedResult: ABIResult = methodResult;\n    try {\n      returnedResult.txInfo = pendingInfo;\n      if (method.returns.type !== 'void') {\n        const logs = pendingInfo.logs || [];\n        if (logs.length === 0) {\n          throw new Error(\n            `App call transaction did not log a return value ${stringifyJSON(\n              pendingInfo\n            )}`\n          );\n        }\n        const lastLog = logs[logs.length - 1];\n        if (\n          lastLog.byteLength < 4 ||\n          !arrayEqual(lastLog.slice(0, 4), RETURN_PREFIX)\n        ) {\n          throw new Error(\n            `App call transaction did not log a ABI return value ${stringifyJSON(\n              pendingInfo\n            )}`\n          );\n        }\n\n        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n        returnedResult.returnValue = method.returns.type.decode(\n          methodResult.rawReturnValue\n        );\n      }\n    } catch (err) {\n      returnedResult.decodeError = err as Error;\n    }\n\n    return returnedResult;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}