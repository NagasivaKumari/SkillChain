{"ast":null,"code":"import { genericHash } from '../nacl/naclWrappers.js';\nimport { ABIType, ABITupleType } from './abi_type.js';\nimport { abiTypeIsTransaction } from './transaction.js';\nimport { abiTypeIsReference } from './reference.js';\nfunction parseMethodSignature(signature) {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n  if (argsEnd === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),\n    returns: signature.slice(argsEnd + 1)\n  };\n}\nexport class ABIMethod {\n  constructor(params) {\n    if (typeof params.name !== 'string' || typeof params.returns !== 'object' || !Array.isArray(params.args)) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(({\n      type,\n      name,\n      desc\n    }) => {\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc\n        };\n      }\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc\n      };\n    });\n    this.returns = {\n      type: params.returns.type === 'void' ? params.returns.type : ABIType.from(params.returns.type),\n      description: params.returns.desc\n    };\n    this.events = params.events;\n    this.readonly = params.readonly;\n  }\n  getSignature() {\n    const args = this.args.map(arg => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return `${this.name}(${args})${returns}`;\n  }\n  getSelector() {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n  txnCount() {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  toJSON() {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(({\n        type,\n        name,\n        description\n      }) => ({\n        type: type.toString(),\n        name,\n        desc: description\n      })),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description\n      },\n      events: this.events,\n      readonly: this.readonly\n    };\n  }\n  static fromSignature(signature) {\n    const {\n      name,\n      args,\n      returns\n    } = parseMethodSignature(signature);\n    return new ABIMethod({\n      name,\n      args: args.map(arg => ({\n        type: arg\n      })),\n      returns: {\n        type: returns\n      }\n    });\n  }\n}\nexport function getMethodByName(methods, name) {\n  if (methods === null || !Array.isArray(methods) || !methods.every(item => item instanceof ABIMethod)) throw new Error('Methods list provided is null or not the correct type');\n  const filteredMethods = methods.filter(m => m.name === name);\n  if (filteredMethods.length > 1) throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map(m => m.getSignature()).join(',')}`);\n  if (filteredMethods.length === 0) throw new Error(`found 0 methods with the name ${name}`);\n  return filteredMethods[0];\n}","map":{"version":3,"names":["genericHash","ABIType","ABITupleType","abiTypeIsTransaction","abiTypeIsReference","parseMethodSignature","signature","argsStart","indexOf","Error","argsEnd","depth","i","length","char","name","slice","args","parseTupleContent","returns","ABIMethod","constructor","params","Array","isArray","description","desc","map","type","from","events","readonly","getSignature","arg","toString","join","getSelector","hash","Uint8Array","txnCount","count","toJSON","fromSignature","getMethodByName","methods","every","item","filteredMethods","filter","m"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\abi\\method.ts"],"sourcesContent":["import { genericHash } from '../nacl/naclWrappers.js';\nimport { ABIType, ABITupleType } from './abi_type.js';\nimport { ABITransactionType, abiTypeIsTransaction } from './transaction.js';\nimport { ABIReferenceType, abiTypeIsReference } from './reference.js';\nimport { ARC28Event } from './event.js';\n\nfunction parseMethodSignature(signature: string): {\n  name: string;\n  args: string[];\n  returns: string;\n} {\n  const argsStart = signature.indexOf('(');\n  if (argsStart === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  let argsEnd = -1;\n  let depth = 0;\n  for (let i = argsStart; i < signature.length; i++) {\n    const char = signature[i];\n\n    if (char === '(') {\n      depth += 1;\n    } else if (char === ')') {\n      if (depth === 0) {\n        // unpaired parenthesis\n        break;\n      }\n\n      depth -= 1;\n      if (depth === 0) {\n        argsEnd = i;\n        break;\n      }\n    }\n  }\n\n  if (argsEnd === -1) {\n    throw new Error(`Invalid method signature: ${signature}`);\n  }\n\n  return {\n    name: signature.slice(0, argsStart),\n    args: ABITupleType.parseTupleContent(\n      signature.slice(argsStart + 1, argsEnd)\n    ),\n    returns: signature.slice(argsEnd + 1),\n  };\n}\n\nexport interface ABIMethodArgParams {\n  type: string;\n  name?: string;\n  desc?: string;\n}\n\nexport interface ABIMethodReturnParams {\n  type: string;\n  desc?: string;\n}\n\nexport interface ABIMethodParams {\n  name: string;\n  desc?: string;\n  args: ABIMethodArgParams[];\n  returns: ABIMethodReturnParams;\n  /** Optional, is it a read-only method (according to [ARC-22](https://arc.algorand.foundation/ARCs/arc-0022)) */\n  readonly?: boolean;\n  /** [ARC-28](https://arc.algorand.foundation/ARCs/arc-0028) events that MAY be emitted by this method */\n  events?: ARC28Event[];\n}\n\nexport type ABIArgumentType = ABIType | ABITransactionType | ABIReferenceType;\n\nexport type ABIReturnType = ABIType | 'void';\n\nexport class ABIMethod {\n  public readonly name: string;\n  public readonly description?: string;\n  public readonly args: Array<{\n    type: ABIArgumentType;\n    name?: string;\n    description?: string;\n  }>;\n\n  public readonly returns: { type: ABIReturnType; description?: string };\n  public readonly events?: ARC28Event[];\n  public readonly readonly?: boolean;\n\n  constructor(params: ABIMethodParams) {\n    if (\n      typeof params.name !== 'string' ||\n      typeof params.returns !== 'object' ||\n      !Array.isArray(params.args)\n    ) {\n      throw new Error('Invalid ABIMethod parameters');\n    }\n\n    this.name = params.name;\n    this.description = params.desc;\n    this.args = params.args.map(({ type, name, desc }) => {\n      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {\n        return {\n          type,\n          name,\n          description: desc,\n        };\n      }\n\n      return {\n        type: ABIType.from(type),\n        name,\n        description: desc,\n      };\n    });\n    this.returns = {\n      type:\n        params.returns.type === 'void'\n          ? params.returns.type\n          : ABIType.from(params.returns.type),\n      description: params.returns.desc,\n    };\n\n    this.events = params.events;\n    this.readonly = params.readonly;\n  }\n\n  getSignature(): string {\n    const args = this.args.map((arg) => arg.type.toString()).join(',');\n    const returns = this.returns.type.toString();\n    return `${this.name}(${args})${returns}`;\n  }\n\n  getSelector(): Uint8Array {\n    const hash = genericHash(this.getSignature());\n    return new Uint8Array(hash.slice(0, 4));\n  }\n\n  txnCount(): number {\n    let count = 1;\n    for (const arg of this.args) {\n      if (typeof arg.type === 'string' && abiTypeIsTransaction(arg.type)) {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  toJSON(): ABIMethodParams {\n    return {\n      name: this.name,\n      desc: this.description,\n      args: this.args.map(({ type, name, description }) => ({\n        type: type.toString(),\n        name,\n        desc: description,\n      })),\n      returns: {\n        type: this.returns.type.toString(),\n        desc: this.returns.description,\n      },\n      events: this.events,\n      readonly: this.readonly,\n    };\n  }\n\n  static fromSignature(signature: string): ABIMethod {\n    const { name, args, returns } = parseMethodSignature(signature);\n\n    return new ABIMethod({\n      name,\n      args: args.map((arg) => ({ type: arg })),\n      returns: { type: returns },\n    });\n  }\n}\n\nexport function getMethodByName(methods: ABIMethod[], name: string): ABIMethod {\n  if (\n    methods === null ||\n    !Array.isArray(methods) ||\n    !methods.every((item) => item instanceof ABIMethod)\n  )\n    throw new Error('Methods list provided is null or not the correct type');\n\n  const filteredMethods = methods.filter((m: ABIMethod) => m.name === name);\n  if (filteredMethods.length > 1)\n    throw new Error(\n      `found ${\n        filteredMethods.length\n      } methods with the same name ${filteredMethods\n        .map((m: ABIMethod) => m.getSignature())\n        .join(',')}`\n    );\n\n  if (filteredMethods.length === 0)\n    throw new Error(`found 0 methods with the name ${name}`);\n\n  return filteredMethods[0];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}