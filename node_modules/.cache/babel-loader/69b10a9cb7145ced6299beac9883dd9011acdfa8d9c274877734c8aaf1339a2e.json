{"ast":null,"code":"import { NamedMapSchema, Uint64MapSchema, SpecialCaseBinaryStringMapSchema, SpecialCaseBinaryStringSchema, ArraySchema, StringSchema, BooleanSchema, Uint64Schema, AddressSchema, ByteArraySchema, FixedLengthByteArraySchema, OptionalSchema, allOmitEmpty, combineMaps, convertMap, BlockHashSchema } from '../encoding/schema/index.js';\nimport { SignedTransaction } from '../signedTransaction.js';\n/**\n * StateProofTrackingData tracks the status of state proofs.\n */\nexport class StateProofTrackingData {\n  constructor(params) {\n    this.stateProofVotersCommitment = params.stateProofVotersCommitment;\n    this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;\n    this.stateProofNextRound = params.stateProofNextRound;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return StateProofTrackingData.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['v', this.stateProofVotersCommitment], ['t', this.stateProofOnlineTotalWeight], ['n', this.stateProofNextRound]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);\n    }\n    return new StateProofTrackingData({\n      stateProofVotersCommitment: data.get('v'),\n      stateProofOnlineTotalWeight: data.get('t'),\n      stateProofNextRound: data.get('n')\n    });\n  }\n}\nStateProofTrackingData.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'v',\n  // stateProofVotersCommitment\n  valueSchema: new ByteArraySchema()\n}, {\n  key: 't',\n  // stateProofOnlineTotalWeight\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'n',\n  // stateProofNextRound\n  valueSchema: new Uint64Schema()\n}]));\n/**\n * TxnCommitments represents the commitments computed from the transactions in the block.\n * It contains multiple commitments based on different algorithms and hash functions, to support\n * different use cases.\n */\nexport class TxnCommitments {\n  constructor(params) {\n    this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;\n    this.sha256Commitment = params.sha256Commitment;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return TxnCommitments.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['txn', this.nativeSha512_256Commitment], ['txn256', this.sha256Commitment]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded TxnCommitments: ${data}`);\n    }\n    return new TxnCommitments({\n      nativeSha512_256Commitment: data.get('txn'),\n      sha256Commitment: data.get('txn256')\n    });\n  }\n}\nTxnCommitments.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'txn',\n  // nativeSha512_256Commitment\n  valueSchema: new FixedLengthByteArraySchema(32)\n}, {\n  key: 'txn256',\n  // sha256Commitment\n  valueSchema: new FixedLengthByteArraySchema(32)\n}]));\n/**\n * RewardsState represents the global parameters controlling the rate at which accounts accrue rewards.\n */\nexport class RewardState {\n  constructor(params) {\n    this.feeSink = params.feeSink;\n    this.rewardsPool = params.rewardsPool;\n    this.rewardsLevel = params.rewardsLevel;\n    this.rewardsRate = params.rewardsRate;\n    this.rewardsResidue = params.rewardsResidue;\n    this.rewardsRecalculationRound = params.rewardsRecalculationRound;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return RewardState.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['fees', this.feeSink], ['rwd', this.rewardsPool], ['earn', this.rewardsLevel], ['rate', this.rewardsRate], ['frac', this.rewardsResidue], ['rwcalr', this.rewardsRecalculationRound]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded RewardState: ${data}`);\n    }\n    return new RewardState({\n      feeSink: data.get('fees'),\n      rewardsPool: data.get('rwd'),\n      rewardsLevel: data.get('earn'),\n      rewardsRate: data.get('rate'),\n      rewardsResidue: data.get('frac'),\n      rewardsRecalculationRound: data.get('rwcalr')\n    });\n  }\n}\nRewardState.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'fees',\n  // feeSink\n  valueSchema: new AddressSchema()\n}, {\n  key: 'rwd',\n  // rewardsPool\n  valueSchema: new AddressSchema()\n}, {\n  key: 'earn',\n  // rewardsLevel\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'rate',\n  // rewardsRate\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'frac',\n  // rewardsResidue\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'rwcalr',\n  // rewardsRecalculationRound\n  valueSchema: new Uint64Schema()\n}]));\n/**\n * UpgradeState tracks the protocol upgrade state machine.  It is, strictly speaking, computable from\n * the history of all UpgradeVotes but we keep it in the block for explicitness and convenience\n * (instead of materializing it separately, like balances).\n */\nexport class UpgradeState {\n  constructor(params) {\n    this.currentProtocol = params.currentProtocol;\n    this.nextProtocol = params.nextProtocol;\n    this.nextProtocolApprovals = params.nextProtocolApprovals;\n    this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;\n    this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return UpgradeState.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['proto', this.currentProtocol], ['nextproto', this.nextProtocol], ['nextyes', this.nextProtocolApprovals], ['nextbefore', this.nextProtocolVoteBefore], ['nextswitch', this.nextProtocolSwitchOn]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded UpgradeState: ${data}`);\n    }\n    return new UpgradeState({\n      currentProtocol: data.get('proto'),\n      nextProtocol: data.get('nextproto'),\n      nextProtocolApprovals: data.get('nextyes'),\n      nextProtocolVoteBefore: data.get('nextbefore'),\n      nextProtocolSwitchOn: data.get('nextswitch')\n    });\n  }\n}\nUpgradeState.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'proto',\n  // currentProtocol\n  valueSchema: new StringSchema()\n}, {\n  key: 'nextproto',\n  // nextProtocol\n  valueSchema: new StringSchema()\n}, {\n  key: 'nextyes',\n  // nextProtocolApprovals\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'nextbefore',\n  // nextProtocolVoteBefore\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'nextswitch',\n  // nextProtocolSwitchOn\n  valueSchema: new Uint64Schema()\n}]));\n/**\n * UpgradeVote represents the vote of the block proposer with respect to protocol upgrades.\n */\nexport class UpgradeVote {\n  constructor(params) {\n    this.upgradePropose = params.upgradePropose;\n    this.upgradeDelay = params.upgradeDelay;\n    this.upgradeApprove = params.upgradeApprove;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return UpgradeVote.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['upgradeprop', this.upgradePropose], ['upgradedelay', this.upgradeDelay], ['upgradeyes', this.upgradeApprove]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded UpgradeVote: ${data}`);\n    }\n    return new UpgradeVote({\n      upgradePropose: data.get('upgradeprop'),\n      upgradeDelay: data.get('upgradedelay'),\n      upgradeApprove: data.get('upgradeyes')\n    });\n  }\n}\nUpgradeVote.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'upgradeprop',\n  // upgradePropose\n  valueSchema: new StringSchema()\n}, {\n  key: 'upgradedelay',\n  // upgradeDelay\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'upgradeyes',\n  // upgradeApprove\n  valueSchema: new BooleanSchema()\n}]));\n/**\n * ParticipationUpdates represents participation account data that needs to be checked/acted on by\n * the network\n */\nexport class ParticipationUpdates {\n  constructor(params) {\n    this.expiredParticipationAccounts = params.expiredParticipationAccounts;\n    this.absentParticipationAccounts = params.absentParticipationAccounts;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return ParticipationUpdates.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['partupdrmv', this.expiredParticipationAccounts], ['partupdabs', this.absentParticipationAccounts]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);\n    }\n    return new ParticipationUpdates({\n      expiredParticipationAccounts: data.get('partupdrmv'),\n      absentParticipationAccounts: data.get('partupdabs')\n    });\n  }\n}\nParticipationUpdates.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'partupdrmv',\n  // expiredParticipationAccounts\n  valueSchema: new ArraySchema(new AddressSchema())\n}, {\n  key: 'partupdabs',\n  // absentParticipationAccounts\n  valueSchema: new ArraySchema(new AddressSchema())\n}]));\n/**\n * Represents the metadata and state of a block.\n *\n * For more information, refer to: https://github.com/algorand/go-algorand/blob/master/data/bookkeeping/block.go\n */\nexport class BlockHeader {\n  constructor(params) {\n    this.round = params.round;\n    this.branch = params.branch;\n    this.seed = params.seed;\n    this.txnCommitments = params.txnCommitments;\n    this.timestamp = params.timestamp;\n    this.genesisID = params.genesisID;\n    this.genesisHash = params.genesisHash;\n    this.proposer = params.proposer;\n    this.feesCollected = params.feesCollected;\n    this.bonus = params.bonus;\n    this.proposerPayout = params.proposerPayout;\n    this.rewardState = params.rewardState;\n    this.upgradeState = params.upgradeState;\n    this.upgradeVote = params.upgradeVote;\n    this.txnCounter = params.txnCounter;\n    this.stateproofTracking = params.stateproofTracking;\n    this.participationUpdates = params.participationUpdates;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return BlockHeader.encodingSchema;\n  }\n  toEncodingData() {\n    const data = new Map([['rnd', this.round], ['prev', this.branch], ['seed', this.seed], ['ts', this.timestamp], ['gen', this.genesisID], ['gh', this.genesisHash], ['prp', this.proposer], ['fc', this.feesCollected], ['bi', this.bonus], ['pp', this.proposerPayout], ['tc', this.txnCounter], ['spt', convertMap(this.stateproofTracking, (key, value) => [key, value.toEncodingData()])]]);\n    return combineMaps(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded BlockHeader: ${data}`);\n    }\n    return new BlockHeader({\n      round: data.get('rnd'),\n      branch: data.get('prev'),\n      seed: data.get('seed'),\n      txnCommitments: TxnCommitments.fromEncodingData(data),\n      timestamp: data.get('ts'),\n      genesisID: data.get('gen'),\n      genesisHash: data.get('gh'),\n      proposer: data.get('prp'),\n      feesCollected: data.get('fc'),\n      bonus: data.get('bi'),\n      proposerPayout: data.get('pp'),\n      rewardState: RewardState.fromEncodingData(data),\n      upgradeState: UpgradeState.fromEncodingData(data),\n      upgradeVote: UpgradeVote.fromEncodingData(data),\n      txnCounter: data.get('tc'),\n      stateproofTracking: convertMap(data.get('spt'), (key, value) => [Number(key), StateProofTrackingData.fromEncodingData(value)]),\n      participationUpdates: ParticipationUpdates.fromEncodingData(data)\n    });\n  }\n}\nBlockHeader.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'rnd',\n  // round\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'prev',\n  // branch\n  valueSchema: new BlockHashSchema()\n}, {\n  key: 'seed',\n  // seed\n  valueSchema: new ByteArraySchema()\n}, {\n  key: '',\n  valueSchema: TxnCommitments.encodingSchema,\n  embedded: true\n}, {\n  key: 'ts',\n  // timestamp\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'gen',\n  // genesisID\n  valueSchema: new StringSchema()\n}, {\n  key: 'gh',\n  // genesisHash\n  valueSchema: new FixedLengthByteArraySchema(32)\n}, {\n  key: 'prp',\n  // proposer\n  valueSchema: new AddressSchema()\n}, {\n  key: 'fc',\n  // feesCollected\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'bi',\n  // bonus\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'pp',\n  // proposerPayout\n  valueSchema: new Uint64Schema()\n}, {\n  key: '',\n  valueSchema: RewardState.encodingSchema,\n  embedded: true\n}, {\n  key: '',\n  valueSchema: UpgradeState.encodingSchema,\n  embedded: true\n}, {\n  key: '',\n  valueSchema: UpgradeVote.encodingSchema,\n  embedded: true\n}, {\n  key: 'tc',\n  // txnCounter\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'spt',\n  // stateproofTracking\n  valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema)\n}, {\n  key: '',\n  valueSchema: ParticipationUpdates.encodingSchema,\n  embedded: true\n}]));\nexport class ValueDelta {\n  constructor(params) {\n    this.action = params.action;\n    this.bytes = params.bytes;\n    this.uint = params.uint;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return ValueDelta.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['at', this.action], ['bs', this.bytes], ['ui', this.uint]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ValueDelta: ${data}`);\n    }\n    return new ValueDelta({\n      action: Number(data.get('at')),\n      bytes: data.get('bs'),\n      uint: data.get('ui')\n    });\n  }\n}\nValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'at',\n  // action\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'bs',\n  // bytes\n  valueSchema: new SpecialCaseBinaryStringSchema()\n}, {\n  key: 'ui',\n  // uint\n  valueSchema: new Uint64Schema()\n}]));\nexport class EvalDelta {\n  static get encodingSchema() {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      this.encodingSchemaValue.pushEntries(...allOmitEmpty([{\n        key: 'gd',\n        // globalDelta\n        valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))\n      }, {\n        key: 'ld',\n        // localDeltas\n        valueSchema: new OptionalSchema(new Uint64MapSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)))\n      }, {\n        key: 'sa',\n        // sharedAccts\n        valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))\n      }, {\n        key: 'lg',\n        // logs\n        valueSchema: new OptionalSchema(new ArraySchema(new SpecialCaseBinaryStringSchema()))\n      }, {\n        key: 'itx',\n        // innerTxns\n        valueSchema: new OptionalSchema(\n        // eslint-disable-next-line no-use-before-define\n        new ArraySchema(SignedTxnWithAD.encodingSchema))\n      }]));\n    }\n    return this.encodingSchemaValue;\n  }\n  constructor(params) {\n    this.globalDelta = params.globalDelta ?? new Map();\n    this.localDeltas = params.localDeltas ?? new Map();\n    this.sharedAccts = params.sharedAccts ?? [];\n    this.logs = params.logs ?? [];\n    this.innerTxns = params.innerTxns ?? [];\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return EvalDelta.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['gd', convertMap(this.globalDelta, (key, value) => [key, value.toEncodingData()])], ['ld', convertMap(this.localDeltas, (key, value) => [key, convertMap(value, (k, v) => [k, v.toEncodingData()])])], ['sa', this.sharedAccts], ['lg', this.logs], ['itx', this.innerTxns.map(t => t.toEncodingData())]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded EvalDelta: ${data}`);\n    }\n    return new EvalDelta({\n      globalDelta: data.get('gd') ? convertMap(data.get('gd'), (key, value) => [key, ValueDelta.fromEncodingData(value)]) : undefined,\n      localDeltas: data.get('ld') ? convertMap(data.get('ld'), (key, value) => [Number(key), convertMap(value, (k, v) => [k, ValueDelta.fromEncodingData(v)])]) : undefined,\n      sharedAccts: data.get('sa'),\n      logs: data.get('lg'),\n      // eslint-disable-next-line no-use-before-define\n      innerTxns: (data.get('itx') ?? []).map(SignedTxnWithAD.fromEncodingData)\n    });\n  }\n}\nexport class ApplyData {\n  static get encodingSchema() {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      this.encodingSchemaValue.pushEntries(...allOmitEmpty([{\n        key: 'ca',\n        // closingAmount\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'aca',\n        // assetClosingAmount\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'rs',\n        // senderRewards\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'rr',\n        // receiverRewards\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'rc',\n        // closeRewards\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'dt',\n        // evalDelta\n        valueSchema: new OptionalSchema(EvalDelta.encodingSchema)\n      }, {\n        key: 'caid',\n        // configAsset\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }, {\n        key: 'apid',\n        // applicationID\n        valueSchema: new OptionalSchema(new Uint64Schema())\n      }]));\n    }\n    return this.encodingSchemaValue;\n  }\n  constructor(params) {\n    this.closingAmount = params.closingAmount;\n    this.assetClosingAmount = params.assetClosingAmount;\n    this.senderRewards = params.senderRewards;\n    this.receiverRewards = params.receiverRewards;\n    this.closeRewards = params.closeRewards;\n    this.evalDelta = params.evalDelta;\n    this.configAsset = params.configAsset;\n    this.applicationID = params.applicationID;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return ApplyData.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['ca', this.closingAmount], ['aca', this.assetClosingAmount], ['rs', this.senderRewards], ['rr', this.receiverRewards], ['rc', this.closeRewards], ['dt', this.evalDelta ? this.evalDelta.toEncodingData() : undefined], ['caid', this.configAsset], ['apid', this.applicationID]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ApplyData: ${data}`);\n    }\n    return new ApplyData({\n      closingAmount: data.get('ca'),\n      assetClosingAmount: data.get('aca'),\n      senderRewards: data.get('rs'),\n      receiverRewards: data.get('rr'),\n      closeRewards: data.get('rc'),\n      evalDelta: data.get('dt') ? EvalDelta.fromEncodingData(data.get('dt')) : undefined,\n      configAsset: data.get('caid'),\n      applicationID: data.get('apid')\n    });\n  }\n}\nexport class SignedTxnWithAD {\n  static get encodingSchema() {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      this.encodingSchemaValue.pushEntries(...allOmitEmpty([{\n        key: '',\n        valueSchema: SignedTransaction.encodingSchema,\n        embedded: true\n      }, {\n        key: '',\n        valueSchema: ApplyData.encodingSchema,\n        embedded: true\n      }]));\n    }\n    return this.encodingSchemaValue;\n  }\n  constructor(params) {\n    this.signedTxn = params.signedTxn;\n    this.applyData = params.applyData;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return SignedTxnWithAD.encodingSchema;\n  }\n  toEncodingData() {\n    return combineMaps(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);\n    }\n    return new SignedTxnWithAD({\n      signedTxn: SignedTransaction.fromEncodingData(data),\n      applyData: ApplyData.fromEncodingData(data)\n    });\n  }\n}\n/**\n * SignedTxnInBlock is how a signed transaction is encoded in a block.\n */\nexport class SignedTxnInBlock {\n  constructor(params) {\n    this.signedTxn = params.signedTxn;\n    this.hasGenesisID = params.hasGenesisID;\n    this.hasGenesisHash = params.hasGenesisHash;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return SignedTxnInBlock.encodingSchema;\n  }\n  toEncodingData() {\n    const data = new Map([['hgi', this.hasGenesisID], ['hgh', this.hasGenesisHash]]);\n    return combineMaps(data, this.signedTxn.toEncodingData());\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);\n    }\n    return new SignedTxnInBlock({\n      signedTxn: SignedTxnWithAD.fromEncodingData(data),\n      hasGenesisID: data.get('hgi'),\n      hasGenesisHash: data.get('hgh')\n    });\n  }\n}\nSignedTxnInBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: '',\n  valueSchema: SignedTxnWithAD.encodingSchema,\n  embedded: true\n}, {\n  key: 'hgi',\n  // hasGenesisID\n  valueSchema: new BooleanSchema()\n}, {\n  key: 'hgh',\n  // hasGenesisHash\n  valueSchema: new BooleanSchema()\n}]));\n/**\n * A Block contains the Payset and metadata corresponding to a given Round.\n */\nexport class Block {\n  constructor(params) {\n    this.header = params.header;\n    this.payset = params.payset;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return Block.encodingSchema;\n  }\n  toEncodingData() {\n    const data = new Map([['txns', this.payset.map(p => p.toEncodingData())]]);\n    return combineMaps(data, this.header.toEncodingData());\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded BlockHeader: ${data}`);\n    }\n    return new Block({\n      header: BlockHeader.fromEncodingData(data),\n      payset: data.get('txns').map(SignedTxnInBlock.fromEncodingData)\n    });\n  }\n}\nBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: '',\n  valueSchema: BlockHeader.encodingSchema,\n  embedded: true\n}, {\n  key: 'txns',\n  // payset\n  valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema)\n}]));","map":{"version":3,"names":["NamedMapSchema","Uint64MapSchema","SpecialCaseBinaryStringMapSchema","SpecialCaseBinaryStringSchema","ArraySchema","StringSchema","BooleanSchema","Uint64Schema","AddressSchema","ByteArraySchema","FixedLengthByteArraySchema","OptionalSchema","allOmitEmpty","combineMaps","convertMap","BlockHashSchema","SignedTransaction","StateProofTrackingData","constructor","params","stateProofVotersCommitment","stateProofOnlineTotalWeight","stateProofNextRound","getEncodingSchema","encodingSchema","toEncodingData","Map","fromEncodingData","data","Error","get","key","valueSchema","TxnCommitments","nativeSha512_256Commitment","sha256Commitment","RewardState","feeSink","rewardsPool","rewardsLevel","rewardsRate","rewardsResidue","rewardsRecalculationRound","UpgradeState","currentProtocol","nextProtocol","nextProtocolApprovals","nextProtocolVoteBefore","nextProtocolSwitchOn","UpgradeVote","upgradePropose","upgradeDelay","upgradeApprove","ParticipationUpdates","expiredParticipationAccounts","absentParticipationAccounts","BlockHeader","round","branch","seed","txnCommitments","timestamp","genesisID","genesisHash","proposer","feesCollected","bonus","proposerPayout","rewardState","upgradeState","upgradeVote","txnCounter","stateproofTracking","participationUpdates","value","Number","embedded","ValueDelta","action","bytes","uint","EvalDelta","encodingSchemaValue","pushEntries","SignedTxnWithAD","globalDelta","localDeltas","sharedAccts","logs","innerTxns","k","v","map","t","undefined","ApplyData","closingAmount","assetClosingAmount","senderRewards","receiverRewards","closeRewards","evalDelta","configAsset","applicationID","signedTxn","applyData","SignedTxnInBlock","hasGenesisID","hasGenesisHash","Block","header","payset","p"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\types\\block.ts"],"sourcesContent":["import { Encodable, Schema } from '../encoding/encoding.js';\nimport {\n  NamedMapSchema,\n  Uint64MapSchema,\n  SpecialCaseBinaryStringMapSchema,\n  SpecialCaseBinaryStringSchema,\n  ArraySchema,\n  StringSchema,\n  BooleanSchema,\n  Uint64Schema,\n  AddressSchema,\n  ByteArraySchema,\n  FixedLengthByteArraySchema,\n  OptionalSchema,\n  allOmitEmpty,\n  combineMaps,\n  convertMap,\n  BlockHashSchema,\n} from '../encoding/schema/index.js';\nimport { Address } from '../encoding/address.js';\nimport { SignedTransaction } from '../signedTransaction.js';\n\n/**\n * StateProofTrackingData tracks the status of state proofs.\n */\nexport class StateProofTrackingData implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'v', // stateProofVotersCommitment\n        valueSchema: new ByteArraySchema(),\n      },\n      {\n        key: 't', // stateProofOnlineTotalWeight\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'n', // stateProofNextRound\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  /**\n   * StateProofVotersCommitment is the root of a vector commitment containing the online accounts\n   * that will help sign a state proof.  The VC root, and the state proof, happen on blocks that are\n   * a multiple of ConsensusParams.StateProofRounds.  For blocks that are not a multiple of\n   * ConsensusParams.StateProofRounds, this value is zero.\n   */\n  public stateProofVotersCommitment: Uint8Array;\n\n  /**\n   * StateProofOnlineTotalWeight is the total number of microalgos held by the online accounts during\n   * the StateProof round (or zero, if the merkle root is zero - no commitment for StateProof voters).\n   * This is intended for computing the threshold of votes to expect from StateProofVotersCommitment.\n   */\n  public stateProofOnlineTotalWeight: bigint;\n\n  /**\n   * StateProofNextRound is the next round for which we will accept a StateProof transaction.\n   */\n  public stateProofNextRound: bigint;\n\n  public constructor(params: {\n    stateProofVotersCommitment: Uint8Array;\n    stateProofOnlineTotalWeight: bigint;\n    stateProofNextRound: bigint;\n  }) {\n    this.stateProofVotersCommitment = params.stateProofVotersCommitment;\n    this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;\n    this.stateProofNextRound = params.stateProofNextRound;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return StateProofTrackingData.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['v', this.stateProofVotersCommitment],\n      ['t', this.stateProofOnlineTotalWeight],\n      ['n', this.stateProofNextRound],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): StateProofTrackingData {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);\n    }\n    return new StateProofTrackingData({\n      stateProofVotersCommitment: data.get('v'),\n      stateProofOnlineTotalWeight: data.get('t'),\n      stateProofNextRound: data.get('n'),\n    });\n  }\n}\n\n/**\n * TxnCommitments represents the commitments computed from the transactions in the block.\n * It contains multiple commitments based on different algorithms and hash functions, to support\n * different use cases.\n */\nexport class TxnCommitments implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'txn', // nativeSha512_256Commitment\n        valueSchema: new FixedLengthByteArraySchema(32),\n      },\n      {\n        key: 'txn256', // sha256Commitment\n        valueSchema: new FixedLengthByteArraySchema(32),\n      },\n    ])\n  );\n\n  /**\n   * Root of transaction merkle tree using SHA512_256 hash function. This commitment is computed\n   * based on the PaysetCommit type specified in the block's consensus protocol.\n   */\n  public nativeSha512_256Commitment: Uint8Array;\n\n  /**\n   * Root of transaction vector commitment merkle tree using SHA256 hash function\n   */\n  public sha256Commitment: Uint8Array;\n\n  constructor(params: {\n    nativeSha512_256Commitment: Uint8Array;\n    sha256Commitment: Uint8Array;\n  }) {\n    this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;\n    this.sha256Commitment = params.sha256Commitment;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return TxnCommitments.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['txn', this.nativeSha512_256Commitment],\n      ['txn256', this.sha256Commitment],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): TxnCommitments {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded TxnCommitments: ${data}`);\n    }\n    return new TxnCommitments({\n      nativeSha512_256Commitment: data.get('txn'),\n      sha256Commitment: data.get('txn256'),\n    });\n  }\n}\n\n/**\n * RewardsState represents the global parameters controlling the rate at which accounts accrue rewards.\n */\nexport class RewardState implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'fees', // feeSink\n        valueSchema: new AddressSchema(),\n      },\n      {\n        key: 'rwd', // rewardsPool\n        valueSchema: new AddressSchema(),\n      },\n      {\n        key: 'earn', // rewardsLevel\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'rate', // rewardsRate\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'frac', // rewardsResidue\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'rwcalr', // rewardsRecalculationRound\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  /**\n   * The FeeSink address.\n   */\n  public feeSink: Address;\n\n  /**\n   * The RewardsPool address.\n   */\n  public rewardsPool: Address;\n\n  /**\n   * RewardsLevel specifies how many rewards, in MicroAlgos, have been distributed to each\n   * config.Protocol.RewardUnit of MicroAlgos since genesis.\n   */\n  public rewardsLevel: bigint;\n\n  /**\n   * The number of new MicroAlgos added to the participation stake from rewards at the next round.\n   */\n  public rewardsRate: bigint;\n\n  /**\n   * The number of leftover MicroAlgos after the distribution of RewardsRate/rewardUnits MicroAlgos for\n   * every reward unit in the next round.\n   */\n  public rewardsResidue: bigint;\n\n  /**\n   * The round at which the RewardsRate will be recalculated.\n   */\n  public rewardsRecalculationRound: bigint;\n\n  constructor(params: {\n    feeSink: Address;\n    rewardsPool: Address;\n    rewardsLevel: bigint;\n    rewardsRate: bigint;\n    rewardsResidue: bigint;\n    rewardsRecalculationRound: bigint;\n  }) {\n    this.feeSink = params.feeSink;\n    this.rewardsPool = params.rewardsPool;\n    this.rewardsLevel = params.rewardsLevel;\n    this.rewardsRate = params.rewardsRate;\n    this.rewardsResidue = params.rewardsResidue;\n    this.rewardsRecalculationRound = params.rewardsRecalculationRound;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return RewardState.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['fees', this.feeSink],\n      ['rwd', this.rewardsPool],\n      ['earn', this.rewardsLevel],\n      ['rate', this.rewardsRate],\n      ['frac', this.rewardsResidue],\n      ['rwcalr', this.rewardsRecalculationRound],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): RewardState {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded RewardState: ${data}`);\n    }\n    return new RewardState({\n      feeSink: data.get('fees'),\n      rewardsPool: data.get('rwd'),\n      rewardsLevel: data.get('earn'),\n      rewardsRate: data.get('rate'),\n      rewardsResidue: data.get('frac'),\n      rewardsRecalculationRound: data.get('rwcalr'),\n    });\n  }\n}\n\n/**\n * UpgradeState tracks the protocol upgrade state machine.  It is, strictly speaking, computable from\n * the history of all UpgradeVotes but we keep it in the block for explicitness and convenience\n * (instead of materializing it separately, like balances).\n */\nexport class UpgradeState implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'proto', // currentProtocol\n        valueSchema: new StringSchema(),\n      },\n      {\n        key: 'nextproto', // nextProtocol\n        valueSchema: new StringSchema(),\n      },\n      {\n        key: 'nextyes', // nextProtocolApprovals\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'nextbefore', // nextProtocolVoteBefore\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'nextswitch', // nextProtocolSwitchOn\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  public currentProtocol: string;\n\n  public nextProtocol: string;\n\n  public nextProtocolApprovals: bigint;\n\n  /**\n   * NextProtocolVoteBefore specify the last voting round for the next protocol proposal. If there\n   * is no voting for an upgrade taking place, this would be zero.\n   */\n  public nextProtocolVoteBefore: bigint;\n\n  /**\n   * NextProtocolSwitchOn specify the round number at which the next protocol would be adopted. If\n   * there is no upgrade taking place, nor a wait for the next protocol, this would be zero.\n   */\n  public nextProtocolSwitchOn: bigint;\n\n  public constructor(params: {\n    currentProtocol: string;\n    nextProtocol: string;\n    nextProtocolApprovals: bigint;\n    nextProtocolVoteBefore: bigint;\n    nextProtocolSwitchOn: bigint;\n  }) {\n    this.currentProtocol = params.currentProtocol;\n    this.nextProtocol = params.nextProtocol;\n    this.nextProtocolApprovals = params.nextProtocolApprovals;\n    this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;\n    this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return UpgradeState.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['proto', this.currentProtocol],\n      ['nextproto', this.nextProtocol],\n      ['nextyes', this.nextProtocolApprovals],\n      ['nextbefore', this.nextProtocolVoteBefore],\n      ['nextswitch', this.nextProtocolSwitchOn],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): UpgradeState {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded UpgradeState: ${data}`);\n    }\n    return new UpgradeState({\n      currentProtocol: data.get('proto'),\n      nextProtocol: data.get('nextproto'),\n      nextProtocolApprovals: data.get('nextyes'),\n      nextProtocolVoteBefore: data.get('nextbefore'),\n      nextProtocolSwitchOn: data.get('nextswitch'),\n    });\n  }\n}\n\n/**\n * UpgradeVote represents the vote of the block proposer with respect to protocol upgrades.\n */\nexport class UpgradeVote implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'upgradeprop', // upgradePropose\n        valueSchema: new StringSchema(),\n      },\n      {\n        key: 'upgradedelay', // upgradeDelay\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'upgradeyes', // upgradeApprove\n        valueSchema: new BooleanSchema(),\n      },\n    ])\n  );\n\n  /**\n   * UpgradePropose indicates a proposed upgrade\n   */\n  public upgradePropose: string;\n\n  /**\n   * UpgradeDelay indicates the time between acceptance and execution\n   */\n  public upgradeDelay: bigint;\n\n  /**\n   * UpgradeApprove indicates a yes vote for the current proposal\n   */\n  public upgradeApprove: boolean;\n\n  public constructor(params: {\n    upgradePropose: string;\n    upgradeDelay: bigint;\n    upgradeApprove: boolean;\n  }) {\n    this.upgradePropose = params.upgradePropose;\n    this.upgradeDelay = params.upgradeDelay;\n    this.upgradeApprove = params.upgradeApprove;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return UpgradeVote.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['upgradeprop', this.upgradePropose],\n      ['upgradedelay', this.upgradeDelay],\n      ['upgradeyes', this.upgradeApprove],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): UpgradeVote {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded UpgradeVote: ${data}`);\n    }\n    return new UpgradeVote({\n      upgradePropose: data.get('upgradeprop'),\n      upgradeDelay: data.get('upgradedelay'),\n      upgradeApprove: data.get('upgradeyes'),\n    });\n  }\n}\n\n/**\n * ParticipationUpdates represents participation account data that needs to be checked/acted on by\n * the network\n */\nexport class ParticipationUpdates implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'partupdrmv', // expiredParticipationAccounts\n        valueSchema: new ArraySchema(new AddressSchema()),\n      },\n      {\n        key: 'partupdabs', // absentParticipationAccounts\n        valueSchema: new ArraySchema(new AddressSchema()),\n      },\n    ])\n  );\n\n  /**\n   * ExpiredParticipationAccounts contains a list of online accounts that needs to be converted to\n   * offline since their participation key expired.\n   */\n  public expiredParticipationAccounts: Address[];\n\n  /**\n   * AbsentParticipationAccounts contains a list of online accounts that needs to be converted to\n   * offline since they are not proposing.\n   */\n  public absentParticipationAccounts: Address[];\n\n  public constructor(params: {\n    expiredParticipationAccounts: Address[];\n    absentParticipationAccounts: Address[];\n  }) {\n    this.expiredParticipationAccounts = params.expiredParticipationAccounts;\n    this.absentParticipationAccounts = params.absentParticipationAccounts;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return ParticipationUpdates.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['partupdrmv', this.expiredParticipationAccounts],\n      ['partupdabs', this.absentParticipationAccounts],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): ParticipationUpdates {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);\n    }\n    return new ParticipationUpdates({\n      expiredParticipationAccounts: data.get('partupdrmv'),\n      absentParticipationAccounts: data.get('partupdabs'),\n    });\n  }\n}\n\n/**\n * Represents the metadata and state of a block.\n *\n * For more information, refer to: https://github.com/algorand/go-algorand/blob/master/data/bookkeeping/block.go\n */\nexport class BlockHeader implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'rnd', // round\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'prev', // branch\n        valueSchema: new BlockHashSchema(),\n      },\n      {\n        key: 'seed', // seed\n        valueSchema: new ByteArraySchema(),\n      },\n      {\n        key: '',\n        valueSchema: TxnCommitments.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: 'ts', // timestamp\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'gen', // genesisID\n        valueSchema: new StringSchema(),\n      },\n      {\n        key: 'gh', // genesisHash\n        valueSchema: new FixedLengthByteArraySchema(32),\n      },\n      {\n        key: 'prp', // proposer\n        valueSchema: new AddressSchema(),\n      },\n      {\n        key: 'fc', // feesCollected\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'bi', // bonus\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'pp', // proposerPayout\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: '',\n        valueSchema: RewardState.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: '',\n        valueSchema: UpgradeState.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: '',\n        valueSchema: UpgradeVote.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: 'tc', // txnCounter\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'spt', // stateproofTracking\n        valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema),\n      },\n      {\n        key: '',\n        valueSchema: ParticipationUpdates.encodingSchema,\n        embedded: true,\n      },\n    ])\n  );\n\n  /**\n   * Round number\n   */\n  public round: bigint;\n\n  /**\n   * Previous block hash\n   */\n  public branch: Uint8Array;\n\n  /**\n   * Sortition seed\n   */\n  public seed: Uint8Array;\n\n  public txnCommitments: TxnCommitments;\n\n  /**\n   * Timestamp in seconds since epoch\n   */\n  public timestamp: bigint;\n\n  /**\n   * Genesis ID to which this block belongs.\n   */\n  public genesisID: string;\n\n  /**\n   * Genesis hash to which this block belongs.\n   */\n  public genesisHash: Uint8Array;\n\n  /**\n   *  Proposer is the proposer of this block. Like the Seed, agreement adds this after the block is\n   * assembled by the transaction pool, so that the same block can be prepared for multiple\n   * participating accounts in the same node. Populated if proto.Payouts.Enabled\n   */\n  public proposer: Address;\n\n  /**\n   * FeesCollected is the sum of all fees paid by transactions in this block. Populated if\n   * proto.EnableMining.\n   */\n  public feesCollected: bigint;\n\n  /**\n   * Bonus is the bonus incentive to be paid for proposing this block.  It begins as a consensus\n   * parameter value, and decays periodically.\n   */\n  public bonus: bigint;\n\n  /**\n   * ProposerPayout is the amount that should be moved from the FeeSink to the Proposer at the start\n   * of the next block.  It is basically the bonus + the payouts percent of FeesCollected, but may\n   * be zero'd by proposer ineligibility.\n   */\n  public proposerPayout: bigint;\n\n  public rewardState: RewardState;\n\n  public upgradeState: UpgradeState;\n\n  public upgradeVote: UpgradeVote;\n\n  /**\n   * TxnCounter is the number of the next transaction that will be committed after this block. Genesis\n   * blocks can start at either 0 or 1000, depending on a consensus parameter (AppForbidLowResources).\n   */\n  public txnCounter: bigint;\n\n  /**\n   * StateProofTracking tracks the status of the state proofs, potentially for multiple types of\n   * ASPs (Algorand's State Proofs).\n   */\n  public stateproofTracking: Map<number, StateProofTrackingData>;\n\n  public participationUpdates: ParticipationUpdates;\n\n  public constructor(params: {\n    round: bigint;\n    branch: Uint8Array;\n    seed: Uint8Array;\n    txnCommitments: TxnCommitments;\n    timestamp: bigint;\n    genesisID: string;\n    genesisHash: Uint8Array;\n    proposer: Address;\n    feesCollected: bigint;\n    bonus: bigint;\n    proposerPayout: bigint;\n    rewardState: RewardState;\n    upgradeState: UpgradeState;\n    upgradeVote: UpgradeVote;\n    txnCounter: bigint;\n    stateproofTracking: Map<number, StateProofTrackingData>;\n    participationUpdates: ParticipationUpdates;\n  }) {\n    this.round = params.round;\n    this.branch = params.branch;\n    this.seed = params.seed;\n    this.txnCommitments = params.txnCommitments;\n    this.timestamp = params.timestamp;\n    this.genesisID = params.genesisID;\n    this.genesisHash = params.genesisHash;\n    this.proposer = params.proposer;\n    this.feesCollected = params.feesCollected;\n    this.bonus = params.bonus;\n    this.proposerPayout = params.proposerPayout;\n    this.rewardState = params.rewardState;\n    this.upgradeState = params.upgradeState;\n    this.upgradeVote = params.upgradeVote;\n    this.txnCounter = params.txnCounter;\n    this.stateproofTracking = params.stateproofTracking;\n    this.participationUpdates = params.participationUpdates;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return BlockHeader.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    const data = new Map<string, unknown>([\n      ['rnd', this.round],\n      ['prev', this.branch],\n      ['seed', this.seed],\n      ['ts', this.timestamp],\n      ['gen', this.genesisID],\n      ['gh', this.genesisHash],\n      ['prp', this.proposer],\n      ['fc', this.feesCollected],\n      ['bi', this.bonus],\n      ['pp', this.proposerPayout],\n      ['tc', this.txnCounter],\n      [\n        'spt',\n        convertMap(this.stateproofTracking, (key, value) => [\n          key,\n          value.toEncodingData(),\n        ]),\n      ],\n    ]);\n    return combineMaps(\n      data,\n      this.txnCommitments.toEncodingData(),\n      this.rewardState.toEncodingData(),\n      this.upgradeState.toEncodingData(),\n      this.upgradeVote.toEncodingData(),\n      this.participationUpdates.toEncodingData()\n    );\n  }\n\n  public static fromEncodingData(data: unknown): BlockHeader {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded BlockHeader: ${data}`);\n    }\n    return new BlockHeader({\n      round: data.get('rnd'),\n      branch: data.get('prev'),\n      seed: data.get('seed'),\n      txnCommitments: TxnCommitments.fromEncodingData(data),\n      timestamp: data.get('ts'),\n      genesisID: data.get('gen'),\n      genesisHash: data.get('gh'),\n      proposer: data.get('prp'),\n      feesCollected: data.get('fc'),\n      bonus: data.get('bi'),\n      proposerPayout: data.get('pp'),\n      rewardState: RewardState.fromEncodingData(data),\n      upgradeState: UpgradeState.fromEncodingData(data),\n      upgradeVote: UpgradeVote.fromEncodingData(data),\n      txnCounter: data.get('tc'),\n      stateproofTracking: convertMap(\n        data.get('spt') as Map<bigint, unknown>,\n        (key, value) => [\n          Number(key),\n          StateProofTrackingData.fromEncodingData(value),\n        ]\n      ),\n      participationUpdates: ParticipationUpdates.fromEncodingData(data),\n    });\n  }\n}\n\nexport class ValueDelta implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'at', // action\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'bs', // bytes\n        valueSchema: new SpecialCaseBinaryStringSchema(),\n      },\n      {\n        key: 'ui', // uint\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  public action: number;\n  public bytes: Uint8Array;\n  public uint: bigint;\n\n  public constructor(params: {\n    action: number;\n    bytes: Uint8Array;\n    uint: bigint;\n  }) {\n    this.action = params.action;\n    this.bytes = params.bytes;\n    this.uint = params.uint;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return ValueDelta.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['at', this.action],\n      ['bs', this.bytes],\n      ['ui', this.uint],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): ValueDelta {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ValueDelta: ${data}`);\n    }\n    return new ValueDelta({\n      action: Number(data.get('at')),\n      bytes: data.get('bs'),\n      uint: data.get('ui'),\n    });\n  }\n}\n\nexport class EvalDelta implements Encodable {\n  private static encodingSchemaValue: Schema | undefined;\n\n  public static get encodingSchema(): Schema {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      (this.encodingSchemaValue as NamedMapSchema).pushEntries(\n        ...allOmitEmpty([\n          {\n            key: 'gd', // globalDelta\n            valueSchema: new OptionalSchema(\n              new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)\n            ),\n          },\n          {\n            key: 'ld', // localDeltas\n            valueSchema: new OptionalSchema(\n              new Uint64MapSchema(\n                new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)\n              )\n            ),\n          },\n          {\n            key: 'sa', // sharedAccts\n            valueSchema: new OptionalSchema(\n              new ArraySchema(new AddressSchema())\n            ),\n          },\n          {\n            key: 'lg', // logs\n            valueSchema: new OptionalSchema(\n              new ArraySchema(new SpecialCaseBinaryStringSchema())\n            ),\n          },\n          {\n            key: 'itx', // innerTxns\n            valueSchema: new OptionalSchema(\n              // eslint-disable-next-line no-use-before-define\n              new ArraySchema(SignedTxnWithAD.encodingSchema)\n            ),\n          },\n        ])\n      );\n    }\n    return this.encodingSchemaValue;\n  }\n\n  public globalDelta: Map<Uint8Array, ValueDelta>;\n\n  /**\n   * When decoding EvalDeltas, the integer key represents an offset into\n   * [txn.Sender, txn.Accounts[0], txn.Accounts[1], ...]\n   */\n  public localDeltas: Map<number, Map<Uint8Array, ValueDelta>>;\n\n  /**\n   * If a program modifies the local of an account that is not the Sender, or\n   * in txn.Accounts, it must be recorded here, so that the key in LocalDeltas\n   * can refer to it.\n   */\n  public sharedAccts: Address[];\n\n  public logs: Uint8Array[];\n\n  // eslint-disable-next-line no-use-before-define\n  public innerTxns: SignedTxnWithAD[];\n\n  public constructor(params: {\n    globalDelta?: Map<Uint8Array, ValueDelta>;\n    localDeltas?: Map<number, Map<Uint8Array, ValueDelta>>;\n    sharedAccts?: Address[];\n    logs?: Uint8Array[];\n    // eslint-disable-next-line no-use-before-define\n    innerTxns?: SignedTxnWithAD[];\n  }) {\n    this.globalDelta = params.globalDelta ?? new Map<Uint8Array, ValueDelta>();\n    this.localDeltas =\n      params.localDeltas ?? new Map<number, Map<Uint8Array, ValueDelta>>();\n    this.sharedAccts = params.sharedAccts ?? [];\n    this.logs = params.logs ?? [];\n    this.innerTxns = params.innerTxns ?? [];\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return EvalDelta.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      [\n        'gd',\n        convertMap(this.globalDelta, (key, value) => [\n          key,\n          value.toEncodingData(),\n        ]),\n      ],\n      [\n        'ld',\n        convertMap(this.localDeltas, (key, value) => [\n          key,\n          convertMap(value, (k, v) => [k, v.toEncodingData()]),\n        ]),\n      ],\n      ['sa', this.sharedAccts],\n      ['lg', this.logs],\n      ['itx', this.innerTxns.map((t) => t.toEncodingData())],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): EvalDelta {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded EvalDelta: ${data}`);\n    }\n    return new EvalDelta({\n      globalDelta: data.get('gd')\n        ? convertMap(\n            data.get('gd') as Map<Uint8Array, unknown>,\n            (key, value) => [key, ValueDelta.fromEncodingData(value)]\n          )\n        : undefined,\n      localDeltas: data.get('ld')\n        ? convertMap(\n            data.get('ld') as Map<bigint, Map<Uint8Array, unknown>>,\n            (key, value) => [\n              Number(key),\n              convertMap(value, (k, v) => [k, ValueDelta.fromEncodingData(v)]),\n            ]\n          )\n        : undefined,\n      sharedAccts: data.get('sa'),\n      logs: data.get('lg'),\n      // eslint-disable-next-line no-use-before-define\n      innerTxns: (data.get('itx') ?? []).map(SignedTxnWithAD.fromEncodingData),\n    });\n  }\n}\n\nexport class ApplyData implements Encodable {\n  private static encodingSchemaValue: Schema | undefined;\n\n  public static get encodingSchema(): Schema {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      (this.encodingSchemaValue as NamedMapSchema).pushEntries(\n        ...allOmitEmpty([\n          {\n            key: 'ca', // closingAmount\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'aca', // assetClosingAmount\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'rs', // senderRewards\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'rr', // receiverRewards\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'rc', // closeRewards\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'dt', // evalDelta\n            valueSchema: new OptionalSchema(EvalDelta.encodingSchema),\n          },\n          {\n            key: 'caid', // configAsset\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n          {\n            key: 'apid', // applicationID\n            valueSchema: new OptionalSchema(new Uint64Schema()),\n          },\n        ])\n      );\n    }\n    return this.encodingSchemaValue;\n  }\n\n  /**\n   * Closing amount for transaction.\n   */\n  public closingAmount?: bigint;\n\n  /**\n   * Closing amount for asset transaction.\n   */\n  public assetClosingAmount?: bigint;\n\n  /**\n   * Rewards applied to the Sender.\n   */\n  public senderRewards?: bigint;\n\n  /**\n   * Rewards applied to the Receiver.\n   */\n  public receiverRewards?: bigint;\n\n  /**\n   * Rewards applied to the CloseRemainderTo account.\n   */\n  public closeRewards?: bigint;\n\n  public evalDelta?: EvalDelta;\n\n  /**\n   * If an ASA is being created, this is its newly created ID. Else 0.\n   */\n  public configAsset?: bigint;\n\n  /**\n   * If an application is being created, this is its newly created ID. Else 0.\n   */\n  public applicationID?: bigint;\n\n  public constructor(params: {\n    closingAmount?: bigint;\n    assetClosingAmount?: bigint;\n    senderRewards?: bigint;\n    receiverRewards?: bigint;\n    closeRewards?: bigint;\n    evalDelta?: EvalDelta;\n    configAsset?: bigint;\n    applicationID?: bigint;\n  }) {\n    this.closingAmount = params.closingAmount;\n    this.assetClosingAmount = params.assetClosingAmount;\n    this.senderRewards = params.senderRewards;\n    this.receiverRewards = params.receiverRewards;\n    this.closeRewards = params.closeRewards;\n    this.evalDelta = params.evalDelta;\n    this.configAsset = params.configAsset;\n    this.applicationID = params.applicationID;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return ApplyData.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['ca', this.closingAmount],\n      ['aca', this.assetClosingAmount],\n      ['rs', this.senderRewards],\n      ['rr', this.receiverRewards],\n      ['rc', this.closeRewards],\n      ['dt', this.evalDelta ? this.evalDelta.toEncodingData() : undefined],\n      ['caid', this.configAsset],\n      ['apid', this.applicationID],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): ApplyData {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded ApplyData: ${data}`);\n    }\n    return new ApplyData({\n      closingAmount: data.get('ca'),\n      assetClosingAmount: data.get('aca'),\n      senderRewards: data.get('rs'),\n      receiverRewards: data.get('rr'),\n      closeRewards: data.get('rc'),\n      evalDelta: data.get('dt')\n        ? EvalDelta.fromEncodingData(data.get('dt'))\n        : undefined,\n      configAsset: data.get('caid'),\n      applicationID: data.get('apid'),\n    });\n  }\n}\n\nexport class SignedTxnWithAD implements Encodable {\n  private static encodingSchemaValue: Schema | undefined;\n\n  public static get encodingSchema(): Schema {\n    // This is declared like this in order to break the circular dependency of\n    // SignedTxnWithAD -> ApplyData -> EvalDelta -> SignedTxnWithAD\n    if (!this.encodingSchemaValue) {\n      this.encodingSchemaValue = new NamedMapSchema([]);\n      (this.encodingSchemaValue as NamedMapSchema).pushEntries(\n        ...allOmitEmpty([\n          {\n            key: '',\n            valueSchema: SignedTransaction.encodingSchema,\n            embedded: true,\n          },\n          {\n            key: '',\n            valueSchema: ApplyData.encodingSchema,\n            embedded: true,\n          },\n        ])\n      );\n    }\n    return this.encodingSchemaValue;\n  }\n\n  public signedTxn: SignedTransaction;\n\n  public applyData: ApplyData;\n\n  public constructor(params: {\n    signedTxn: SignedTransaction;\n    applyData: ApplyData;\n  }) {\n    this.signedTxn = params.signedTxn;\n    this.applyData = params.applyData;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return SignedTxnWithAD.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return combineMaps(\n      this.signedTxn.toEncodingData(),\n      this.applyData.toEncodingData()\n    );\n  }\n\n  public static fromEncodingData(data: unknown): SignedTxnWithAD {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);\n    }\n    return new SignedTxnWithAD({\n      signedTxn: SignedTransaction.fromEncodingData(data),\n      applyData: ApplyData.fromEncodingData(data),\n    });\n  }\n}\n\n/**\n * SignedTxnInBlock is how a signed transaction is encoded in a block.\n */\nexport class SignedTxnInBlock implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: '',\n        valueSchema: SignedTxnWithAD.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: 'hgi', // hasGenesisID\n        valueSchema: new BooleanSchema(),\n      },\n      {\n        key: 'hgh', // hasGenesisHash\n        valueSchema: new BooleanSchema(),\n      },\n    ])\n  );\n\n  public signedTxn: SignedTxnWithAD;\n\n  public hasGenesisID: boolean;\n\n  public hasGenesisHash: boolean;\n\n  public constructor(params: {\n    signedTxn: SignedTxnWithAD;\n    hasGenesisID: boolean;\n    hasGenesisHash: boolean;\n  }) {\n    this.signedTxn = params.signedTxn;\n    this.hasGenesisID = params.hasGenesisID;\n    this.hasGenesisHash = params.hasGenesisHash;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return SignedTxnInBlock.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    const data = new Map<string, unknown>([\n      ['hgi', this.hasGenesisID],\n      ['hgh', this.hasGenesisHash],\n    ]);\n    return combineMaps(data, this.signedTxn.toEncodingData());\n  }\n\n  public static fromEncodingData(data: unknown): SignedTxnInBlock {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);\n    }\n    return new SignedTxnInBlock({\n      signedTxn: SignedTxnWithAD.fromEncodingData(data),\n      hasGenesisID: data.get('hgi'),\n      hasGenesisHash: data.get('hgh'),\n    });\n  }\n}\n\n/**\n * A Block contains the Payset and metadata corresponding to a given Round.\n */\nexport class Block implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: '',\n        valueSchema: BlockHeader.encodingSchema,\n        embedded: true,\n      },\n      {\n        key: 'txns', // payset\n        valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema),\n      },\n    ])\n  );\n\n  public header: BlockHeader;\n\n  public payset: SignedTxnInBlock[];\n\n  public constructor(params: {\n    header: BlockHeader;\n    payset: SignedTxnInBlock[];\n  }) {\n    this.header = params.header;\n    this.payset = params.payset;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return Block.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    const data = new Map<string, unknown>([\n      ['txns', this.payset.map((p) => p.toEncodingData())],\n    ]);\n    return combineMaps(data, this.header.toEncodingData());\n  }\n\n  public static fromEncodingData(data: unknown): Block {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded BlockHeader: ${data}`);\n    }\n    return new Block({\n      header: BlockHeader.fromEncodingData(data),\n      payset: data.get('txns').map(SignedTxnInBlock.fromEncodingData),\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}