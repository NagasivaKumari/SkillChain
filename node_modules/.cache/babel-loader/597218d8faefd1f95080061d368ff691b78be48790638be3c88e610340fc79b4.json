{"ast":null,"code":"import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport { LogicSigAccount } from './logicsig.js';\nimport { addressFromMultisigPreImg } from './multisig.js';\nfunction signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {\n  if (!lsig.verify(lsigAddress.publicKey)) {\n    throw new Error('Logic signature verification failed. Ensure the program and signature are valid.');\n  }\n  let sgnr;\n  if (!nacl.bytesEqual(lsigAddress.publicKey, txn.sender.publicKey)) {\n    sgnr = lsigAddress;\n  }\n  const signedTxn = new SignedTransaction({\n    lsig,\n    txn,\n    sgnr\n  });\n  return {\n    txID: txn.txID(),\n    blob: encoding.encodeMsgpack(signedTxn)\n  };\n}\n/**\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\n * returns a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n */\nexport function signLogicSigTransactionObject(txn, lsigObject) {\n  let lsig;\n  let lsigAddress;\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = lsigObject.address();\n  } else {\n    lsig = lsigObject;\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = new Address(txn.sender.publicKey);\n    } else if (lsig.msig) {\n      const msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      lsigAddress = addressFromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = lsig.address();\n    }\n  }\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n/**\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\n * a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nexport function signLogicSigTransaction(txn, lsigObject) {\n  return signLogicSigTransactionObject(txn, lsigObject);\n}","map":{"version":3,"names":["nacl","Address","encoding","SignedTransaction","LogicSigAccount","addressFromMultisigPreImg","signLogicSigTransactionWithAddress","txn","lsig","lsigAddress","verify","publicKey","Error","sgnr","bytesEqual","sender","signedTxn","txID","blob","encodeMsgpack","signLogicSigTransactionObject","lsigObject","address","sig","msig","msigMetadata","version","v","threshold","thr","pks","subsig","map","pk","signLogicSigTransaction"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\signing.ts"],"sourcesContent":["import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport { Transaction } from './transaction.js';\nimport { LogicSig, LogicSigAccount } from './logicsig.js';\nimport { addressFromMultisigPreImg } from './multisig.js';\n\nfunction signLogicSigTransactionWithAddress(\n  txn: Transaction,\n  lsig: LogicSig,\n  lsigAddress: Address\n) {\n  if (!lsig.verify(lsigAddress.publicKey)) {\n    throw new Error(\n      'Logic signature verification failed. Ensure the program and signature are valid.'\n    );\n  }\n\n  let sgnr: Address | undefined;\n  if (!nacl.bytesEqual(lsigAddress.publicKey, txn.sender.publicKey)) {\n    sgnr = lsigAddress;\n  }\n\n  const signedTxn = new SignedTransaction({\n    lsig,\n    txn,\n    sgnr,\n  });\n\n  return {\n    txID: txn.txID(),\n    blob: encoding.encodeMsgpack(signedTxn),\n  };\n}\n\n/**\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\n * returns a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n */\nexport function signLogicSigTransactionObject(\n  txn: Transaction,\n  lsigObject: LogicSig | LogicSigAccount\n) {\n  let lsig: LogicSig;\n  let lsigAddress: Address;\n\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = lsigObject.address();\n  } else {\n    lsig = lsigObject;\n\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = new Address(txn.sender.publicKey);\n    } else if (lsig.msig) {\n      const msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map((subsig) => subsig.pk),\n      };\n      lsigAddress = addressFromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = lsig.address();\n    }\n  }\n\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n\n/**\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\n * a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nexport function signLogicSigTransaction(\n  txn: Transaction,\n  lsigObject: LogicSig | LogicSigAccount\n) {\n  return signLogicSigTransactionObject(txn, lsigObject);\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,wBAAwB;AAC9C,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,OAAO,KAAKC,QAAQ,MAAM,wBAAwB;AAClD,SAASC,iBAAiB,QAAQ,wBAAwB;AAE1D,SAAmBC,eAAe,QAAQ,eAAe;AACzD,SAASC,yBAAyB,QAAQ,eAAe;AAEzD,SAASC,kCAAkCA,CACzCC,GAAgB,EAChBC,IAAc,EACdC,WAAoB;EAEpB,IAAI,CAACD,IAAI,CAACE,MAAM,CAACD,WAAW,CAACE,SAAS,CAAC,EAAE;IACvC,MAAM,IAAIC,KAAK,CACb,kFAAkF,CACnF;EACH;EAEA,IAAIC,IAAyB;EAC7B,IAAI,CAACb,IAAI,CAACc,UAAU,CAACL,WAAW,CAACE,SAAS,EAAEJ,GAAG,CAACQ,MAAM,CAACJ,SAAS,CAAC,EAAE;IACjEE,IAAI,GAAGJ,WAAW;EACpB;EAEA,MAAMO,SAAS,GAAG,IAAIb,iBAAiB,CAAC;IACtCK,IAAI;IACJD,GAAG;IACHM;GACD,CAAC;EAEF,OAAO;IACLI,IAAI,EAAEV,GAAG,CAACU,IAAI,EAAE;IAChBC,IAAI,EAAEhB,QAAQ,CAACiB,aAAa,CAACH,SAAS;GACvC;AACH;AAEA;;;;;;;;;AASA,OAAM,SAAUI,6BAA6BA,CAC3Cb,GAAgB,EAChBc,UAAsC;EAEtC,IAAIb,IAAc;EAClB,IAAIC,WAAoB;EAExB,IAAIY,UAAU,YAAYjB,eAAe,EAAE;IACzCI,IAAI,GAAGa,UAAU,CAACb,IAAI;IACtBC,WAAW,GAAGY,UAAU,CAACC,OAAO,EAAE;EACpC,CAAC,MAAM;IACLd,IAAI,GAAGa,UAAU;IAEjB,IAAIb,IAAI,CAACe,GAAG,EAAE;MACZ;MACA;MACA;MACA;MACAd,WAAW,GAAG,IAAIR,OAAO,CAACM,GAAG,CAACQ,MAAM,CAACJ,SAAS,CAAC;IACjD,CAAC,MAAM,IAAIH,IAAI,CAACgB,IAAI,EAAE;MACpB,MAAMC,YAAY,GAAG;QACnBC,OAAO,EAAElB,IAAI,CAACgB,IAAI,CAACG,CAAC;QACpBC,SAAS,EAAEpB,IAAI,CAACgB,IAAI,CAACK,GAAG;QACxBC,GAAG,EAAEtB,IAAI,CAACgB,IAAI,CAACO,MAAM,CAACC,GAAG,CAAED,MAAM,IAAKA,MAAM,CAACE,EAAE;OAChD;MACDxB,WAAW,GAAGJ,yBAAyB,CAACoB,YAAY,CAAC;IACvD,CAAC,MAAM;MACLhB,WAAW,GAAGD,IAAI,CAACc,OAAO,EAAE;IAC9B;EACF;EAEA,OAAOhB,kCAAkC,CAACC,GAAG,EAAEC,IAAI,EAAEC,WAAW,CAAC;AACnE;AAEA;;;;;;;;;;AAUA,OAAM,SAAUyB,uBAAuBA,CACrC3B,GAAgB,EAChBc,UAAsC;EAEtC,OAAOD,6BAA6B,CAACb,GAAG,EAAEc,UAAU,CAAC;AACvD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}