{"ast":null,"code":"import { encodeMsgpack, decodeMsgpack } from './encoding/encoding.js';\nimport { Transaction } from './transaction.js';\nimport { LogicSig } from './logicsig.js';\nimport { encodedMultiSigToEncodingData, encodedMultiSigFromEncodingData, ENCODED_MULTISIG_SCHEMA } from './types/transactions/index.js';\nimport { AddressSchema, FixedLengthByteArraySchema, OptionalSchema, NamedMapSchema, allOmitEmpty } from './encoding/schema/index.js';\nexport class SignedTransaction {\n  constructor({\n    txn,\n    sig,\n    msig,\n    lsig,\n    sgnr\n  }) {\n    this.txn = txn;\n    this.sig = sig;\n    this.msig = msig;\n    this.lsig = lsig;\n    this.sgnr = sgnr;\n    let numberOfSigs = 0;\n    if (sig) numberOfSigs += 1;\n    if (msig) numberOfSigs += 1;\n    if (lsig) numberOfSigs += 1;\n    if (numberOfSigs > 1) {\n      throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);\n    }\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return SignedTransaction.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['txn', this.txn.toEncodingData()], ['sig', this.sig], ['msig', this.msig ? encodedMultiSigToEncodingData(this.msig) : undefined], ['lsig', this.lsig ? this.lsig.toEncodingData() : undefined], ['sgnr', this.sgnr]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTransaction: ${data}`);\n    }\n    return new SignedTransaction({\n      txn: Transaction.fromEncodingData(data.get('txn')),\n      sig: data.get('sig'),\n      msig: data.get('msig') ? encodedMultiSigFromEncodingData(data.get('msig')) : undefined,\n      lsig: data.get('lsig') ? LogicSig.fromEncodingData(data.get('lsig')) : undefined,\n      sgnr: data.get('sgnr')\n    });\n  }\n}\nSignedTransaction.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'txn',\n  valueSchema: Transaction.encodingSchema\n}, {\n  key: 'sig',\n  valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))\n}, {\n  key: 'msig',\n  valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)\n}, {\n  key: 'lsig',\n  valueSchema: new OptionalSchema(LogicSig.encodingSchema)\n}, {\n  key: 'sgnr',\n  valueSchema: new OptionalSchema(new AddressSchema())\n}]));\n/**\n * decodeSignedTransaction takes a Uint8Array (from transaction.signTxn) and converts it to an object\n * containing the Transaction (txn), the signature (sig), and the auth-addr field if applicable (sgnr)\n * @param transactionBuffer - the Uint8Array containing a transaction\n * @returns containing a Transaction, the signature, and possibly an auth-addr field\n */\nexport function decodeSignedTransaction(transactionBuffer) {\n  return decodeMsgpack(transactionBuffer, SignedTransaction);\n}\n/**\n * encodeUnsignedSimulateTransaction takes a txnBuilder.Transaction object,\n * converts it into a SignedTransaction-like object, and converts it to a Buffer.\n *\n * Note: this function should only be used to simulate unsigned transactions.\n *\n * @param txn - Transaction object to simulate.\n */\nexport function encodeUnsignedSimulateTransaction(txn) {\n  const stxn = new SignedTransaction({\n    txn\n  });\n  return encodeMsgpack(stxn);\n}","map":{"version":3,"names":["encodeMsgpack","decodeMsgpack","Transaction","LogicSig","encodedMultiSigToEncodingData","encodedMultiSigFromEncodingData","ENCODED_MULTISIG_SCHEMA","AddressSchema","FixedLengthByteArraySchema","OptionalSchema","NamedMapSchema","allOmitEmpty","SignedTransaction","constructor","txn","sig","msig","lsig","sgnr","numberOfSigs","Error","getEncodingSchema","encodingSchema","toEncodingData","Map","undefined","fromEncodingData","data","get","key","valueSchema","decodeSignedTransaction","transactionBuffer","encodeUnsignedSimulateTransaction","stxn"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\signedTransaction.ts"],"sourcesContent":["import {\n  Encodable,\n  encodeMsgpack,\n  decodeMsgpack,\n} from './encoding/encoding.js';\nimport { Address } from './encoding/address.js';\nimport { Transaction } from './transaction.js';\nimport { LogicSig } from './logicsig.js';\nimport {\n  EncodedMultisig,\n  encodedMultiSigToEncodingData,\n  encodedMultiSigFromEncodingData,\n  ENCODED_MULTISIG_SCHEMA,\n} from './types/transactions/index.js';\nimport {\n  AddressSchema,\n  FixedLengthByteArraySchema,\n  OptionalSchema,\n  NamedMapSchema,\n  allOmitEmpty,\n} from './encoding/schema/index.js';\n\nexport class SignedTransaction implements Encodable {\n  static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'txn',\n        valueSchema: Transaction.encodingSchema,\n      },\n      {\n        key: 'sig',\n        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64)),\n      },\n      {\n        key: 'msig',\n        valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA),\n      },\n      {\n        key: 'lsig',\n        valueSchema: new OptionalSchema(LogicSig.encodingSchema),\n      },\n      {\n        key: 'sgnr',\n        valueSchema: new OptionalSchema(new AddressSchema()),\n      },\n    ])\n  );\n\n  /**\n   * The transaction that was signed\n   */\n  public readonly txn: Transaction;\n\n  /**\n   * Transaction signature\n   */\n  public readonly sig?: Uint8Array;\n\n  /**\n   * Multisig structure\n   */\n  public readonly msig?: EncodedMultisig;\n\n  /**\n   * Logic signature\n   */\n  public readonly lsig?: LogicSig;\n\n  /**\n   * The signer, if signing with a different key than the Transaction type `sender` property indicates\n   */\n  public readonly sgnr?: Address;\n\n  constructor({\n    txn,\n    sig,\n    msig,\n    lsig,\n    sgnr,\n  }: {\n    txn: Transaction;\n    sig?: Uint8Array;\n    msig?: EncodedMultisig;\n    lsig?: LogicSig;\n    sgnr?: Address;\n  }) {\n    this.txn = txn;\n    this.sig = sig;\n    this.msig = msig;\n    this.lsig = lsig;\n    this.sgnr = sgnr;\n\n    let numberOfSigs = 0;\n    if (sig) numberOfSigs += 1;\n    if (msig) numberOfSigs += 1;\n    if (lsig) numberOfSigs += 1;\n    if (numberOfSigs > 1) {\n      throw new Error(\n        `SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`\n      );\n    }\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema() {\n    return SignedTransaction.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['txn', this.txn.toEncodingData()],\n      ['sig', this.sig],\n      [\n        'msig',\n        this.msig ? encodedMultiSigToEncodingData(this.msig) : undefined,\n      ],\n      ['lsig', this.lsig ? this.lsig.toEncodingData() : undefined],\n      ['sgnr', this.sgnr],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): SignedTransaction {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SignedTransaction: ${data}`);\n    }\n    return new SignedTransaction({\n      txn: Transaction.fromEncodingData(data.get('txn')),\n      sig: data.get('sig'),\n      msig: data.get('msig')\n        ? encodedMultiSigFromEncodingData(data.get('msig'))\n        : undefined,\n      lsig: data.get('lsig')\n        ? LogicSig.fromEncodingData(data.get('lsig'))\n        : undefined,\n      sgnr: data.get('sgnr'),\n    });\n  }\n}\n\n/**\n * decodeSignedTransaction takes a Uint8Array (from transaction.signTxn) and converts it to an object\n * containing the Transaction (txn), the signature (sig), and the auth-addr field if applicable (sgnr)\n * @param transactionBuffer - the Uint8Array containing a transaction\n * @returns containing a Transaction, the signature, and possibly an auth-addr field\n */\nexport function decodeSignedTransaction(\n  transactionBuffer: Uint8Array\n): SignedTransaction {\n  return decodeMsgpack(transactionBuffer, SignedTransaction);\n}\n\n/**\n * encodeUnsignedSimulateTransaction takes a txnBuilder.Transaction object,\n * converts it into a SignedTransaction-like object, and converts it to a Buffer.\n *\n * Note: this function should only be used to simulate unsigned transactions.\n *\n * @param txn - Transaction object to simulate.\n */\nexport function encodeUnsignedSimulateTransaction(txn: Transaction) {\n  const stxn = new SignedTransaction({ txn });\n  return encodeMsgpack(stxn);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}