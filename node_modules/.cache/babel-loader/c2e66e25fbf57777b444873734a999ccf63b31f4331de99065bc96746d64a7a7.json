{"ast":null,"code":"import { Uint64Schema, ByteArraySchema, FixedLengthByteArraySchema, ArraySchema, NamedMapSchema, Uint64MapSchema, allOmitEmpty, convertMap } from './encoding/schema/index.js';\nexport class HashFactory {\n  constructor(params) {\n    this.hashType = params.hashType;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return HashFactory.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['t', this.hashType]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded HashFactory: ${data}`);\n    }\n    return new HashFactory({\n      hashType: Number(data.get('t'))\n    });\n  }\n}\nHashFactory.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 't',\n  valueSchema: new Uint64Schema()\n} // hashType\n]));\nexport class MerkleArrayProof {\n  constructor(params) {\n    this.path = params.path;\n    this.hashFactory = params.hashFactory;\n    this.treeDepth = params.treeDepth;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return MerkleArrayProof.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['pth', this.path], ['hsh', this.hashFactory.toEncodingData()], ['td', this.treeDepth]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);\n    }\n    return new MerkleArrayProof({\n      path: data.get('pth'),\n      hashFactory: HashFactory.fromEncodingData(data.get('hsh')),\n      treeDepth: Number(data.get('td'))\n    });\n  }\n}\nMerkleArrayProof.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'pth',\n  // path\n  valueSchema: new ArraySchema(new ByteArraySchema())\n}, {\n  key: 'hsh',\n  // hashFactory\n  valueSchema: HashFactory.encodingSchema\n}, {\n  key: 'td',\n  // treeDepth\n  valueSchema: new Uint64Schema()\n}]));\n/**\n * MerkleSignatureVerifier is used to verify a merkle signature.\n */\nexport class MerkleSignatureVerifier {\n  constructor(params) {\n    this.commitment = params.commitment;\n    this.keyLifetime = params.keyLifetime;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return MerkleSignatureVerifier.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['cmt', this.commitment], ['lf', this.keyLifetime]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);\n    }\n    return new MerkleSignatureVerifier({\n      commitment: data.get('cmt'),\n      keyLifetime: data.get('lf')\n    });\n  }\n}\nMerkleSignatureVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'cmt',\n  // commitment\n  valueSchema: new FixedLengthByteArraySchema(64)\n}, {\n  key: 'lf',\n  // keyLifetime\n  valueSchema: new Uint64Schema()\n}]));\n/**\n * A Participant corresponds to an account whose AccountData.Status is Online, and for which the\n * expected sigRound satisfies AccountData.VoteFirstValid <= sigRound <= AccountData.VoteLastValid.\n *\n * In the Algorand ledger, it is possible for multiple accounts to have the same PK. Thus, the PK is\n * not necessarily unique among Participants. However, each account will produce a unique Participant\n * struct, to avoid potential DoS attacks where one account claims to have the same VoteID PK as\n * another account.\n */\nexport class Participant {\n  constructor(params) {\n    this.pk = params.pk;\n    this.weight = params.weight;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return Participant.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['p', this.pk.toEncodingData()], ['w', this.weight]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded Participant: ${data}`);\n    }\n    return new Participant({\n      pk: MerkleSignatureVerifier.fromEncodingData(data.get('p')),\n      weight: data.get('w')\n    });\n  }\n}\nParticipant.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'p',\n  // pk\n  valueSchema: MerkleSignatureVerifier.encodingSchema\n}, {\n  key: 'w',\n  // weight\n  valueSchema: new Uint64Schema()\n}]));\nexport class FalconVerifier {\n  constructor(params) {\n    this.publicKey = params.publicKey;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return FalconVerifier.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['k', this.publicKey]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded FalconVerifier: ${data}`);\n    }\n    return new FalconVerifier({\n      publicKey: data.get('k')\n    });\n  }\n}\nFalconVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'k',\n  valueSchema: new FixedLengthByteArraySchema(0x701)\n} // publicKey\n]));\n/**\n * FalconSignatureStruct represents a signature in the merkle signature scheme using falcon signatures\n * as an underlying crypto scheme. It consists of an ephemeral public key, a signature, a merkle\n * verification path and an index. The merkle signature considered valid only if the Signature is\n * verified under the ephemeral public key and the Merkle verification path verifies that the\n * ephemeral public key is located at the given index of the tree (for the root given in the\n * long-term public key). More details can be found on Algorand's spec\n */\nexport class FalconSignatureStruct {\n  constructor(params) {\n    this.signature = params.signature;\n    this.vectorCommitmentIndex = params.index;\n    this.proof = params.proof;\n    this.verifyingKey = params.verifyingKey;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return FalconSignatureStruct.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['sig', this.signature], ['idx', this.vectorCommitmentIndex], ['prf', this.proof.toEncodingData()], ['vkey', this.verifyingKey.toEncodingData()]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);\n    }\n    return new FalconSignatureStruct({\n      signature: data.get('sig'),\n      index: data.get('idx'),\n      proof: MerkleArrayProof.fromEncodingData(data.get('prf')),\n      verifyingKey: FalconVerifier.fromEncodingData(data.get('vkey'))\n    });\n  }\n}\nFalconSignatureStruct.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'sig',\n  valueSchema: new ByteArraySchema()\n},\n// signature\n{\n  key: 'idx',\n  valueSchema: new Uint64Schema()\n},\n// index\n{\n  key: 'prf',\n  valueSchema: MerkleArrayProof.encodingSchema\n},\n// proof\n{\n  key: 'vkey',\n  valueSchema: FalconVerifier.encodingSchema\n} // verifyingKey\n]));\n/**\n * A SigslotCommit is a single slot in the sigs array that forms the state proof.\n */\nexport class SigslotCommit {\n  constructor(params) {\n    this.sig = params.sig;\n    this.l = params.l;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return SigslotCommit.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['s', this.sig.toEncodingData()], ['l', this.l]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SigslotCommit: ${data}`);\n    }\n    return new SigslotCommit({\n      sig: FalconSignatureStruct.fromEncodingData(data.get('s')),\n      l: data.get('l')\n    });\n  }\n}\nSigslotCommit.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 's',\n  valueSchema: FalconSignatureStruct.encodingSchema\n},\n// sigslot\n{\n  key: 'l',\n  valueSchema: new Uint64Schema()\n} // l\n]));\n/**\n * Reveal is a single array position revealed as part of a state proof. It reveals an element of the\n * signature array and the corresponding element of the participants array.\n */\nexport class Reveal {\n  constructor(params) {\n    this.sigslot = params.sigslot;\n    this.participant = params.participant;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return Reveal.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['s', this.sigslot.toEncodingData()], ['p', this.participant.toEncodingData()]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded Reveal: ${data}`);\n    }\n    return new Reveal({\n      sigslot: SigslotCommit.fromEncodingData(data.get('s')),\n      participant: Participant.fromEncodingData(data.get('p'))\n    });\n  }\n}\nReveal.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 's',\n  valueSchema: SigslotCommit.encodingSchema\n},\n// sigslotCommit\n{\n  key: 'p',\n  valueSchema: Participant.encodingSchema\n} // participant\n]));\nexport class StateProof {\n  constructor(params) {\n    this.sigCommit = params.sigCommit;\n    this.signedWeight = params.signedWeight;\n    this.sigProofs = params.sigProofs;\n    this.partProofs = params.partProofs;\n    this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;\n    this.reveals = params.reveals;\n    this.positionsToReveal = params.positionsToReveal;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return StateProof.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['c', this.sigCommit], ['w', this.signedWeight], ['S', this.sigProofs.toEncodingData()], ['P', this.partProofs.toEncodingData()], ['v', this.merkleSignatureSaltVersion], ['r', convertMap(this.reveals, (key, value) => [key, value.toEncodingData()])], ['pr', this.positionsToReveal]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProof: ${data}`);\n    }\n    return new StateProof({\n      sigCommit: data.get('c'),\n      signedWeight: data.get('w'),\n      sigProofs: MerkleArrayProof.fromEncodingData(data.get('S')),\n      partProofs: MerkleArrayProof.fromEncodingData(data.get('P')),\n      merkleSignatureSaltVersion: Number(data.get('v')),\n      reveals: convertMap(data.get('r'), (key, value) => [key, Reveal.fromEncodingData(value)]),\n      positionsToReveal: data.get('pr')\n    });\n  }\n}\nStateProof.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'c',\n  // sigCommit\n  valueSchema: new ByteArraySchema()\n}, {\n  key: 'w',\n  // signedWeight\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'S',\n  // sigProofs\n  valueSchema: MerkleArrayProof.encodingSchema\n}, {\n  key: 'P',\n  // partProofs\n  valueSchema: MerkleArrayProof.encodingSchema\n}, {\n  key: 'v',\n  // merkleSignatureSaltVersion\n  valueSchema: new Uint64Schema()\n}, {\n  key: 'r',\n  // reveals\n  valueSchema: new Uint64MapSchema(Reveal.encodingSchema)\n}, {\n  key: 'pr',\n  // positionsToReveal\n  valueSchema: new ArraySchema(new Uint64Schema())\n}]));\nexport class StateProofMessage {\n  constructor(params) {\n    this.blockHeadersCommitment = params.blockHeadersCommitment;\n    this.votersCommitment = params.votersCommitment;\n    this.lnProvenWeight = params.lnProvenWeight;\n    this.firstAttestedRound = params.firstAttestedRound;\n    this.lastAttestedRound = params.lastAttestedRound;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return StateProofMessage.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['b', this.blockHeadersCommitment], ['v', this.votersCommitment], ['P', this.lnProvenWeight], ['f', this.firstAttestedRound], ['l', this.lastAttestedRound]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProofMessage: ${data}`);\n    }\n    return new StateProofMessage({\n      blockHeadersCommitment: data.get('b'),\n      votersCommitment: data.get('v'),\n      lnProvenWeight: data.get('P'),\n      firstAttestedRound: data.get('f'),\n      lastAttestedRound: data.get('l')\n    });\n  }\n  static fromMap(data) {\n    return new StateProofMessage({\n      blockHeadersCommitment: data.get('b'),\n      votersCommitment: data.get('v'),\n      lnProvenWeight: data.get('P'),\n      firstAttestedRound: data.get('f'),\n      lastAttestedRound: data.get('l')\n    });\n  }\n}\nStateProofMessage.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'b',\n  valueSchema: new ByteArraySchema()\n},\n// blockHeadersCommitment\n{\n  key: 'v',\n  valueSchema: new ByteArraySchema()\n},\n// votersCommitment\n{\n  key: 'P',\n  valueSchema: new Uint64Schema()\n},\n// lnProvenWeight\n{\n  key: 'f',\n  valueSchema: new Uint64Schema()\n},\n// firstAttestedRound\n{\n  key: 'l',\n  valueSchema: new Uint64Schema()\n} // lastAttestedRound\n]));","map":{"version":3,"names":["Uint64Schema","ByteArraySchema","FixedLengthByteArraySchema","ArraySchema","NamedMapSchema","Uint64MapSchema","allOmitEmpty","convertMap","HashFactory","constructor","params","hashType","getEncodingSchema","encodingSchema","toEncodingData","Map","fromEncodingData","data","Error","Number","get","key","valueSchema","MerkleArrayProof","path","hashFactory","treeDepth","MerkleSignatureVerifier","commitment","keyLifetime","Participant","pk","weight","FalconVerifier","publicKey","FalconSignatureStruct","signature","vectorCommitmentIndex","index","proof","verifyingKey","SigslotCommit","sig","l","Reveal","sigslot","participant","StateProof","sigCommit","signedWeight","sigProofs","partProofs","merkleSignatureSaltVersion","reveals","positionsToReveal","value","StateProofMessage","blockHeadersCommitment","votersCommitment","lnProvenWeight","firstAttestedRound","lastAttestedRound","fromMap"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\stateproof.ts"],"sourcesContent":["import { Encodable, Schema } from './encoding/encoding.js';\nimport {\n  Uint64Schema,\n  ByteArraySchema,\n  FixedLengthByteArraySchema,\n  ArraySchema,\n  NamedMapSchema,\n  Uint64MapSchema,\n  allOmitEmpty,\n  convertMap,\n} from './encoding/schema/index.js';\n\nexport class HashFactory implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 't', valueSchema: new Uint64Schema() }, // hashType\n    ])\n  );\n\n  public hashType: number;\n\n  public constructor(params: { hashType: number }) {\n    this.hashType = params.hashType;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return HashFactory.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([['t', this.hashType]]);\n  }\n\n  public static fromEncodingData(data: unknown): HashFactory {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded HashFactory: ${data}`);\n    }\n    return new HashFactory({\n      hashType: Number(data.get('t')),\n    });\n  }\n}\n\nexport class MerkleArrayProof implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'pth', // path\n        valueSchema: new ArraySchema(new ByteArraySchema()),\n      },\n      {\n        key: 'hsh', // hashFactory\n        valueSchema: HashFactory.encodingSchema,\n      },\n      {\n        key: 'td', // treeDepth\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  /**\n   * Path is bounded by MaxNumLeavesOnEncodedTree since there could be multiple reveals, and\n   * given the distribution of the elt positions and the depth of the tree, the path length can\n   * increase up to 2^MaxEncodedTreeDepth / 2\n   */\n  public path: Uint8Array[];\n\n  public hashFactory: HashFactory;\n\n  /**\n   * TreeDepth represents the depth of the tree that is being proven. It is the number of edges\n   * from the root to a leaf.\n   */\n  public treeDepth: number;\n\n  public constructor(params: {\n    path: Uint8Array[];\n    hashFactory: HashFactory;\n    treeDepth: number;\n  }) {\n    this.path = params.path;\n    this.hashFactory = params.hashFactory;\n    this.treeDepth = params.treeDepth;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return MerkleArrayProof.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['pth', this.path],\n      ['hsh', this.hashFactory.toEncodingData()],\n      ['td', this.treeDepth],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): MerkleArrayProof {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);\n    }\n    return new MerkleArrayProof({\n      path: data.get('pth'),\n      hashFactory: HashFactory.fromEncodingData(data.get('hsh')),\n      treeDepth: Number(data.get('td')),\n    });\n  }\n}\n\n/**\n * MerkleSignatureVerifier is used to verify a merkle signature.\n */\nexport class MerkleSignatureVerifier implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'cmt', // commitment\n        valueSchema: new FixedLengthByteArraySchema(64),\n      },\n      {\n        key: 'lf', // keyLifetime\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  public commitment: Uint8Array;\n\n  public keyLifetime: bigint;\n\n  public constructor(params: { commitment: Uint8Array; keyLifetime: bigint }) {\n    this.commitment = params.commitment;\n    this.keyLifetime = params.keyLifetime;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return MerkleSignatureVerifier.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['cmt', this.commitment],\n      ['lf', this.keyLifetime],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): MerkleSignatureVerifier {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);\n    }\n    return new MerkleSignatureVerifier({\n      commitment: data.get('cmt'),\n      keyLifetime: data.get('lf'),\n    });\n  }\n}\n\n/**\n * A Participant corresponds to an account whose AccountData.Status is Online, and for which the\n * expected sigRound satisfies AccountData.VoteFirstValid <= sigRound <= AccountData.VoteLastValid.\n *\n * In the Algorand ledger, it is possible for multiple accounts to have the same PK. Thus, the PK is\n * not necessarily unique among Participants. However, each account will produce a unique Participant\n * struct, to avoid potential DoS attacks where one account claims to have the same VoteID PK as\n * another account.\n */\nexport class Participant implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'p', // pk\n        valueSchema: MerkleSignatureVerifier.encodingSchema,\n      },\n      {\n        key: 'w', // weight\n        valueSchema: new Uint64Schema(),\n      },\n    ])\n  );\n\n  /**\n   * pk is the identifier used to verify the signature for a specific participant\n   */\n  public pk: MerkleSignatureVerifier;\n\n  /**\n   * weight is AccountData.MicroAlgos.\n   */\n  public weight: bigint;\n\n  public constructor(params: { pk: MerkleSignatureVerifier; weight: bigint }) {\n    this.pk = params.pk;\n    this.weight = params.weight;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return Participant.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['p', this.pk.toEncodingData()],\n      ['w', this.weight],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): Participant {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded Participant: ${data}`);\n    }\n    return new Participant({\n      pk: MerkleSignatureVerifier.fromEncodingData(data.get('p')),\n      weight: data.get('w'),\n    });\n  }\n}\n\nexport class FalconVerifier implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 'k', valueSchema: new FixedLengthByteArraySchema(0x701) }, // publicKey\n    ])\n  );\n\n  public publicKey: Uint8Array;\n\n  public constructor(params: { publicKey: Uint8Array }) {\n    this.publicKey = params.publicKey;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return FalconVerifier.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([['k', this.publicKey]]);\n  }\n\n  public static fromEncodingData(data: unknown): FalconVerifier {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded FalconVerifier: ${data}`);\n    }\n    return new FalconVerifier({\n      publicKey: data.get('k'),\n    });\n  }\n}\n\n/**\n * FalconSignatureStruct represents a signature in the merkle signature scheme using falcon signatures\n * as an underlying crypto scheme. It consists of an ephemeral public key, a signature, a merkle\n * verification path and an index. The merkle signature considered valid only if the Signature is\n * verified under the ephemeral public key and the Merkle verification path verifies that the\n * ephemeral public key is located at the given index of the tree (for the root given in the\n * long-term public key). More details can be found on Algorand's spec\n */\nexport class FalconSignatureStruct implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 'sig', valueSchema: new ByteArraySchema() }, // signature\n      { key: 'idx', valueSchema: new Uint64Schema() }, // index\n      { key: 'prf', valueSchema: MerkleArrayProof.encodingSchema }, // proof\n      { key: 'vkey', valueSchema: FalconVerifier.encodingSchema }, // verifyingKey\n    ])\n  );\n\n  public signature: Uint8Array;\n  public vectorCommitmentIndex: bigint;\n  public proof: MerkleArrayProof;\n  public verifyingKey: FalconVerifier;\n\n  public constructor(params: {\n    signature: Uint8Array;\n    index: bigint;\n    proof: MerkleArrayProof;\n    verifyingKey: FalconVerifier;\n  }) {\n    this.signature = params.signature;\n    this.vectorCommitmentIndex = params.index;\n    this.proof = params.proof;\n    this.verifyingKey = params.verifyingKey;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return FalconSignatureStruct.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['sig', this.signature],\n      ['idx', this.vectorCommitmentIndex],\n      ['prf', this.proof.toEncodingData()],\n      ['vkey', this.verifyingKey.toEncodingData()],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): FalconSignatureStruct {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);\n    }\n    return new FalconSignatureStruct({\n      signature: data.get('sig'),\n      index: data.get('idx'),\n      proof: MerkleArrayProof.fromEncodingData(data.get('prf')),\n      verifyingKey: FalconVerifier.fromEncodingData(data.get('vkey')),\n    });\n  }\n}\n\n/**\n * A SigslotCommit is a single slot in the sigs array that forms the state proof.\n */\nexport class SigslotCommit implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 's', valueSchema: FalconSignatureStruct.encodingSchema }, // sigslot\n      { key: 'l', valueSchema: new Uint64Schema() }, // l\n    ])\n  );\n\n  /**\n   * Sig is a signature by the participant on the expected message.\n   */\n  public sig: FalconSignatureStruct;\n\n  /**\n   * L is the total weight of signatures in lower-numbered slots. This is initialized once the builder\n   * has collected a sufficient number of signatures.\n   */\n  public l: bigint;\n\n  public constructor(params: { sig: FalconSignatureStruct; l: bigint }) {\n    this.sig = params.sig;\n    this.l = params.l;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return SigslotCommit.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['s', this.sig.toEncodingData()],\n      ['l', this.l],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): SigslotCommit {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded SigslotCommit: ${data}`);\n    }\n    return new SigslotCommit({\n      sig: FalconSignatureStruct.fromEncodingData(data.get('s')),\n      l: data.get('l'),\n    });\n  }\n}\n\n/**\n * Reveal is a single array position revealed as part of a state proof. It reveals an element of the\n * signature array and the corresponding element of the participants array.\n */\nexport class Reveal implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 's', valueSchema: SigslotCommit.encodingSchema }, // sigslotCommit\n      { key: 'p', valueSchema: Participant.encodingSchema }, // participant\n    ])\n  );\n\n  public sigslot: SigslotCommit;\n\n  public participant: Participant;\n\n  public constructor(params: {\n    sigslot: SigslotCommit;\n    participant: Participant;\n  }) {\n    this.sigslot = params.sigslot;\n    this.participant = params.participant;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return Reveal.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['s', this.sigslot.toEncodingData()],\n      ['p', this.participant.toEncodingData()],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): Reveal {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded Reveal: ${data}`);\n    }\n    return new Reveal({\n      sigslot: SigslotCommit.fromEncodingData(data.get('s')),\n      participant: Participant.fromEncodingData(data.get('p')),\n    });\n  }\n}\n\nexport class StateProof implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'c', // sigCommit\n        valueSchema: new ByteArraySchema(),\n      },\n      {\n        key: 'w', // signedWeight\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'S', // sigProofs\n        valueSchema: MerkleArrayProof.encodingSchema,\n      },\n      {\n        key: 'P', // partProofs\n        valueSchema: MerkleArrayProof.encodingSchema,\n      },\n      {\n        key: 'v', // merkleSignatureSaltVersion\n        valueSchema: new Uint64Schema(),\n      },\n      {\n        key: 'r', // reveals\n        valueSchema: new Uint64MapSchema(Reveal.encodingSchema),\n      },\n      {\n        key: 'pr', // positionsToReveal\n        valueSchema: new ArraySchema(new Uint64Schema()),\n      },\n    ])\n  );\n\n  public sigCommit: Uint8Array;\n\n  public signedWeight: bigint;\n\n  public sigProofs: MerkleArrayProof;\n\n  public partProofs: MerkleArrayProof;\n\n  public merkleSignatureSaltVersion: number;\n\n  /**\n   * Reveals is a sparse map from the position being revealed to the corresponding elements from the\n   * sigs and participants arrays.\n   */\n  public reveals: Map<bigint, Reveal>;\n\n  public positionsToReveal: bigint[];\n\n  public constructor(params: {\n    sigCommit: Uint8Array;\n    signedWeight: bigint;\n    sigProofs: MerkleArrayProof;\n    partProofs: MerkleArrayProof;\n    merkleSignatureSaltVersion: number;\n    reveals: Map<bigint, Reveal>;\n    positionsToReveal: bigint[];\n  }) {\n    this.sigCommit = params.sigCommit;\n    this.signedWeight = params.signedWeight;\n    this.sigProofs = params.sigProofs;\n    this.partProofs = params.partProofs;\n    this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;\n    this.reveals = params.reveals;\n    this.positionsToReveal = params.positionsToReveal;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return StateProof.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['c', this.sigCommit],\n      ['w', this.signedWeight],\n      ['S', this.sigProofs.toEncodingData()],\n      ['P', this.partProofs.toEncodingData()],\n      ['v', this.merkleSignatureSaltVersion],\n      [\n        'r',\n        convertMap(this.reveals, (key, value) => [key, value.toEncodingData()]),\n      ],\n      ['pr', this.positionsToReveal],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): StateProof {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProof: ${data}`);\n    }\n    return new StateProof({\n      sigCommit: data.get('c'),\n      signedWeight: data.get('w'),\n      sigProofs: MerkleArrayProof.fromEncodingData(data.get('S')),\n      partProofs: MerkleArrayProof.fromEncodingData(data.get('P')),\n      merkleSignatureSaltVersion: Number(data.get('v')),\n      reveals: convertMap(data.get('r'), (key, value) => [\n        key as bigint,\n        Reveal.fromEncodingData(value),\n      ]),\n      positionsToReveal: data.get('pr'),\n    });\n  }\n}\n\nexport class StateProofMessage implements Encodable {\n  public static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      { key: 'b', valueSchema: new ByteArraySchema() }, // blockHeadersCommitment\n      { key: 'v', valueSchema: new ByteArraySchema() }, // votersCommitment\n      { key: 'P', valueSchema: new Uint64Schema() }, // lnProvenWeight\n      { key: 'f', valueSchema: new Uint64Schema() }, // firstAttestedRound\n      { key: 'l', valueSchema: new Uint64Schema() }, // lastAttestedRound\n    ])\n  );\n\n  public blockHeadersCommitment: Uint8Array;\n\n  public votersCommitment: Uint8Array;\n\n  public lnProvenWeight: bigint;\n\n  public firstAttestedRound: bigint;\n\n  public lastAttestedRound: bigint;\n\n  public constructor(params: {\n    blockHeadersCommitment: Uint8Array;\n    votersCommitment: Uint8Array;\n    lnProvenWeight: bigint;\n    firstAttestedRound: bigint;\n    lastAttestedRound: bigint;\n  }) {\n    this.blockHeadersCommitment = params.blockHeadersCommitment;\n    this.votersCommitment = params.votersCommitment;\n    this.lnProvenWeight = params.lnProvenWeight;\n    this.firstAttestedRound = params.firstAttestedRound;\n    this.lastAttestedRound = params.lastAttestedRound;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  public getEncodingSchema(): Schema {\n    return StateProofMessage.encodingSchema;\n  }\n\n  public toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['b', this.blockHeadersCommitment],\n      ['v', this.votersCommitment],\n      ['P', this.lnProvenWeight],\n      ['f', this.firstAttestedRound],\n      ['l', this.lastAttestedRound],\n    ]);\n  }\n\n  public static fromEncodingData(data: unknown): StateProofMessage {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded StateProofMessage: ${data}`);\n    }\n    return new StateProofMessage({\n      blockHeadersCommitment: data.get('b'),\n      votersCommitment: data.get('v'),\n      lnProvenWeight: data.get('P'),\n      firstAttestedRound: data.get('f'),\n      lastAttestedRound: data.get('l'),\n    });\n  }\n\n  public static fromMap(data: Map<string, unknown>): StateProofMessage {\n    return new StateProofMessage({\n      blockHeadersCommitment: data.get('b') as Uint8Array,\n      votersCommitment: data.get('v') as Uint8Array,\n      lnProvenWeight: data.get('P') as bigint,\n      firstAttestedRound: data.get('f') as bigint,\n      lastAttestedRound: data.get('l') as bigint,\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}