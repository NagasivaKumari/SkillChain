{"ast":null,"code":"import { Application, ApplicationParams, ApplicationStateSchema, DryrunRequest } from './client/v2/algod/models/types.js';\nimport { getApplicationAddress } from './encoding/address.js';\nimport { bytesToHex } from './encoding/binarydata.js';\nimport { TransactionType } from './types/transactions/index.js';\nimport { stringifyJSON } from './utils/utils.js';\nconst defaultAppId = 1380011588;\nconst defaultMaxWidth = 30;\n/**\n * createDryrun takes an Algod Client (from algod.AlgodV2Client) and an array of Signed Transactions\n * from (transaction.SignedTransaction) and creates a DryrunRequest object with relevant balances\n * @param client - the AlgodClient to make requests against\n * @param txns - the array of SignedTransaction to use for generating the DryrunRequest object\n * @param protocolVersion - the string representing the protocol version to use\n * @param latestTimestamp - the timestamp\n * @param round - the round available to some TEAL scripts. Defaults to the current round on the network.\n * @param sources - TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.\n * @returns the DryrunRequest object constructed from the SignedTransactions passed\n */\nexport async function createDryrun({\n  client,\n  txns,\n  protocolVersion,\n  latestTimestamp,\n  round,\n  sources\n}) {\n  const appInfos = [];\n  const acctInfos = [];\n  const apps = [];\n  const assets = [];\n  const accts = [];\n  for (const t of txns) {\n    if (t.txn.type === TransactionType.appl) {\n      accts.push(t.txn.sender.toString());\n      accts.push(...t.txn.applicationCall.accounts.map(a => a.toString()));\n      apps.push(...t.txn.applicationCall.foreignApps);\n      accts.push(...t.txn.applicationCall.foreignApps.map(getApplicationAddress).map(a => a.toString()));\n      assets.push(...t.txn.applicationCall.foreignAssets);\n      // Create application,\n      if (t.txn.applicationCall.appIndex === BigInt(0)) {\n        appInfos.push(new Application({\n          id: defaultAppId,\n          params: new ApplicationParams({\n            creator: t.txn.sender.toString(),\n            approvalProgram: t.txn.applicationCall.approvalProgram,\n            clearStateProgram: t.txn.applicationCall.clearProgram,\n            localStateSchema: new ApplicationStateSchema({\n              numUint: t.txn.applicationCall.numLocalInts,\n              numByteSlice: t.txn.applicationCall.numLocalByteSlices\n            }),\n            globalStateSchema: new ApplicationStateSchema({\n              numUint: t.txn.applicationCall.numGlobalInts,\n              numByteSlice: t.txn.applicationCall.numGlobalByteSlices\n            })\n          })\n        }));\n      } else {\n        const {\n          appIndex\n        } = t.txn.applicationCall;\n        apps.push(appIndex);\n        accts.push(getApplicationAddress(appIndex).toString());\n      }\n    }\n  }\n  // Dedupe and add creator to accts array\n  const assetPromises = [];\n  for (const assetId of new Set(assets)) {\n    assetPromises.push(client.getAssetByID(assetId).do().then(assetInfo => {\n      accts.push(assetInfo.params.creator);\n    }));\n  }\n  // Wait for assets to finish since we append to accts array\n  await Promise.all(assetPromises);\n  // Dedupe and get app info for all apps\n  const appPromises = [];\n  for (const appId of new Set(apps)) {\n    appPromises.push(client.getApplicationByID(appId).do().then(appInfo => {\n      appInfos.push(appInfo);\n      accts.push(appInfo.params.creator.toString());\n    }));\n  }\n  await Promise.all(appPromises);\n  const acctPromises = [];\n  for (const acct of new Set(accts)) {\n    acctPromises.push(client.accountInformation(acct).do().then(acctInfo => {\n      acctInfos.push(acctInfo);\n    }));\n  }\n  await Promise.all(acctPromises);\n  return new DryrunRequest({\n    txns: txns.slice(),\n    accounts: acctInfos,\n    apps: appInfos,\n    latestTimestamp: latestTimestamp ?? 0,\n    round: round ?? 0,\n    protocolVersion: protocolVersion ?? '',\n    sources: sources ?? []\n  });\n}\nfunction truncate(str, maxValueWidth) {\n  if (str.length > maxValueWidth && maxValueWidth > 0) {\n    return `${str.slice(0, maxValueWidth)}...`;\n  }\n  return str;\n}\nfunction scratchToString(prevScratch, currScratch) {\n  if (currScratch.length === 0) return '';\n  let newScratchIdx = null;\n  for (let idx = 0; idx < currScratch.length; idx++) {\n    if (idx > prevScratch.length) {\n      newScratchIdx = idx;\n      continue;\n    }\n    if (stringifyJSON(prevScratch[idx]) !== stringifyJSON(currScratch[idx])) {\n      newScratchIdx = idx;\n    }\n  }\n  if (newScratchIdx == null) return '';\n  const newScratch = currScratch[newScratchIdx];\n  if (newScratch.bytes.length > 0) {\n    return `${newScratchIdx} = 0x${bytesToHex(newScratch.bytes)}`;\n  }\n  return `${newScratchIdx} = ${newScratch.uint.toString()}`;\n}\nfunction stackToString(stack, reverse) {\n  const svs = reverse ? stack.reverse() : stack;\n  return `[${svs.map(sv => {\n    switch (sv.type) {\n      case 1:\n        return `0x${bytesToHex(sv.bytes)}`;\n      case 2:\n        return sv.uint.toString();\n      default:\n        return '';\n    }\n  }).join(', ')}]`;\n}\nfunction dryrunTrace(trace, disassembly, spc) {\n  const maxWidth = spc.maxValueWidth || defaultMaxWidth;\n  // Create the array of arrays, each sub array contains N columns\n  const lines = [['pc#', 'ln#', 'source', 'scratch', 'stack']];\n  for (let idx = 0; idx < trace.length; idx++) {\n    const {\n      line,\n      error,\n      pc,\n      scratch,\n      stack\n    } = trace[idx];\n    const currScratch = scratch !== undefined ? scratch : [];\n    const prevScratch = idx > 0 && trace[idx - 1].scratch !== undefined ? trace[idx - 1].scratch : [];\n    const src = !error ? disassembly[line] : `!! ${error} !!`;\n    lines.push([pc.toString().padEnd(3, ' '), line.toString().padEnd(3, ' '), truncate(src, maxWidth), truncate(scratchToString(prevScratch, currScratch), maxWidth), truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)]);\n  }\n  // Get the max length for each column\n  const maxLengths = lines.reduce((prev, curr) => {\n    const newVal = new Array(lines[0].length).fill(0);\n    for (let idx = 0; idx < prev.length; idx++) {\n      newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];\n    }\n    return newVal;\n  }, new Array(lines[0].length).fill(0));\n  return `${lines.map(line => line.map((v, idx) => v.padEnd(maxLengths[idx] + 1, ' ')).join('|').trim()).join('\\n')}\\n`;\n}\nexport function dryrunTxnResultAppTrace(result, spc) {\n  if (!result.appCallTrace || !result.disassembly) return '';\n  let conf = spc;\n  if (spc !== undefined) conf = spc;else {\n    conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: false\n    };\n  }\n  return dryrunTrace(result.appCallTrace, result.disassembly, conf);\n}\nexport function dryrunTxnResultLogicSigTrace(result, spc) {\n  if (!result.logicSigTrace || !result.logicSigDisassembly) return '';\n  let conf;\n  if (spc !== undefined) conf = spc;else {\n    conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: true\n    };\n  }\n  return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);\n}","map":{"version":3,"names":["Application","ApplicationParams","ApplicationStateSchema","DryrunRequest","getApplicationAddress","bytesToHex","TransactionType","stringifyJSON","defaultAppId","defaultMaxWidth","createDryrun","client","txns","protocolVersion","latestTimestamp","round","sources","appInfos","acctInfos","apps","assets","accts","t","txn","type","appl","push","sender","toString","applicationCall","accounts","map","a","foreignApps","foreignAssets","appIndex","BigInt","id","params","creator","approvalProgram","clearStateProgram","clearProgram","localStateSchema","numUint","numLocalInts","numByteSlice","numLocalByteSlices","globalStateSchema","numGlobalInts","numGlobalByteSlices","assetPromises","assetId","Set","getAssetByID","do","then","assetInfo","Promise","all","appPromises","appId","getApplicationByID","appInfo","acctPromises","acct","accountInformation","acctInfo","slice","truncate","str","maxValueWidth","length","scratchToString","prevScratch","currScratch","newScratchIdx","idx","newScratch","bytes","uint","stackToString","stack","reverse","svs","sv","join","dryrunTrace","trace","disassembly","spc","maxWidth","lines","line","error","pc","scratch","undefined","src","padEnd","topOfStackFirst","maxLengths","reduce","prev","curr","newVal","Array","fill","v","trim","dryrunTxnResultAppTrace","result","appCallTrace","conf","dryrunTxnResultLogicSigTrace","logicSigTrace","logicSigDisassembly"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\dryrun.ts"],"sourcesContent":["import { AlgodClient } from './client/v2/algod/algod.js';\nimport {\n  Account,\n  Application,\n  ApplicationParams,\n  ApplicationStateSchema,\n  DryrunRequest,\n  DryrunSource,\n  DryrunTxnResult,\n  DryrunState,\n  TealValue,\n} from './client/v2/algod/models/types.js';\nimport { getApplicationAddress } from './encoding/address.js';\nimport { bytesToHex } from './encoding/binarydata.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport { TransactionType } from './types/transactions/index.js';\nimport { stringifyJSON } from './utils/utils.js';\n\nconst defaultAppId = 1380011588;\nconst defaultMaxWidth = 30;\n\n/**\n * createDryrun takes an Algod Client (from algod.AlgodV2Client) and an array of Signed Transactions\n * from (transaction.SignedTransaction) and creates a DryrunRequest object with relevant balances\n * @param client - the AlgodClient to make requests against\n * @param txns - the array of SignedTransaction to use for generating the DryrunRequest object\n * @param protocolVersion - the string representing the protocol version to use\n * @param latestTimestamp - the timestamp\n * @param round - the round available to some TEAL scripts. Defaults to the current round on the network.\n * @param sources - TEAL source text that gets uploaded, compiled, and inserted into transactions or application state.\n * @returns the DryrunRequest object constructed from the SignedTransactions passed\n */\nexport async function createDryrun({\n  client,\n  txns,\n  protocolVersion,\n  latestTimestamp,\n  round,\n  sources,\n}: {\n  client: AlgodClient;\n  txns: SignedTransaction[];\n  protocolVersion?: string;\n  latestTimestamp?: number | bigint;\n  round?: number | bigint;\n  sources?: DryrunSource[];\n}): Promise<DryrunRequest> {\n  const appInfos: Application[] = [];\n  const acctInfos: Account[] = [];\n\n  const apps: bigint[] = [];\n  const assets: bigint[] = [];\n  const accts: string[] = [];\n\n  for (const t of txns) {\n    if (t.txn.type === TransactionType.appl) {\n      accts.push(t.txn.sender.toString());\n\n      accts.push(...t.txn.applicationCall!.accounts.map((a) => a.toString()));\n\n      apps.push(...t.txn.applicationCall!.foreignApps);\n      accts.push(\n        ...t.txn\n          .applicationCall!.foreignApps.map(getApplicationAddress)\n          .map((a) => a.toString())\n      );\n\n      assets.push(...t.txn.applicationCall!.foreignAssets);\n\n      // Create application,\n      if (t.txn.applicationCall!.appIndex === BigInt(0)) {\n        appInfos.push(\n          new Application({\n            id: defaultAppId,\n            params: new ApplicationParams({\n              creator: t.txn.sender.toString(),\n              approvalProgram: t.txn.applicationCall!.approvalProgram,\n              clearStateProgram: t.txn.applicationCall!.clearProgram,\n              localStateSchema: new ApplicationStateSchema({\n                numUint: t.txn.applicationCall!.numLocalInts,\n                numByteSlice: t.txn.applicationCall!.numLocalByteSlices,\n              }),\n              globalStateSchema: new ApplicationStateSchema({\n                numUint: t.txn.applicationCall!.numGlobalInts,\n                numByteSlice: t.txn.applicationCall!.numGlobalByteSlices,\n              }),\n            }),\n          })\n        );\n      } else {\n        const { appIndex } = t.txn.applicationCall!;\n        apps.push(appIndex);\n        accts.push(getApplicationAddress(appIndex).toString());\n      }\n    }\n  }\n\n  // Dedupe and add creator to accts array\n  const assetPromises = [];\n  for (const assetId of new Set(assets)) {\n    assetPromises.push(\n      client\n        .getAssetByID(assetId)\n        .do()\n        .then((assetInfo) => {\n          accts.push(assetInfo.params.creator);\n        })\n    );\n  }\n  // Wait for assets to finish since we append to accts array\n  await Promise.all(assetPromises);\n\n  // Dedupe and get app info for all apps\n  const appPromises = [];\n  for (const appId of new Set(apps)) {\n    appPromises.push(\n      client\n        .getApplicationByID(appId)\n        .do()\n        .then((appInfo) => {\n          appInfos.push(appInfo);\n          accts.push(appInfo.params.creator.toString());\n        })\n    );\n  }\n  await Promise.all(appPromises);\n\n  const acctPromises = [];\n  for (const acct of new Set(accts)) {\n    acctPromises.push(\n      client\n        .accountInformation(acct)\n        .do()\n        .then((acctInfo) => {\n          acctInfos.push(acctInfo);\n        })\n    );\n  }\n  await Promise.all(acctPromises);\n\n  return new DryrunRequest({\n    txns: txns.slice(),\n    accounts: acctInfos,\n    apps: appInfos,\n    latestTimestamp: latestTimestamp ?? 0,\n    round: round ?? 0,\n    protocolVersion: protocolVersion ?? '',\n    sources: sources ?? [],\n  });\n}\n\nexport interface StackPrinterConfig {\n  maxValueWidth: number | undefined;\n  topOfStackFirst: boolean | undefined;\n}\n\nfunction truncate(str: string, maxValueWidth: number): string {\n  if (str.length > maxValueWidth && maxValueWidth > 0) {\n    return `${str.slice(0, maxValueWidth)}...`;\n  }\n  return str;\n}\n\nfunction scratchToString(\n  prevScratch: TealValue[],\n  currScratch: TealValue[]\n): string {\n  if (currScratch.length === 0) return '';\n\n  let newScratchIdx = null;\n  for (let idx = 0; idx < currScratch.length; idx++) {\n    if (idx > prevScratch.length) {\n      newScratchIdx = idx;\n      continue;\n    }\n\n    if (stringifyJSON(prevScratch[idx]) !== stringifyJSON(currScratch[idx])) {\n      newScratchIdx = idx;\n    }\n  }\n\n  if (newScratchIdx == null) return '';\n\n  const newScratch = currScratch[newScratchIdx];\n  if (newScratch.bytes.length > 0) {\n    return `${newScratchIdx} = 0x${bytesToHex(newScratch.bytes)}`;\n  }\n  return `${newScratchIdx} = ${newScratch.uint.toString()}`;\n}\n\nfunction stackToString(\n  stack: TealValue[],\n  reverse: boolean | undefined\n): string {\n  const svs = reverse ? stack.reverse() : stack;\n  return `[${svs\n    .map((sv) => {\n      switch (sv.type) {\n        case 1:\n          return `0x${bytesToHex(sv.bytes)}`;\n        case 2:\n          return sv.uint.toString();\n        default:\n          return '';\n      }\n    })\n    .join(', ')}]`;\n}\n\nfunction dryrunTrace(\n  trace: DryrunState[],\n  disassembly: string[],\n  spc: StackPrinterConfig\n): string {\n  const maxWidth = spc.maxValueWidth || defaultMaxWidth;\n\n  // Create the array of arrays, each sub array contains N columns\n  const lines = [['pc#', 'ln#', 'source', 'scratch', 'stack']];\n  for (let idx = 0; idx < trace.length; idx++) {\n    const { line, error, pc, scratch, stack } = trace[idx];\n\n    const currScratch = scratch !== undefined ? scratch : [];\n    const prevScratch =\n      idx > 0 && trace[idx - 1].scratch !== undefined\n        ? trace[idx - 1].scratch!\n        : [];\n\n    const src = !error ? disassembly[line] : `!! ${error} !!`;\n\n    lines.push([\n      pc.toString().padEnd(3, ' '),\n      line.toString().padEnd(3, ' '),\n      truncate(src, maxWidth),\n      truncate(scratchToString(prevScratch, currScratch), maxWidth),\n      truncate(stackToString(stack, spc.topOfStackFirst), maxWidth),\n    ]);\n  }\n\n  // Get the max length for each column\n  const maxLengths = lines.reduce((prev, curr) => {\n    const newVal = new Array(lines[0].length).fill(0);\n    for (let idx = 0; idx < prev.length; idx++) {\n      newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];\n    }\n    return newVal;\n  }, new Array(lines[0].length).fill(0));\n\n  return `${lines\n    .map((line) =>\n      line\n        .map((v, idx) => v.padEnd(maxLengths[idx] + 1, ' '))\n        .join('|')\n        .trim()\n    )\n    .join('\\n')}\\n`;\n}\n\nexport function dryrunTxnResultAppTrace(\n  result: DryrunTxnResult,\n  spc?: StackPrinterConfig\n): string {\n  if (!result.appCallTrace || !result.disassembly) return '';\n\n  let conf = spc;\n  if (spc !== undefined) conf = spc;\n  else {\n    conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: false,\n    };\n  }\n\n  return dryrunTrace(result.appCallTrace, result.disassembly, conf);\n}\n\nexport function dryrunTxnResultLogicSigTrace(\n  result: DryrunTxnResult,\n  spc?: StackPrinterConfig\n): string {\n  if (!result.logicSigTrace || !result.logicSigDisassembly) return '';\n\n  let conf: StackPrinterConfig;\n  if (spc !== undefined) conf = spc;\n  else {\n    conf = {\n      maxValueWidth: defaultMaxWidth,\n      topOfStackFirst: true,\n    };\n  }\n\n  return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}