{"ast":null,"code":"import { RawBinaryString } from 'algorand-msgpack';\nimport { Schema } from '../encoding.js';\nimport { ensureUint64, arrayEqual } from '../../utils/utils.js';\nimport { bytesToString, coerceToBytes, bytesToBase64, base64ToBytes } from '../binarydata.js';\n/**\n * Applies the omitEmpty flag to all entries in the array.\n * @param entries - The entries to apply the flag to.\n * @returns A new array with the omitEmpty flag applied to all entries.\n */\nexport function allOmitEmpty(entries) {\n  return entries.map(entry => ({\n    ...entry,\n    omitEmpty: true\n  }));\n}\n/**\n * Schema for a map/struct with a fixed set of known string fields.\n */\nexport class NamedMapSchema extends Schema {\n  constructor(entries) {\n    super();\n    this.entries = entries;\n    this.checkEntries();\n  }\n  /**\n   * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very\n   * careful when using it. Any error that happens here is non-recoverable and will corrupt the\n   * NamedMapSchema object;\n   * @param entries - The entries to add.\n   */\n  pushEntries(...entries) {\n    this.entries.push(...entries);\n    this.checkEntries();\n  }\n  checkEntries() {\n    for (const entry of this.entries) {\n      if (entry.embedded) {\n        if (entry.key !== '') {\n          throw new Error('Embedded entries must have an empty key');\n        }\n        if (!(entry.valueSchema instanceof NamedMapSchema)) {\n          throw new Error('Embedded entry valueSchema must be a NamedMapSchema');\n        }\n      }\n    }\n    const keys = new Set();\n    for (const entry of this.getEntries()) {\n      if (keys.has(entry.key)) {\n        throw new Error(`Duplicate key: ${entry.key}`);\n      }\n      keys.add(entry.key);\n    }\n  }\n  /**\n   * Returns all top-level entries, properly accounting for fields from embedded entries.\n   * @returns An array of all top-level entries for this map.\n   */\n  getEntries() {\n    const entries = [];\n    for (const entry of this.entries) {\n      if (entry.embedded) {\n        const embeddedMapSchema = entry.valueSchema;\n        entries.push(...embeddedMapSchema.getEntries());\n      } else {\n        entries.push(entry);\n      }\n    }\n    return entries;\n  }\n  defaultValue() {\n    const map = new Map();\n    for (const entry of this.getEntries()) {\n      map.set(entry.key, entry.valueSchema.defaultValue());\n    }\n    return map;\n  }\n  isDefaultValue(data) {\n    if (!(data instanceof Map)) return false;\n    for (const entry of this.getEntries()) {\n      if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  prepareMsgpack(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const map = new Map();\n    for (const entry of this.getEntries()) {\n      const value = data.get(entry.key);\n      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {\n        continue;\n      }\n      map.set(entry.key, entry.valueSchema.prepareMsgpack(value));\n    }\n    return map;\n  }\n  fromPreparedMsgpack(encoded, rawStringProvider) {\n    if (!(encoded instanceof Map)) {\n      throw new Error('NamedMapSchema data must be a Map');\n    }\n    const map = new Map();\n    for (const entry of this.getEntries()) {\n      if (encoded.has(entry.key)) {\n        map.set(entry.key, entry.valueSchema.fromPreparedMsgpack(encoded.get(entry.key), rawStringProvider.withMapValue(entry.key)));\n      } else if (entry.omitEmpty) {\n        map.set(entry.key, entry.valueSchema.defaultValue());\n      } else {\n        throw new Error(`Missing key: ${entry.key}`);\n      }\n    }\n    return map;\n  }\n  prepareJSON(data, options) {\n    if (!(data instanceof Map)) {\n      throw new Error('NamedMapSchema data must be a Map');\n    }\n    const obj = {};\n    for (const entry of this.getEntries()) {\n      const value = data.get(entry.key);\n      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {\n        continue;\n      }\n      obj[entry.key] = entry.valueSchema.prepareJSON(value, options);\n    }\n    return obj;\n  }\n  fromPreparedJSON(encoded) {\n    if (encoded == null || typeof encoded !== 'object' || Array.isArray(encoded)) {\n      throw new Error('NamedMapSchema data must be an object');\n    }\n    const map = new Map();\n    for (const entry of this.getEntries()) {\n      if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {\n        map.set(entry.key, entry.valueSchema.fromPreparedJSON(encoded[entry.key]));\n      } else if (entry.omitEmpty) {\n        map.set(entry.key, entry.valueSchema.defaultValue());\n      } else {\n        throw new Error(`Missing key: ${entry.key}`);\n      }\n    }\n    return map;\n  }\n}\n/**\n * Combines multiple maps into a single map. Throws an error if any of the maps have duplicate keys.\n * @param maps - The maps to combine.\n * @returns A new map with all the entries from the input maps.\n */\nexport function combineMaps(...maps) {\n  const combined = new Map();\n  for (const map of maps) {\n    for (const [key, value] of map) {\n      if (combined.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      combined.set(key, value);\n    }\n  }\n  return combined;\n}\n/**\n * Converts a map to a new map with different keys and values.\n * @param map - The map to convert.\n * @param func - The function to convert each entry.\n * @returns A new map with the converted entries.\n */\nexport function convertMap(map, func) {\n  const mapped = new Map();\n  for (const [key, value] of map) {\n    const [newKey, newValue] = func(key, value);\n    mapped.set(newKey, newValue);\n  }\n  return mapped;\n}\n/**\n * Schema for a map with a variable number of uint64 keys.\n */\nexport class Uint64MapSchema extends Schema {\n  constructor(valueSchema) {\n    super();\n    this.valueSchema = valueSchema;\n  }\n  defaultValue() {\n    return new Map();\n  }\n  isDefaultValue(data) {\n    return data instanceof Map && data.size === 0;\n  }\n  prepareMsgpack(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      const bigintKey = ensureUint64(key);\n      if (prepared.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n  fromPreparedMsgpack(encoded, rawStringProvider) {\n    if (!(encoded instanceof Map)) {\n      throw new Error('Uint64MapSchema data must be a Map');\n    }\n    const map = new Map();\n    for (const [key, value] of encoded) {\n      const bigintKey = ensureUint64(key);\n      if (map.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      map.set(bigintKey, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));\n    }\n    return map;\n  }\n  prepareJSON(data, options) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      const bigintKey = ensureUint64(key);\n      if (prepared.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj = {};\n    for (const [key, value] of prepared) {\n      obj[key.toString()] = value;\n    }\n    return obj;\n  }\n  fromPreparedJSON(encoded) {\n    if (encoded == null || typeof encoded !== 'object' || Array.isArray(encoded)) {\n      throw new Error('Uint64MapSchema data must be an object');\n    }\n    const map = new Map();\n    for (const [key, value] of Object.entries(encoded)) {\n      const bigintKey = BigInt(key);\n      if (map.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      map.set(bigintKey, this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n/**\n * Schema for a map with a variable number of string keys.\n */\nexport class StringMapSchema extends Schema {\n  constructor(valueSchema) {\n    super();\n    this.valueSchema = valueSchema;\n  }\n  defaultValue() {\n    return new Map();\n  }\n  isDefaultValue(data) {\n    return data instanceof Map && data.size === 0;\n  }\n  prepareMsgpack(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`StringMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (prepared.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      prepared.set(key, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n  fromPreparedMsgpack(encoded, rawStringProvider) {\n    if (!(encoded instanceof Map)) {\n      throw new Error('StringMapSchema data must be a Map');\n    }\n    const map = new Map();\n    for (const [key, value] of encoded) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (map.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      map.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));\n    }\n    return map;\n  }\n  prepareJSON(data, options) {\n    if (!(data instanceof Map)) {\n      throw new Error(`StringMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (prepared.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      prepared.set(key, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  fromPreparedJSON(encoded) {\n    if (encoded == null || typeof encoded !== 'object' || Array.isArray(encoded)) {\n      throw new Error('StringMapSchema data must be an object');\n    }\n    const map = new Map();\n    for (const [key, value] of Object.entries(encoded)) {\n      if (map.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      map.set(key, this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n/**\n * Schema for a map with a variable number of byte array keys.\n */\nexport class ByteArrayMapSchema extends Schema {\n  constructor(valueSchema) {\n    super();\n    this.valueSchema = valueSchema;\n  }\n  defaultValue() {\n    return new Map();\n  }\n  isDefaultValue(data) {\n    return data instanceof Map && data.size === 0;\n  }\n  prepareMsgpack(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      prepared.set(key, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n  fromPreparedMsgpack(encoded, rawStringProvider) {\n    if (!(encoded instanceof Map)) {\n      throw new Error('ByteArrayMapSchema data must be a Map');\n    }\n    const map = new Map();\n    for (const [key, value] of encoded) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      map.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));\n    }\n    return map;\n  }\n  prepareJSON(data, options) {\n    if (!(data instanceof Map)) {\n      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      const b64Encoded = bytesToBase64(key);\n      if (prepared.has(b64Encoded)) {\n        throw new Error(`Duplicate key (base64): ${b64Encoded}`);\n      }\n      prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  fromPreparedJSON(encoded) {\n    if (encoded == null || typeof encoded !== 'object' || Array.isArray(encoded)) {\n      throw new Error('ByteArrayMapSchema data must be an object');\n    }\n    const map = new Map();\n    for (const [key, value] of Object.entries(encoded)) {\n      map.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n/**\n * Converts any RawBinaryString values to regular strings in a MsgpackEncodingData object.\n *\n * Note this conversion may be lossy if the binary data is not valid UTF-8.\n *\n * @returns A new object with RawBinaryString values converted to strings.\n */\nfunction convertRawStringsInMsgpackValue(value) {\n  if (value instanceof RawBinaryString) {\n    return bytesToString(value.rawBinaryValue);\n  }\n  if (value instanceof Map) {\n    const newMap = new Map();\n    for (const [key, val] of value) {\n      newMap.set(convertRawStringsInMsgpackValue(key), convertRawStringsInMsgpackValue(val));\n    }\n    return newMap;\n  }\n  if (Array.isArray(value)) {\n    return value.map(convertRawStringsInMsgpackValue);\n  }\n  return value;\n}\n/**\n * Schema for a map with a variable number of binary string keys.\n *\n * See SpecialCaseBinaryStringSchema for more information about the key type.\n */\nexport class SpecialCaseBinaryStringMapSchema extends Schema {\n  constructor(valueSchema) {\n    super();\n    this.valueSchema = valueSchema;\n  }\n  defaultValue() {\n    return new Map();\n  }\n  isDefaultValue(data) {\n    return data instanceof Map && data.size === 0;\n  }\n  prepareMsgpack(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      prepared.set(new RawBinaryString(key), this.valueSchema.prepareMsgpack(value));\n    }\n    // Cast is needed because RawBinaryString is not part of the standard MsgpackEncodingData\n    return prepared;\n  }\n  fromPreparedMsgpack(_encoded, rawStringProvider) {\n    const map = new Map();\n    const keysAndValues = rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();\n    for (const [key, value] of keysAndValues) {\n      map.set(key, this.valueSchema.fromPreparedMsgpack(convertRawStringsInMsgpackValue(value), rawStringProvider.withMapValue(new RawBinaryString(key))));\n    }\n    return map;\n  }\n  prepareJSON(data, options) {\n    if (!(data instanceof Map)) {\n      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);\n    }\n    const prepared = new Map();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      // Not safe to convert to string for all binary data\n      const keyStringValue = bytesToString(key);\n      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(keyStringValue), key)) {\n        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`);\n      }\n      prepared.set(keyStringValue, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n  fromPreparedJSON(encoded) {\n    if (encoded == null || typeof encoded !== 'object' || Array.isArray(encoded)) {\n      throw new Error('SpecialCaseBinaryStringMapSchema data must be an object');\n    }\n    const map = new Map();\n    for (const [key, value] of Object.entries(encoded)) {\n      map.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}","map":{"version":3,"names":["RawBinaryString","Schema","ensureUint64","arrayEqual","bytesToString","coerceToBytes","bytesToBase64","base64ToBytes","allOmitEmpty","entries","map","entry","omitEmpty","NamedMapSchema","constructor","checkEntries","pushEntries","push","embedded","key","Error","valueSchema","keys","Set","getEntries","has","add","embeddedMapSchema","defaultValue","Map","set","isDefaultValue","data","get","prepareMsgpack","value","fromPreparedMsgpack","encoded","rawStringProvider","withMapValue","prepareJSON","options","obj","fromPreparedJSON","Array","isArray","Object","prototype","hasOwnProperty","call","combineMaps","maps","combined","convertMap","func","mapped","newKey","newValue","Uint64MapSchema","size","prepared","bigintKey","toString","BigInt","StringMapSchema","ByteArrayMapSchema","Uint8Array","b64Encoded","convertRawStringsInMsgpackValue","rawBinaryValue","newMap","val","SpecialCaseBinaryStringMapSchema","_encoded","keysAndValues","getRawStringKeysAndValuesAtCurrentLocation","keyStringValue","lossyBinaryStringConversion"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\encoding\\schema\\map.ts"],"sourcesContent":["import { RawBinaryString } from 'algorand-msgpack';\nimport {\n  Schema,\n  MsgpackEncodingData,\n  MsgpackRawStringProvider,\n  JSONEncodingData,\n  PrepareJSONOptions,\n} from '../encoding.js';\nimport { ensureUint64, arrayEqual } from '../../utils/utils.js';\nimport {\n  bytesToString,\n  coerceToBytes,\n  bytesToBase64,\n  base64ToBytes,\n} from '../binarydata.js';\n\n/* eslint-disable class-methods-use-this */\n\n/**\n * Describes a key-value entry in a NamedMapSchema.\n */\nexport interface NamedMapEntry {\n  /**\n   * Key of the entry. Must be unique for this map.\n   */\n  key: string;\n  /**\n   * The Schema for the entry's value.\n   */\n  valueSchema: Schema;\n  /**\n   * If true, the entry will be omitted from the encoding if the value is the default value.\n   */\n  omitEmpty: boolean;\n  /**\n   * If true, valueSchema must be a NamedMapSchema and key must be the empty string. The fields of\n   * valueSchema will be embedded directly in the parent map.\n   *\n   * omitEmpty is ignored for embedded entries. Instead, the individual omitEmpty values of the\n   * embedded fields are used.\n   */\n  embedded?: boolean;\n}\n\n/**\n * Applies the omitEmpty flag to all entries in the array.\n * @param entries - The entries to apply the flag to.\n * @returns A new array with the omitEmpty flag applied to all entries.\n */\nexport function allOmitEmpty(\n  entries: Array<Omit<NamedMapEntry, 'omitEmpty'>>\n): NamedMapEntry[] {\n  return entries.map((entry) => ({ ...entry, omitEmpty: true }));\n}\n\n/**\n * Schema for a map/struct with a fixed set of known string fields.\n */\nexport class NamedMapSchema extends Schema {\n  private readonly entries: NamedMapEntry[];\n\n  constructor(entries: NamedMapEntry[]) {\n    super();\n    this.entries = entries;\n    this.checkEntries();\n  }\n\n  /**\n   * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very\n   * careful when using it. Any error that happens here is non-recoverable and will corrupt the\n   * NamedMapSchema object;\n   * @param entries - The entries to add.\n   */\n  public pushEntries(...entries: NamedMapEntry[]) {\n    this.entries.push(...entries);\n    this.checkEntries();\n  }\n\n  private checkEntries() {\n    for (const entry of this.entries) {\n      if (entry.embedded) {\n        if (entry.key !== '') {\n          throw new Error('Embedded entries must have an empty key');\n        }\n        if (!(entry.valueSchema instanceof NamedMapSchema)) {\n          throw new Error(\n            'Embedded entry valueSchema must be a NamedMapSchema'\n          );\n        }\n      }\n    }\n\n    const keys = new Set<string>();\n    for (const entry of this.getEntries()) {\n      if (keys.has(entry.key)) {\n        throw new Error(`Duplicate key: ${entry.key}`);\n      }\n      keys.add(entry.key);\n    }\n  }\n\n  /**\n   * Returns all top-level entries, properly accounting for fields from embedded entries.\n   * @returns An array of all top-level entries for this map.\n   */\n  public getEntries(): NamedMapEntry[] {\n    const entries: NamedMapEntry[] = [];\n    for (const entry of this.entries) {\n      if (entry.embedded) {\n        const embeddedMapSchema = entry.valueSchema as NamedMapSchema;\n        entries.push(...embeddedMapSchema.getEntries());\n      } else {\n        entries.push(entry);\n      }\n    }\n    return entries;\n  }\n\n  public defaultValue(): Map<string, unknown> {\n    const map = new Map<string, unknown>();\n    for (const entry of this.getEntries()) {\n      map.set(entry.key, entry.valueSchema.defaultValue());\n    }\n    return map;\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    if (!(data instanceof Map)) return false;\n    for (const entry of this.getEntries()) {\n      if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const map = new Map<string, MsgpackEncodingData>();\n    for (const entry of this.getEntries()) {\n      const value = data.get(entry.key);\n      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {\n        continue;\n      }\n      map.set(entry.key, entry.valueSchema.prepareMsgpack(value));\n    }\n    return map;\n  }\n\n  public fromPreparedMsgpack(\n    encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Map<string, unknown> {\n    if (!(encoded instanceof Map)) {\n      throw new Error('NamedMapSchema data must be a Map');\n    }\n    const map = new Map<string, unknown>();\n    for (const entry of this.getEntries()) {\n      if (encoded.has(entry.key)) {\n        map.set(\n          entry.key,\n          entry.valueSchema.fromPreparedMsgpack(\n            encoded.get(entry.key),\n            rawStringProvider.withMapValue(entry.key)\n          )\n        );\n      } else if (entry.omitEmpty) {\n        map.set(entry.key, entry.valueSchema.defaultValue());\n      } else {\n        throw new Error(`Missing key: ${entry.key}`);\n      }\n    }\n    return map;\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error('NamedMapSchema data must be a Map');\n    }\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const entry of this.getEntries()) {\n      const value = data.get(entry.key);\n      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {\n        continue;\n      }\n      obj[entry.key] = entry.valueSchema.prepareJSON(value, options);\n    }\n    return obj;\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Map<string, unknown> {\n    if (\n      encoded == null ||\n      typeof encoded !== 'object' ||\n      Array.isArray(encoded)\n    ) {\n      throw new Error('NamedMapSchema data must be an object');\n    }\n    const map = new Map<string, unknown>();\n    for (const entry of this.getEntries()) {\n      if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {\n        map.set(\n          entry.key,\n          entry.valueSchema.fromPreparedJSON(encoded[entry.key])\n        );\n      } else if (entry.omitEmpty) {\n        map.set(entry.key, entry.valueSchema.defaultValue());\n      } else {\n        throw new Error(`Missing key: ${entry.key}`);\n      }\n    }\n    return map;\n  }\n}\n\n/**\n * Combines multiple maps into a single map. Throws an error if any of the maps have duplicate keys.\n * @param maps - The maps to combine.\n * @returns A new map with all the entries from the input maps.\n */\nexport function combineMaps<K, V>(...maps: Array<Map<K, V>>): Map<K, V> {\n  const combined = new Map<K, V>();\n  for (const map of maps) {\n    for (const [key, value] of map) {\n      if (combined.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      combined.set(key, value);\n    }\n  }\n  return combined;\n}\n\n/**\n * Converts a map to a new map with different keys and values.\n * @param map - The map to convert.\n * @param func - The function to convert each entry.\n * @returns A new map with the converted entries.\n */\nexport function convertMap<K1, V1, K2, V2>(\n  map: Map<K1, V1>,\n  func: (k: K1, v: V1) => [K2, V2]\n): Map<K2, V2> {\n  const mapped = new Map<K2, V2>();\n  for (const [key, value] of map) {\n    const [newKey, newValue] = func(key, value);\n    mapped.set(newKey, newValue);\n  }\n  return mapped;\n}\n\n/**\n * Schema for a map with a variable number of uint64 keys.\n */\nexport class Uint64MapSchema extends Schema {\n  constructor(public readonly valueSchema: Schema) {\n    super();\n  }\n\n  public defaultValue(): Map<bigint, unknown> {\n    return new Map();\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    return data instanceof Map && data.size === 0;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<bigint, MsgpackEncodingData>();\n    for (const [key, value] of data) {\n      const bigintKey = ensureUint64(key);\n      if (prepared.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n\n  public fromPreparedMsgpack(\n    encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Map<bigint, unknown> {\n    if (!(encoded instanceof Map)) {\n      throw new Error('Uint64MapSchema data must be a Map');\n    }\n    const map = new Map<bigint, unknown>();\n    for (const [key, value] of encoded) {\n      const bigintKey = ensureUint64(key);\n      if (map.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      map.set(\n        bigintKey,\n        this.valueSchema.fromPreparedMsgpack(\n          value,\n          rawStringProvider.withMapValue(key)\n        )\n      );\n    }\n    return map;\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<bigint, JSONEncodingData>();\n    for (const [key, value] of data) {\n      const bigintKey = ensureUint64(key);\n      if (prepared.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const [key, value] of prepared) {\n      obj[key.toString()] = value;\n    }\n    return obj;\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Map<bigint, unknown> {\n    if (\n      encoded == null ||\n      typeof encoded !== 'object' ||\n      Array.isArray(encoded)\n    ) {\n      throw new Error('Uint64MapSchema data must be an object');\n    }\n    const map = new Map<bigint, unknown>();\n    for (const [key, value] of Object.entries(encoded)) {\n      const bigintKey = BigInt(key);\n      if (map.has(bigintKey)) {\n        throw new Error(`Duplicate key: ${bigintKey}`);\n      }\n      map.set(bigintKey, this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n\n/**\n * Schema for a map with a variable number of string keys.\n */\nexport class StringMapSchema extends Schema {\n  constructor(public readonly valueSchema: Schema) {\n    super();\n  }\n\n  public defaultValue(): Map<string, unknown> {\n    return new Map();\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    return data instanceof Map && data.size === 0;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `StringMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<string, MsgpackEncodingData>();\n    for (const [key, value] of data) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (prepared.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      prepared.set(key, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n\n  public fromPreparedMsgpack(\n    encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Map<string, unknown> {\n    if (!(encoded instanceof Map)) {\n      throw new Error('StringMapSchema data must be a Map');\n    }\n    const map = new Map<string, unknown>();\n    for (const [key, value] of encoded) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (map.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      map.set(\n        key,\n        this.valueSchema.fromPreparedMsgpack(\n          value,\n          rawStringProvider.withMapValue(key)\n        )\n      );\n    }\n    return map;\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `StringMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<string, JSONEncodingData>();\n    for (const [key, value] of data) {\n      if (typeof key !== 'string') {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      if (prepared.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      prepared.set(key, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Map<string, unknown> {\n    if (\n      encoded == null ||\n      typeof encoded !== 'object' ||\n      Array.isArray(encoded)\n    ) {\n      throw new Error('StringMapSchema data must be an object');\n    }\n    const map = new Map<string, unknown>();\n    for (const [key, value] of Object.entries(encoded)) {\n      if (map.has(key)) {\n        throw new Error(`Duplicate key: ${key}`);\n      }\n      map.set(key, this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n\n/**\n * Schema for a map with a variable number of byte array keys.\n */\nexport class ByteArrayMapSchema extends Schema {\n  constructor(public readonly valueSchema: Schema) {\n    super();\n  }\n\n  public defaultValue(): Map<Uint8Array, unknown> {\n    return new Map();\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    return data instanceof Map && data.size === 0;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<Uint8Array, MsgpackEncodingData>();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      prepared.set(key, this.valueSchema.prepareMsgpack(value));\n    }\n    return prepared;\n  }\n\n  public fromPreparedMsgpack(\n    encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Map<Uint8Array, unknown> {\n    if (!(encoded instanceof Map)) {\n      throw new Error('ByteArrayMapSchema data must be a Map');\n    }\n    const map = new Map<Uint8Array, unknown>();\n    for (const [key, value] of encoded) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      map.set(\n        key,\n        this.valueSchema.fromPreparedMsgpack(\n          value,\n          rawStringProvider.withMapValue(key)\n        )\n      );\n    }\n    return map;\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<string, JSONEncodingData>();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      const b64Encoded = bytesToBase64(key);\n      if (prepared.has(b64Encoded)) {\n        throw new Error(`Duplicate key (base64): ${b64Encoded}`);\n      }\n      prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));\n    }\n    // Convert map to object\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Map<Uint8Array, unknown> {\n    if (\n      encoded == null ||\n      typeof encoded !== 'object' ||\n      Array.isArray(encoded)\n    ) {\n      throw new Error('ByteArrayMapSchema data must be an object');\n    }\n    const map = new Map<Uint8Array, unknown>();\n    for (const [key, value] of Object.entries(encoded)) {\n      map.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n\n/**\n * Converts any RawBinaryString values to regular strings in a MsgpackEncodingData object.\n *\n * Note this conversion may be lossy if the binary data is not valid UTF-8.\n *\n * @returns A new object with RawBinaryString values converted to strings.\n */\nfunction convertRawStringsInMsgpackValue(\n  value: MsgpackEncodingData\n): MsgpackEncodingData {\n  if (value instanceof RawBinaryString) {\n    return bytesToString(value.rawBinaryValue as Uint8Array);\n  }\n  if (value instanceof Map) {\n    const newMap = new Map<\n      string | number | bigint | Uint8Array,\n      MsgpackEncodingData\n    >();\n    for (const [key, val] of value) {\n      newMap.set(\n        convertRawStringsInMsgpackValue(key) as\n          | string\n          | number\n          | bigint\n          | Uint8Array,\n        convertRawStringsInMsgpackValue(val)\n      );\n    }\n    return newMap;\n  }\n  if (Array.isArray(value)) {\n    return value.map(convertRawStringsInMsgpackValue);\n  }\n  return value;\n}\n\n/**\n * Schema for a map with a variable number of binary string keys.\n *\n * See SpecialCaseBinaryStringSchema for more information about the key type.\n */\nexport class SpecialCaseBinaryStringMapSchema extends Schema {\n  constructor(public readonly valueSchema: Schema) {\n    super();\n  }\n\n  public defaultValue(): Map<Uint8Array, unknown> {\n    return new Map();\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    return data instanceof Map && data.size === 0;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<RawBinaryString, MsgpackEncodingData>();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key} (${typeof key})`);\n      }\n      prepared.set(\n        new RawBinaryString(key),\n        this.valueSchema.prepareMsgpack(value)\n      );\n    }\n    // Cast is needed because RawBinaryString is not part of the standard MsgpackEncodingData\n    return prepared as unknown as Map<Uint8Array, MsgpackEncodingData>;\n  }\n\n  public fromPreparedMsgpack(\n    _encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Map<Uint8Array, unknown> {\n    const map = new Map<Uint8Array, unknown>();\n    const keysAndValues =\n      rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();\n    for (const [key, value] of keysAndValues) {\n      map.set(\n        key,\n        this.valueSchema.fromPreparedMsgpack(\n          convertRawStringsInMsgpackValue(value),\n          rawStringProvider.withMapValue(new RawBinaryString(key))\n        )\n      );\n    }\n    return map;\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (!(data instanceof Map)) {\n      throw new Error(\n        `SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`\n      );\n    }\n    const prepared = new Map<string, JSONEncodingData>();\n    for (const [key, value] of data) {\n      if (!(key instanceof Uint8Array)) {\n        throw new Error(`Invalid key: ${key}`);\n      }\n      // Not safe to convert to string for all binary data\n      const keyStringValue = bytesToString(key);\n      if (\n        !options.lossyBinaryStringConversion &&\n        !arrayEqual(coerceToBytes(keyStringValue), key)\n      ) {\n        throw new Error(\n          `Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`\n        );\n      }\n      prepared.set(\n        keyStringValue,\n        this.valueSchema.prepareJSON(value, options)\n      );\n    }\n    // Convert map to object\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const [key, value] of prepared) {\n      obj[key] = value;\n    }\n    return obj;\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Map<Uint8Array, unknown> {\n    if (\n      encoded == null ||\n      typeof encoded !== 'object' ||\n      Array.isArray(encoded)\n    ) {\n      throw new Error(\n        'SpecialCaseBinaryStringMapSchema data must be an object'\n      );\n    }\n    const map = new Map<Uint8Array, unknown>();\n    for (const [key, value] of Object.entries(encoded)) {\n      map.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));\n    }\n    return map;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}