{"ast":null,"code":"import * as nacl from './nacl/naclWrappers.js';\nimport { Address, isValidAddress } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport { NamedMapSchema, ArraySchema, ByteArraySchema, FixedLengthByteArraySchema, OptionalSchema, allOmitEmpty } from './encoding/schema/index.js';\nimport { verifyMultisig, addressFromMultisigPreImg, pksFromAddresses } from './multisig.js';\nimport * as utils from './utils/utils.js';\nimport { encodedMultiSigToEncodingData, encodedMultiSigFromEncodingData, ENCODED_MULTISIG_SCHEMA } from './types/transactions/encoded.js';\n// base64regex is the regex to test for base64 strings\nconst base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n/** sanityCheckProgram performs heuristic program validation:\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\n *\n * @param program - Program bytes to check\n */\nexport function sanityCheckProgram(program) {\n  if (!program || program.length === 0) throw new Error('empty program');\n  const lineBreakOrd = '\\n'.charCodeAt(0);\n  const blankSpaceOrd = ' '.charCodeAt(0);\n  const tildeOrd = '~'.charCodeAt(0);\n  const isPrintable = x => blankSpaceOrd <= x && x <= tildeOrd;\n  const isAsciiPrintable = program.every(x => x === lineBreakOrd || isPrintable(x));\n  if (isAsciiPrintable) {\n    const programStr = new TextDecoder().decode(program);\n    if (isValidAddress(programStr)) throw new Error('requesting program bytes, get Algorand address');\n    if (base64regex.test(programStr)) throw new Error('program should not be b64 encoded');\n    throw new Error('program bytes are all ASCII printable characters, not looking like Teal byte code');\n  }\n}\nconst programTag = new TextEncoder().encode('Program');\n/**\n LogicSig implementation\n\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\n */\nexport class LogicSig {\n  constructor(program, programArgs) {\n    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every(arg => arg.constructor === Uint8Array))) {\n      throw new TypeError('Invalid arguments');\n    }\n    let args = [];\n    if (programArgs != null) args = programArgs.map(arg => new Uint8Array(arg));\n    sanityCheckProgram(program);\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return LogicSig.encodingSchema;\n  }\n  toEncodingData() {\n    const data = new Map([['l', this.logic], ['arg', this.args], ['sig', this.sig]]);\n    if (this.msig) {\n      data.set('msig', encodedMultiSigToEncodingData(this.msig));\n    }\n    return data;\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded logic sig: ${data}`);\n    }\n    const lsig = new LogicSig(data.get('l'), data.get('arg'));\n    lsig.sig = data.get('sig');\n    if (data.get('msig')) {\n      lsig.msig = encodedMultiSigFromEncodingData(data.get('msig'));\n    }\n    return lsig;\n  }\n  /**\n   * Performs signature verification\n   * @param publicKey - Verification key (derived from sender address or escrow address)\n   */\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n    try {\n      sanityCheckProgram(this.logic);\n    } catch (e) {\n      return false;\n    }\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n    return verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns String representation of the address\n   */\n  address() {\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return new Address(Uint8Array.from(hash));\n  }\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param secretKey - Secret key to sign with\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\n   */\n  sign(secretKey, msig) {\n    if (msig == null) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = pksFromAddresses(msig.addrs).map(pk => ({\n        pk\n      }));\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs\n      };\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n  /**\n   * Appends a signature to multi signature\n   * @param secretKey - Secret key to sign with\n   */\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n  signProgram(secretKey) {\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const {\n        pk\n      } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n  toByte() {\n    return encoding.encodeMsgpack(this);\n  }\n  static fromByte(encoded) {\n    return encoding.decodeMsgpack(encoded, LogicSig);\n  }\n}\nLogicSig.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'l',\n  valueSchema: new ByteArraySchema()\n}, {\n  key: 'arg',\n  valueSchema: new ArraySchema(new ByteArraySchema())\n}, {\n  key: 'sig',\n  valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))\n}, {\n  key: 'msig',\n  valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)\n}]));\n/**\n * Represents an account that can sign with a LogicSig program.\n */\nexport class LogicSigAccount {\n  /**\n   * Create a new LogicSigAccount. By default this will create an escrow\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\n   * LogicSigAccount to make it a delegated account.\n   *\n   * @param program - The compiled TEAL program which contains the logic for\n   *   this LogicSig.\n   * @param args - An optional array of arguments for the program.\n   */\n  constructor(program, args) {\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema() {\n    return LogicSigAccount.encodingSchema;\n  }\n  toEncodingData() {\n    return new Map([['lsig', this.lsig.toEncodingData()], ['sigkey', this.sigkey]]);\n  }\n  static fromEncodingData(data) {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded logic sig account: ${data}`);\n    }\n    const value = data;\n    const lsig = LogicSig.fromEncodingData(value.get('lsig'));\n    const lsigAccount = new LogicSigAccount(lsig.logic, lsig.args);\n    lsigAccount.lsig = lsig; // Restore other properties of the lsig\n    lsigAccount.sigkey = value.get('sigkey');\n    return lsigAccount;\n  }\n  /**\n   * Encode this object into msgpack.\n   */\n  toByte() {\n    return encoding.encodeMsgpack(this);\n  }\n  /**\n   * Decode a msgpack object into a LogicSigAccount.\n   * @param encoded - The encoded LogicSigAccount.\n   */\n  static fromByte(encoded) {\n    return encoding.decodeMsgpack(encoded, LogicSigAccount);\n  }\n  /**\n   * Check if this LogicSigAccount has been delegated to another account with a\n   * signature.\n   *\n   * Note this function only checks for the presence of a delegation signature.\n   * To verify the delegation signature, use `verify`.\n   */\n  isDelegated() {\n    return !!(this.lsig.sig || this.lsig.msig);\n  }\n  /**\n   * Verifies this LogicSig's program and signatures.\n   * @returns true if and only if the LogicSig program and signatures are valid.\n   */\n  verify() {\n    const addr = this.address();\n    return this.lsig.verify(addr.publicKey);\n  }\n  /**\n   * Get the address of this LogicSigAccount.\n   *\n   * If the LogicSig is delegated to another account, this will return the\n   * address of that account.\n   *\n   * If the LogicSig is not delegated to another account, this will return an\n   *  escrow address that is the hash of the LogicSig's program code.\n   */\n  address() {\n    if (this.lsig.sig && this.lsig.msig) {\n      throw new Error('LogicSig has too many signatures. At most one of sig or msig may be present');\n    }\n    if (this.lsig.sig) {\n      if (!this.sigkey) {\n        throw new Error('Signing key for delegated account is missing');\n      }\n      return new Address(this.sigkey);\n    }\n    if (this.lsig.msig) {\n      const msigMetadata = {\n        version: this.lsig.msig.v,\n        threshold: this.lsig.msig.thr,\n        pks: this.lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      return addressFromMultisigPreImg(msigMetadata);\n    }\n    return this.lsig.address();\n  }\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. Use this function if the delegating account is a\n   * multisig account.\n   *\n   * @param msig - The multisig delegating account\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account. Use `appendToMultisig` to add additional signatures\n   *   from other members.\n   */\n  signMultisig(msig, secretKey) {\n    this.lsig.sign(secretKey, msig);\n  }\n  /**\n   * Adds an additional signature from a member of the delegating multisig\n   * account.\n   *\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account.\n   */\n  appendToMultisig(secretKey) {\n    this.lsig.appendToMultisig(secretKey);\n  }\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. If the delegating account is a multisig account,\n   * use `signMultisig` instead.\n   *\n   * @param secretKey - The secret key of the delegating account.\n   */\n  sign(secretKey) {\n    this.lsig.sign(secretKey);\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n  }\n}\nLogicSigAccount.encodingSchema = new NamedMapSchema(allOmitEmpty([{\n  key: 'lsig',\n  valueSchema: LogicSig.encodingSchema\n}, {\n  key: 'sigkey',\n  valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))\n}]));\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nexport function logicSigFromByte(encoded) {\n  return encoding.decodeMsgpack(encoded, LogicSig);\n}\nconst SIGN_PROGRAM_DATA_PREFIX = new TextEncoder().encode('ProgData');\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\n * @param sk - Uint8Array with secret key\n * @param data - Uint8Array with data to sign\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n */\nexport function tealSign(sk, data, programHash) {\n  const programAddr = typeof programHash === 'string' ? Address.fromString(programHash) : programHash;\n  const parts = utils.concatArrays(programAddr.publicKey, data);\n  const toBeSigned = utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);\n  return nacl.sign(toBeSigned, sk);\n}\n/**\n * verifyTealSign verifies a signature as would the ed25519verify opcode\n * @param data - Uint8Array with original signed data\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\n * @param pk - uint8array with public key to verify against\n */\nexport function verifyTealSign(data, programHash, sig, pk) {\n  const programAddr = typeof programHash === 'string' ? Address.fromString(programHash) : programHash;\n  const parts = utils.concatArrays(programAddr.publicKey, data);\n  const toBeSigned = utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);\n  return nacl.verify(toBeSigned, sig, pk);\n}\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - Uint8Array with data to sign\n * @param program - Uint8Array with teal program\n */\nexport function tealSignFromProgram(sk, data, program) {\n  const lsig = new LogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}","map":{"version":3,"names":["nacl","Address","isValidAddress","encoding","NamedMapSchema","ArraySchema","ByteArraySchema","FixedLengthByteArraySchema","OptionalSchema","allOmitEmpty","verifyMultisig","addressFromMultisigPreImg","pksFromAddresses","utils","encodedMultiSigToEncodingData","encodedMultiSigFromEncodingData","ENCODED_MULTISIG_SCHEMA","base64regex","sanityCheckProgram","program","length","Error","lineBreakOrd","charCodeAt","blankSpaceOrd","tildeOrd","isPrintable","x","isAsciiPrintable","every","programStr","TextDecoder","decode","test","programTag","TextEncoder","encode","LogicSig","constructor","programArgs","Array","isArray","arg","Uint8Array","TypeError","args","map","logic","sig","undefined","msig","getEncodingSchema","encodingSchema","toEncodingData","data","Map","set","fromEncodingData","lsig","get","verify","publicKey","e","toBeSigned","concatArrays","hash","genericHash","arrayEqual","address","from","sign","secretKey","signProgram","subsigs","addrs","pk","v","version","thr","threshold","subsig","index","singleSignMultisig","s","appendToMultisig","myPk","keyPairFromSecretKey","i","toByte","encodeMsgpack","fromByte","encoded","decodeMsgpack","key","valueSchema","LogicSigAccount","sigkey","value","lsigAccount","isDelegated","addr","msigMetadata","pks","signMultisig","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","programHash","programAddr","fromString","parts","verifyTealSign","tealSignFromProgram","contractAddress"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\logicsig.ts"],"sourcesContent":["import * as nacl from './nacl/naclWrappers.js';\nimport { Address, isValidAddress } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport {\n  NamedMapSchema,\n  ArraySchema,\n  ByteArraySchema,\n  FixedLengthByteArraySchema,\n  OptionalSchema,\n  allOmitEmpty,\n} from './encoding/schema/index.js';\nimport {\n  MultisigMetadata,\n  verifyMultisig,\n  addressFromMultisigPreImg,\n  pksFromAddresses,\n} from './multisig.js';\nimport * as utils from './utils/utils.js';\nimport {\n  EncodedMultisig,\n  encodedMultiSigToEncodingData,\n  encodedMultiSigFromEncodingData,\n  ENCODED_MULTISIG_SCHEMA,\n} from './types/transactions/encoded.js';\n\n// base64regex is the regex to test for base64 strings\nconst base64regex =\n  /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\n\n/** sanityCheckProgram performs heuristic program validation:\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\n *\n * @param program - Program bytes to check\n */\nexport function sanityCheckProgram(program: Uint8Array) {\n  if (!program || program.length === 0) throw new Error('empty program');\n\n  const lineBreakOrd = '\\n'.charCodeAt(0);\n  const blankSpaceOrd = ' '.charCodeAt(0);\n  const tildeOrd = '~'.charCodeAt(0);\n\n  const isPrintable = (x: number) => blankSpaceOrd <= x && x <= tildeOrd;\n  const isAsciiPrintable = program.every(\n    (x: number) => x === lineBreakOrd || isPrintable(x)\n  );\n\n  if (isAsciiPrintable) {\n    const programStr = new TextDecoder().decode(program);\n\n    if (isValidAddress(programStr))\n      throw new Error('requesting program bytes, get Algorand address');\n\n    if (base64regex.test(programStr))\n      throw new Error('program should not be b64 encoded');\n\n    throw new Error(\n      'program bytes are all ASCII printable characters, not looking like Teal byte code'\n    );\n  }\n}\n\nconst programTag = new TextEncoder().encode('Program');\n\n/**\n LogicSig implementation\n\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\n */\nexport class LogicSig implements encoding.Encodable {\n  static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'l',\n        valueSchema: new ByteArraySchema(),\n      },\n      {\n        key: 'arg',\n        valueSchema: new ArraySchema(new ByteArraySchema()),\n      },\n      {\n        key: 'sig',\n        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64)),\n      },\n      {\n        key: 'msig',\n        valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA),\n      },\n    ])\n  );\n\n  logic: Uint8Array;\n  args: Uint8Array[];\n  sig?: Uint8Array;\n  msig?: EncodedMultisig;\n\n  constructor(program: Uint8Array, programArgs?: Array<Uint8Array> | null) {\n    if (\n      programArgs &&\n      (!Array.isArray(programArgs) ||\n        !programArgs.every((arg) => arg.constructor === Uint8Array))\n    ) {\n      throw new TypeError('Invalid arguments');\n    }\n\n    let args: Uint8Array[] = [];\n    if (programArgs != null)\n      args = programArgs.map((arg) => new Uint8Array(arg));\n\n    sanityCheckProgram(program);\n\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema(): encoding.Schema {\n    return LogicSig.encodingSchema;\n  }\n\n  toEncodingData(): Map<string, unknown> {\n    const data = new Map<string, unknown>([\n      ['l', this.logic],\n      ['arg', this.args],\n      ['sig', this.sig],\n    ]);\n    if (this.msig) {\n      data.set('msig', encodedMultiSigToEncodingData(this.msig));\n    }\n    return data;\n  }\n\n  static fromEncodingData(data: unknown): LogicSig {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded logic sig: ${data}`);\n    }\n    const lsig = new LogicSig(data.get('l'), data.get('arg'));\n    lsig.sig = data.get('sig');\n    if (data.get('msig')) {\n      lsig.msig = encodedMultiSigFromEncodingData(data.get('msig'));\n    }\n    return lsig;\n  }\n\n  /**\n   * Performs signature verification\n   * @param publicKey - Verification key (derived from sender address or escrow address)\n   */\n  verify(publicKey: Uint8Array) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n\n    try {\n      sanityCheckProgram(this.logic);\n    } catch (e) {\n      return false;\n    }\n\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n\n    return verifyMultisig(toBeSigned, this.msig!, publicKey);\n  }\n\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns String representation of the address\n   */\n  address(): Address {\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return new Address(Uint8Array.from(hash));\n  }\n\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param secretKey - Secret key to sign with\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\n   */\n  sign(secretKey: Uint8Array, msig?: MultisigMetadata) {\n    if (msig == null) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = pksFromAddresses(msig.addrs).map((pk) => ({ pk }));\n\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs,\n      };\n\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n\n  /**\n   * Appends a signature to multi signature\n   * @param secretKey - Secret key to sign with\n   */\n  appendToMultisig(secretKey: Uint8Array) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n\n  signProgram(secretKey: Uint8Array) {\n    const toBeSigned = utils.concatArrays(programTag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n\n  singleSignMultisig(\n    secretKey: Uint8Array,\n    msig: EncodedMultisig\n  ): [sig: Uint8Array, index: number] {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const { pk } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n\n  toByte(): Uint8Array {\n    return encoding.encodeMsgpack(this);\n  }\n\n  static fromByte(encoded: ArrayLike<any>): LogicSig {\n    return encoding.decodeMsgpack(encoded, LogicSig);\n  }\n}\n\n/**\n * Represents an account that can sign with a LogicSig program.\n */\nexport class LogicSigAccount implements encoding.Encodable {\n  static readonly encodingSchema = new NamedMapSchema(\n    allOmitEmpty([\n      {\n        key: 'lsig',\n        valueSchema: LogicSig.encodingSchema,\n      },\n      {\n        key: 'sigkey',\n        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32)),\n      },\n    ])\n  );\n\n  lsig: LogicSig;\n  sigkey?: Uint8Array;\n\n  /**\n   * Create a new LogicSigAccount. By default this will create an escrow\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\n   * LogicSigAccount to make it a delegated account.\n   *\n   * @param program - The compiled TEAL program which contains the logic for\n   *   this LogicSig.\n   * @param args - An optional array of arguments for the program.\n   */\n  constructor(program: Uint8Array, args?: Array<Uint8Array> | null) {\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getEncodingSchema(): encoding.Schema {\n    return LogicSigAccount.encodingSchema;\n  }\n\n  toEncodingData(): Map<string, unknown> {\n    return new Map<string, unknown>([\n      ['lsig', this.lsig.toEncodingData()],\n      ['sigkey', this.sigkey],\n    ]);\n  }\n\n  static fromEncodingData(data: unknown): LogicSigAccount {\n    if (!(data instanceof Map)) {\n      throw new Error(`Invalid decoded logic sig account: ${data}`);\n    }\n    const value = data as Map<string, unknown>;\n    const lsig = LogicSig.fromEncodingData(value.get('lsig'));\n    const lsigAccount = new LogicSigAccount(lsig.logic, lsig.args);\n    lsigAccount.lsig = lsig; // Restore other properties of the lsig\n    lsigAccount.sigkey = value.get('sigkey') as Uint8Array;\n    return lsigAccount;\n  }\n\n  /**\n   * Encode this object into msgpack.\n   */\n  toByte(): Uint8Array {\n    return encoding.encodeMsgpack(this);\n  }\n\n  /**\n   * Decode a msgpack object into a LogicSigAccount.\n   * @param encoded - The encoded LogicSigAccount.\n   */\n  static fromByte(encoded: ArrayLike<any>): LogicSigAccount {\n    return encoding.decodeMsgpack(encoded, LogicSigAccount);\n  }\n\n  /**\n   * Check if this LogicSigAccount has been delegated to another account with a\n   * signature.\n   *\n   * Note this function only checks for the presence of a delegation signature.\n   * To verify the delegation signature, use `verify`.\n   */\n  isDelegated() {\n    return !!(this.lsig.sig || this.lsig.msig);\n  }\n\n  /**\n   * Verifies this LogicSig's program and signatures.\n   * @returns true if and only if the LogicSig program and signatures are valid.\n   */\n  verify() {\n    const addr = this.address();\n    return this.lsig.verify(addr.publicKey);\n  }\n\n  /**\n   * Get the address of this LogicSigAccount.\n   *\n   * If the LogicSig is delegated to another account, this will return the\n   * address of that account.\n   *\n   * If the LogicSig is not delegated to another account, this will return an\n   *  escrow address that is the hash of the LogicSig's program code.\n   */\n  address(): Address {\n    if (this.lsig.sig && this.lsig.msig) {\n      throw new Error(\n        'LogicSig has too many signatures. At most one of sig or msig may be present'\n      );\n    }\n\n    if (this.lsig.sig) {\n      if (!this.sigkey) {\n        throw new Error('Signing key for delegated account is missing');\n      }\n      return new Address(this.sigkey);\n    }\n\n    if (this.lsig.msig) {\n      const msigMetadata = {\n        version: this.lsig.msig.v,\n        threshold: this.lsig.msig.thr,\n        pks: this.lsig.msig.subsig.map((subsig) => subsig.pk),\n      };\n      return addressFromMultisigPreImg(msigMetadata);\n    }\n\n    return this.lsig.address();\n  }\n\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. Use this function if the delegating account is a\n   * multisig account.\n   *\n   * @param msig - The multisig delegating account\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account. Use `appendToMultisig` to add additional signatures\n   *   from other members.\n   */\n  signMultisig(msig: MultisigMetadata, secretKey: Uint8Array) {\n    this.lsig.sign(secretKey, msig);\n  }\n\n  /**\n   * Adds an additional signature from a member of the delegating multisig\n   * account.\n   *\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account.\n   */\n  appendToMultisig(secretKey: Uint8Array) {\n    this.lsig.appendToMultisig(secretKey);\n  }\n\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. If the delegating account is a multisig account,\n   * use `signMultisig` instead.\n   *\n   * @param secretKey - The secret key of the delegating account.\n   */\n  sign(secretKey: Uint8Array) {\n    this.lsig.sign(secretKey);\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n  }\n}\n\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nexport function logicSigFromByte(encoded: Uint8Array): LogicSig {\n  return encoding.decodeMsgpack(encoded, LogicSig);\n}\n\nconst SIGN_PROGRAM_DATA_PREFIX = new TextEncoder().encode('ProgData');\n\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\n * @param sk - Uint8Array with secret key\n * @param data - Uint8Array with data to sign\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n */\nexport function tealSign(\n  sk: Uint8Array,\n  data: Uint8Array,\n  programHash: string | Address\n) {\n  const programAddr =\n    typeof programHash === 'string'\n      ? Address.fromString(programHash)\n      : programHash;\n  const parts = utils.concatArrays(programAddr.publicKey, data);\n  const toBeSigned = utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);\n  return nacl.sign(toBeSigned, sk);\n}\n\n/**\n * verifyTealSign verifies a signature as would the ed25519verify opcode\n * @param data - Uint8Array with original signed data\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\n * @param pk - uint8array with public key to verify against\n */\nexport function verifyTealSign(\n  data: Uint8Array,\n  programHash: string | Address,\n  sig: Uint8Array,\n  pk: Uint8Array\n) {\n  const programAddr =\n    typeof programHash === 'string'\n      ? Address.fromString(programHash)\n      : programHash;\n  const parts = utils.concatArrays(programAddr.publicKey, data);\n  const toBeSigned = utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts);\n  return nacl.verify(toBeSigned, sig, pk);\n}\n\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - Uint8Array with data to sign\n * @param program - Uint8Array with teal program\n */\nexport function tealSignFromProgram(\n  sk: Uint8Array,\n  data: Uint8Array,\n  program: Uint8Array\n) {\n  const lsig = new LogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,wBAAwB;AAC9C,SAASC,OAAO,EAAEC,cAAc,QAAQ,uBAAuB;AAC/D,OAAO,KAAKC,QAAQ,MAAM,wBAAwB;AAClD,SACEC,cAAc,EACdC,WAAW,EACXC,eAAe,EACfC,0BAA0B,EAC1BC,cAAc,EACdC,YAAY,QACP,4BAA4B;AACnC,SAEEC,cAAc,EACdC,yBAAyB,EACzBC,gBAAgB,QACX,eAAe;AACtB,OAAO,KAAKC,KAAK,MAAM,kBAAkB;AACzC,SAEEC,6BAA6B,EAC7BC,+BAA+B,EAC/BC,uBAAuB,QAClB,iCAAiC;AAExC;AACA,MAAMC,WAAW,GACf,kEAAkE;AAEpE;;;;;AAKA,OAAM,SAAUC,kBAAkBA,CAACC,OAAmB;EACpD,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACC,MAAM,KAAK,CAAC,EAAE,MAAM,IAAIC,KAAK,CAAC,eAAe,CAAC;EAEtE,MAAMC,YAAY,GAAG,IAAI,CAACC,UAAU,CAAC,CAAC,CAAC;EACvC,MAAMC,aAAa,GAAG,GAAG,CAACD,UAAU,CAAC,CAAC,CAAC;EACvC,MAAME,QAAQ,GAAG,GAAG,CAACF,UAAU,CAAC,CAAC,CAAC;EAElC,MAAMG,WAAW,GAAIC,CAAS,IAAKH,aAAa,IAAIG,CAAC,IAAIA,CAAC,IAAIF,QAAQ;EACtE,MAAMG,gBAAgB,GAAGT,OAAO,CAACU,KAAK,CACnCF,CAAS,IAAKA,CAAC,KAAKL,YAAY,IAAII,WAAW,CAACC,CAAC,CAAC,CACpD;EAED,IAAIC,gBAAgB,EAAE;IACpB,MAAME,UAAU,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAACb,OAAO,CAAC;IAEpD,IAAIjB,cAAc,CAAC4B,UAAU,CAAC,EAC5B,MAAM,IAAIT,KAAK,CAAC,gDAAgD,CAAC;IAEnE,IAAIJ,WAAW,CAACgB,IAAI,CAACH,UAAU,CAAC,EAC9B,MAAM,IAAIT,KAAK,CAAC,mCAAmC,CAAC;IAEtD,MAAM,IAAIA,KAAK,CACb,mFAAmF,CACpF;EACH;AACF;AAEA,MAAMa,UAAU,GAAG,IAAIC,WAAW,EAAE,CAACC,MAAM,CAAC,SAAS,CAAC;AAEtD;;;;;AAKA,OAAM,MAAOC,QAAQ;EA2BnBC,YAAYnB,OAAmB,EAAEoB,WAAsC;IACrE,IACEA,WAAW,KACV,CAACC,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,IAC1B,CAACA,WAAW,CAACV,KAAK,CAAEa,GAAG,IAAKA,GAAG,CAACJ,WAAW,KAAKK,UAAU,CAAC,CAAC,EAC9D;MACA,MAAM,IAAIC,SAAS,CAAC,mBAAmB,CAAC;IAC1C;IAEA,IAAIC,IAAI,GAAiB,EAAE;IAC3B,IAAIN,WAAW,IAAI,IAAI,EACrBM,IAAI,GAAGN,WAAW,CAACO,GAAG,CAAEJ,GAAG,IAAK,IAAIC,UAAU,CAACD,GAAG,CAAC,CAAC;IAEtDxB,kBAAkB,CAACC,OAAO,CAAC;IAE3B,IAAI,CAAC4B,KAAK,GAAG5B,OAAO;IACpB,IAAI,CAAC0B,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACG,GAAG,GAAGC,SAAS;IACpB,IAAI,CAACC,IAAI,GAAGD,SAAS;EACvB;EAEA;EACAE,iBAAiBA,CAAA;IACf,OAAOd,QAAQ,CAACe,cAAc;EAChC;EAEAC,cAAcA,CAAA;IACZ,MAAMC,IAAI,GAAG,IAAIC,GAAG,CAAkB,CACpC,CAAC,GAAG,EAAE,IAAI,CAACR,KAAK,CAAC,EACjB,CAAC,KAAK,EAAE,IAAI,CAACF,IAAI,CAAC,EAClB,CAAC,KAAK,EAAE,IAAI,CAACG,GAAG,CAAC,CAClB,CAAC;IACF,IAAI,IAAI,CAACE,IAAI,EAAE;MACbI,IAAI,CAACE,GAAG,CAAC,MAAM,EAAE1C,6BAA6B,CAAC,IAAI,CAACoC,IAAI,CAAC,CAAC;IAC5D;IACA,OAAOI,IAAI;EACb;EAEA,OAAOG,gBAAgBA,CAACH,IAAa;IACnC,IAAI,EAAEA,IAAI,YAAYC,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAIlC,KAAK,CAAC,8BAA8BiC,IAAI,EAAE,CAAC;IACvD;IACA,MAAMI,IAAI,GAAG,IAAIrB,QAAQ,CAACiB,IAAI,CAACK,GAAG,CAAC,GAAG,CAAC,EAAEL,IAAI,CAACK,GAAG,CAAC,KAAK,CAAC,CAAC;IACzDD,IAAI,CAACV,GAAG,GAAGM,IAAI,CAACK,GAAG,CAAC,KAAK,CAAC;IAC1B,IAAIL,IAAI,CAACK,GAAG,CAAC,MAAM,CAAC,EAAE;MACpBD,IAAI,CAACR,IAAI,GAAGnC,+BAA+B,CAACuC,IAAI,CAACK,GAAG,CAAC,MAAM,CAAC,CAAC;IAC/D;IACA,OAAOD,IAAI;EACb;EAEA;;;;EAIAE,MAAMA,CAACC,SAAqB;IAC1B,IAAI,IAAI,CAACb,GAAG,IAAI,IAAI,CAACE,IAAI,EAAE;MACzB,OAAO,KAAK;IACd;IAEA,IAAI;MACFhC,kBAAkB,CAAC,IAAI,CAAC6B,KAAK,CAAC;IAChC,CAAC,CAAC,OAAOe,CAAC,EAAE;MACV,OAAO,KAAK;IACd;IAEA,MAAMC,UAAU,GAAGlD,KAAK,CAACmD,YAAY,CAAC9B,UAAU,EAAE,IAAI,CAACa,KAAK,CAAC;IAE7D,IAAI,CAAC,IAAI,CAACC,GAAG,IAAI,CAAC,IAAI,CAACE,IAAI,EAAE;MAC3B,MAAMe,IAAI,GAAGjE,IAAI,CAACkE,WAAW,CAACH,UAAU,CAAC;MACzC,OAAOlD,KAAK,CAACsD,UAAU,CAACF,IAAI,EAAEJ,SAAS,CAAC;IAC1C;IAEA,IAAI,IAAI,CAACb,GAAG,EAAE;MACZ,OAAOhD,IAAI,CAAC4D,MAAM,CAACG,UAAU,EAAE,IAAI,CAACf,GAAG,EAAEa,SAAS,CAAC;IACrD;IAEA,OAAOnD,cAAc,CAACqD,UAAU,EAAE,IAAI,CAACb,IAAK,EAAEW,SAAS,CAAC;EAC1D;EAEA;;;;EAIAO,OAAOA,CAAA;IACL,MAAML,UAAU,GAAGlD,KAAK,CAACmD,YAAY,CAAC9B,UAAU,EAAE,IAAI,CAACa,KAAK,CAAC;IAC7D,MAAMkB,IAAI,GAAGjE,IAAI,CAACkE,WAAW,CAACH,UAAU,CAAC;IACzC,OAAO,IAAI9D,OAAO,CAAC0C,UAAU,CAAC0B,IAAI,CAACJ,IAAI,CAAC,CAAC;EAC3C;EAEA;;;;;EAKAK,IAAIA,CAACC,SAAqB,EAAErB,IAAuB;IACjD,IAAIA,IAAI,IAAI,IAAI,EAAE;MAChB,IAAI,CAACF,GAAG,GAAG,IAAI,CAACwB,WAAW,CAACD,SAAS,CAAC;IACxC,CAAC,MAAM;MACL,MAAME,OAAO,GAAG7D,gBAAgB,CAACsC,IAAI,CAACwB,KAAK,CAAC,CAAC5B,GAAG,CAAE6B,EAAE,KAAM;QAAEA;MAAE,CAAE,CAAC,CAAC;MAElE,IAAI,CAACzB,IAAI,GAAG;QACV0B,CAAC,EAAE1B,IAAI,CAAC2B,OAAO;QACfC,GAAG,EAAE5B,IAAI,CAAC6B,SAAS;QACnBC,MAAM,EAAEP;OACT;MAED,MAAM,CAACzB,GAAG,EAAEiC,KAAK,CAAC,GAAG,IAAI,CAACC,kBAAkB,CAACX,SAAS,EAAE,IAAI,CAACrB,IAAI,CAAC;MAClE,IAAI,CAACA,IAAI,CAAC8B,MAAM,CAACC,KAAK,CAAC,CAACE,CAAC,GAAGnC,GAAG;IACjC;EACF;EAEA;;;;EAIAoC,gBAAgBA,CAACb,SAAqB;IACpC,IAAI,IAAI,CAACrB,IAAI,KAAKD,SAAS,EAAE;MAC3B,MAAM,IAAI5B,KAAK,CAAC,qBAAqB,CAAC;IACxC;IACA,MAAM,CAAC2B,GAAG,EAAEiC,KAAK,CAAC,GAAG,IAAI,CAACC,kBAAkB,CAACX,SAAS,EAAE,IAAI,CAACrB,IAAI,CAAC;IAClE,IAAI,CAACA,IAAI,CAAC8B,MAAM,CAACC,KAAK,CAAC,CAACE,CAAC,GAAGnC,GAAG;EACjC;EAEAwB,WAAWA,CAACD,SAAqB;IAC/B,MAAMR,UAAU,GAAGlD,KAAK,CAACmD,YAAY,CAAC9B,UAAU,EAAE,IAAI,CAACa,KAAK,CAAC;IAC7D,MAAMC,GAAG,GAAGhD,IAAI,CAACsE,IAAI,CAACP,UAAU,EAAEQ,SAAS,CAAC;IAC5C,OAAOvB,GAAG;EACZ;EAEAkC,kBAAkBA,CAChBX,SAAqB,EACrBrB,IAAqB;IAErB,IAAI+B,KAAK,GAAG,CAAC,CAAC;IACd,MAAMI,IAAI,GAAGrF,IAAI,CAACsF,oBAAoB,CAACf,SAAS,CAAC,CAACV,SAAS;IAC3D,KAAK,IAAI0B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGrC,IAAI,CAAC8B,MAAM,CAAC5D,MAAM,EAAEmE,CAAC,EAAE,EAAE;MAC3C,MAAM;QAAEZ;MAAE,CAAE,GAAGzB,IAAI,CAAC8B,MAAM,CAACO,CAAC,CAAC;MAC7B,IAAI1E,KAAK,CAACsD,UAAU,CAACQ,EAAE,EAAEU,IAAI,CAAC,EAAE;QAC9BJ,KAAK,GAAGM,CAAC;QACT;MACF;IACF;IACA,IAAIN,KAAK,KAAK,CAAC,CAAC,EAAE;MAChB,MAAM,IAAI5D,KAAK,CAAC,oBAAoB,CAAC;IACvC;IACA,MAAM2B,GAAG,GAAG,IAAI,CAACwB,WAAW,CAACD,SAAS,CAAC;IACvC,OAAO,CAACvB,GAAG,EAAEiC,KAAK,CAAC;EACrB;EAEAO,MAAMA,CAAA;IACJ,OAAOrF,QAAQ,CAACsF,aAAa,CAAC,IAAI,CAAC;EACrC;EAEA,OAAOC,QAAQA,CAACC,OAAuB;IACrC,OAAOxF,QAAQ,CAACyF,aAAa,CAACD,OAAO,EAAEtD,QAAQ,CAAC;EAClD;;AArLgBA,QAAA,CAAAe,cAAc,GAAG,IAAIhD,cAAc,CACjDK,YAAY,CAAC,CACX;EACEoF,GAAG,EAAE,GAAG;EACRC,WAAW,EAAE,IAAIxF,eAAe;CACjC,EACD;EACEuF,GAAG,EAAE,KAAK;EACVC,WAAW,EAAE,IAAIzF,WAAW,CAAC,IAAIC,eAAe,EAAE;CACnD,EACD;EACEuF,GAAG,EAAE,KAAK;EACVC,WAAW,EAAE,IAAItF,cAAc,CAAC,IAAID,0BAA0B,CAAC,EAAE,CAAC;CACnE,EACD;EACEsF,GAAG,EAAE,MAAM;EACXC,WAAW,EAAE,IAAItF,cAAc,CAACQ,uBAAuB;CACxD,CACF,CAAC,CACH;AAqKH;;;AAGA,OAAM,MAAO+E,eAAe;EAiB1B;;;;;;;;;EASAzD,YAAYnB,OAAmB,EAAE0B,IAA+B;IAC9D,IAAI,CAACa,IAAI,GAAG,IAAIrB,QAAQ,CAAClB,OAAO,EAAE0B,IAAI,CAAC;IACvC,IAAI,CAACmD,MAAM,GAAG/C,SAAS;EACzB;EAEA;EACAE,iBAAiBA,CAAA;IACf,OAAO4C,eAAe,CAAC3C,cAAc;EACvC;EAEAC,cAAcA,CAAA;IACZ,OAAO,IAAIE,GAAG,CAAkB,CAC9B,CAAC,MAAM,EAAE,IAAI,CAACG,IAAI,CAACL,cAAc,EAAE,CAAC,EACpC,CAAC,QAAQ,EAAE,IAAI,CAAC2C,MAAM,CAAC,CACxB,CAAC;EACJ;EAEA,OAAOvC,gBAAgBA,CAACH,IAAa;IACnC,IAAI,EAAEA,IAAI,YAAYC,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAIlC,KAAK,CAAC,sCAAsCiC,IAAI,EAAE,CAAC;IAC/D;IACA,MAAM2C,KAAK,GAAG3C,IAA4B;IAC1C,MAAMI,IAAI,GAAGrB,QAAQ,CAACoB,gBAAgB,CAACwC,KAAK,CAACtC,GAAG,CAAC,MAAM,CAAC,CAAC;IACzD,MAAMuC,WAAW,GAAG,IAAIH,eAAe,CAACrC,IAAI,CAACX,KAAK,EAAEW,IAAI,CAACb,IAAI,CAAC;IAC9DqD,WAAW,CAACxC,IAAI,GAAGA,IAAI,CAAC,CAAC;IACzBwC,WAAW,CAACF,MAAM,GAAGC,KAAK,CAACtC,GAAG,CAAC,QAAQ,CAAe;IACtD,OAAOuC,WAAW;EACpB;EAEA;;;EAGAV,MAAMA,CAAA;IACJ,OAAOrF,QAAQ,CAACsF,aAAa,CAAC,IAAI,CAAC;EACrC;EAEA;;;;EAIA,OAAOC,QAAQA,CAACC,OAAuB;IACrC,OAAOxF,QAAQ,CAACyF,aAAa,CAACD,OAAO,EAAEI,eAAe,CAAC;EACzD;EAEA;;;;;;;EAOAI,WAAWA,CAAA;IACT,OAAO,CAAC,EAAE,IAAI,CAACzC,IAAI,CAACV,GAAG,IAAI,IAAI,CAACU,IAAI,CAACR,IAAI,CAAC;EAC5C;EAEA;;;;EAIAU,MAAMA,CAAA;IACJ,MAAMwC,IAAI,GAAG,IAAI,CAAChC,OAAO,EAAE;IAC3B,OAAO,IAAI,CAACV,IAAI,CAACE,MAAM,CAACwC,IAAI,CAACvC,SAAS,CAAC;EACzC;EAEA;;;;;;;;;EASAO,OAAOA,CAAA;IACL,IAAI,IAAI,CAACV,IAAI,CAACV,GAAG,IAAI,IAAI,CAACU,IAAI,CAACR,IAAI,EAAE;MACnC,MAAM,IAAI7B,KAAK,CACb,6EAA6E,CAC9E;IACH;IAEA,IAAI,IAAI,CAACqC,IAAI,CAACV,GAAG,EAAE;MACjB,IAAI,CAAC,IAAI,CAACgD,MAAM,EAAE;QAChB,MAAM,IAAI3E,KAAK,CAAC,8CAA8C,CAAC;MACjE;MACA,OAAO,IAAIpB,OAAO,CAAC,IAAI,CAAC+F,MAAM,CAAC;IACjC;IAEA,IAAI,IAAI,CAACtC,IAAI,CAACR,IAAI,EAAE;MAClB,MAAMmD,YAAY,GAAG;QACnBxB,OAAO,EAAE,IAAI,CAACnB,IAAI,CAACR,IAAI,CAAC0B,CAAC;QACzBG,SAAS,EAAE,IAAI,CAACrB,IAAI,CAACR,IAAI,CAAC4B,GAAG;QAC7BwB,GAAG,EAAE,IAAI,CAAC5C,IAAI,CAACR,IAAI,CAAC8B,MAAM,CAAClC,GAAG,CAAEkC,MAAM,IAAKA,MAAM,CAACL,EAAE;OACrD;MACD,OAAOhE,yBAAyB,CAAC0F,YAAY,CAAC;IAChD;IAEA,OAAO,IAAI,CAAC3C,IAAI,CAACU,OAAO,EAAE;EAC5B;EAEA;;;;;;;;;;;EAWAmC,YAAYA,CAACrD,IAAsB,EAAEqB,SAAqB;IACxD,IAAI,CAACb,IAAI,CAACY,IAAI,CAACC,SAAS,EAAErB,IAAI,CAAC;EACjC;EAEA;;;;;;;EAOAkC,gBAAgBA,CAACb,SAAqB;IACpC,IAAI,CAACb,IAAI,CAAC0B,gBAAgB,CAACb,SAAS,CAAC;EACvC;EAEA;;;;;;;;EAQAD,IAAIA,CAACC,SAAqB;IACxB,IAAI,CAACb,IAAI,CAACY,IAAI,CAACC,SAAS,CAAC;IACzB,IAAI,CAACyB,MAAM,GAAGhG,IAAI,CAACsF,oBAAoB,CAACf,SAAS,CAAC,CAACV,SAAS;EAC9D;;AAjKgBkC,eAAA,CAAA3C,cAAc,GAAG,IAAIhD,cAAc,CACjDK,YAAY,CAAC,CACX;EACEoF,GAAG,EAAE,MAAM;EACXC,WAAW,EAAEzD,QAAQ,CAACe;CACvB,EACD;EACEyC,GAAG,EAAE,QAAQ;EACbC,WAAW,EAAE,IAAItF,cAAc,CAAC,IAAID,0BAA0B,CAAC,EAAE,CAAC;CACnE,CACF,CAAC,CACH;AAyJH;;;;AAIA,OAAM,SAAUiG,gBAAgBA,CAACb,OAAmB;EAClD,OAAOxF,QAAQ,CAACyF,aAAa,CAACD,OAAO,EAAEtD,QAAQ,CAAC;AAClD;AAEA,MAAMoE,wBAAwB,GAAG,IAAItE,WAAW,EAAE,CAACC,MAAM,CAAC,UAAU,CAAC;AAErE;;;;;;AAMA,OAAM,SAAUsE,QAAQA,CACtBC,EAAc,EACdrD,IAAgB,EAChBsD,WAA6B;EAE7B,MAAMC,WAAW,GACf,OAAOD,WAAW,KAAK,QAAQ,GAC3B3G,OAAO,CAAC6G,UAAU,CAACF,WAAW,CAAC,GAC/BA,WAAW;EACjB,MAAMG,KAAK,GAAGlG,KAAK,CAACmD,YAAY,CAAC6C,WAAW,CAAChD,SAAS,EAAEP,IAAI,CAAC;EAC7D,MAAMS,UAAU,GAAGlD,KAAK,CAACmD,YAAY,CAACyC,wBAAwB,EAAEM,KAAK,CAAC;EACtE,OAAO/G,IAAI,CAACsE,IAAI,CAACP,UAAU,EAAE4C,EAAE,CAAC;AAClC;AAEA;;;;;;;AAOA,OAAM,SAAUK,cAAcA,CAC5B1D,IAAgB,EAChBsD,WAA6B,EAC7B5D,GAAe,EACf2B,EAAc;EAEd,MAAMkC,WAAW,GACf,OAAOD,WAAW,KAAK,QAAQ,GAC3B3G,OAAO,CAAC6G,UAAU,CAACF,WAAW,CAAC,GAC/BA,WAAW;EACjB,MAAMG,KAAK,GAAGlG,KAAK,CAACmD,YAAY,CAAC6C,WAAW,CAAChD,SAAS,EAAEP,IAAI,CAAC;EAC7D,MAAMS,UAAU,GAAGlD,KAAK,CAACmD,YAAY,CAACyC,wBAAwB,EAAEM,KAAK,CAAC;EACtE,OAAO/G,IAAI,CAAC4D,MAAM,CAACG,UAAU,EAAEf,GAAG,EAAE2B,EAAE,CAAC;AACzC;AAEA;;;;;;AAMA,OAAM,SAAUsC,mBAAmBA,CACjCN,EAAc,EACdrD,IAAgB,EAChBnC,OAAmB;EAEnB,MAAMuC,IAAI,GAAG,IAAIrB,QAAQ,CAAClB,OAAO,CAAC;EAClC,MAAM+F,eAAe,GAAGxD,IAAI,CAACU,OAAO,EAAE;EACtC,OAAOsC,QAAQ,CAACC,EAAE,EAAErD,IAAI,EAAE4D,eAAe,CAAC;AAC5C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}