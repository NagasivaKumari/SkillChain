{"ast":null,"code":"/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { encodeAddress, decodeAddress, Address } from '../encoding/address.js';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint.js';\nimport { concatArrays } from '../utils/utils.js';\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\nexport class ABIType {\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str) {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (!stringMatches || stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = s => [...s].every(c => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (!stringMatches || stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));\n      const tupleTypes = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\nexport class ABIUintType extends ABIType {\n  constructor(size) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n  equals(other) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIUfixedType extends ABIType {\n  constructor(size, denominator) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n  equals(other) {\n    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n  equals(other) {\n    return other instanceof ABIAddressType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n    if (value instanceof Address) {\n      return value.publicKey;\n    }\n    if (value instanceof Uint8Array) {\n      if (value.byteLength !== 32) {\n        throw new Error(`byte string must be 32 bytes long for an address`);\n      }\n      return value;\n    }\n    throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n  equals(other) {\n    return other instanceof ABIBoolType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n  equals(other) {\n    return other instanceof ABIByteType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n  equals(other) {\n    return other instanceof ABIStringType;\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    let encodedBytes;\n    if (typeof value === 'string') {\n      encodedBytes = new TextEncoder().encode(value);\n    } else {\n      encodedBytes = value;\n    }\n    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);\n    }\n    const view = new DataView(byteString.buffer, byteString.byteOffset, LENGTH_ENCODE_BYTE_SIZE);\n    const byteLength = view.getUint16(0);\n    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);\n    if (byteLength !== byteValue.length) {\n      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);\n    }\n    return new TextDecoder('utf-8').decode(byteValue);\n  }\n}\nexport class ABIArrayStaticType extends ABIType {\n  constructor(argType, arrayLength) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(`static array must have a non negative length: ${arrayLength}`);\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n  decode(byteString) {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\nexport class ABIArrayDynamicType extends ABIType {\n  constructor(argType) {\n    super();\n    this.childType = argType;\n  }\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    const view = new DataView(byteString.buffer, 0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteLength = view.getUint16(0);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));\n  }\n  toABITupleType(length) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\nexport class ABITupleType extends ABIType {\n  constructor(argTypes) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error('tuple type child type number larger than maximum uint16 error');\n    }\n    this.childTypes = argTypes;\n  }\n  toString() {\n    const typeStrings = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n  equals(other) {\n    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));\n  }\n  isDynamic() {\n    const isDynamic = child => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads = [];\n    const tails = [];\n    const isDynamicIndex = new Map();\n    let i = 0;\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error('expected before index should have number of bool mod 8 equal 0');\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(`byte length of ${headValue} should not exceed a uint16`);\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n    return concatArrays(...heads, ...tails);\n  }\n  decode(byteString) {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments = [];\n    const valuePartition = [];\n    let i = 0;\n    let iterIndex = 0;\n    const view = new DataView(byteString.buffer);\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        // Since LENGTH_ENCODE_BYTE_SIZE is 2 and indices are at most 2 bytes,\n        // we can use getUint16 using the iterIndex offset.\n        const dynamicIndex = view.getUint16(iterIndex);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error('dynamic index segment miscalculation: left is greater than right index');\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg = {\n          left: dynamicIndex,\n          right: -1\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error('dynamic segment should display a [l, r] space with l <= r');\n      }\n      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);\n        segIndex += 1;\n      }\n    }\n    // Decode each tuple element\n    const returnValues = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n  static parseTupleContent(str) {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n    const tupleStrings = [];\n    let depth = 0;\n    let word = '';\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList) {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << 7 - i;\n    }\n  }\n  return res;\n}\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList, index, delta) {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}","map":{"version":3,"names":["encodeAddress","decodeAddress","Address","bigIntToBytes","bytesToBigInt","concatArrays","MAX_LEN","ADDR_BYTE_SIZE","SINGLE_BYTE_SIZE","SINGLE_BOOL_SIZE","LENGTH_ENCODE_BYTE_SIZE","staticArrayRegexp","ufixedRegexp","ABIType","from","str","endsWith","arrayArgType","slice","length","ABIArrayDynamicType","stringMatches","match","Error","arrayLengthStr","arrayLength","parseInt","arrayType","ABIArrayStaticType","startsWith","digitsOnly","s","every","c","includes","typeSizeStr","typeSize","ABIUintType","ABIByteType","ufixedSize","ufixedPrecision","ABIUfixedType","ABIBoolType","ABIAddressType","ABIStringType","tupleContent","ABITupleType","parseTupleContent","tupleTypes","i","ti","push","constructor","size","bitSize","toString","equals","other","isDynamic","byteLen","encode","value","BigInt","Number","isSafeInteger","decode","byteString","denominator","precision","decodedAddress","publicKey","Uint8Array","byteLength","encodedBytes","TextEncoder","encodedLength","mergedBytes","set","view","DataView","buffer","byteOffset","getUint16","byteValue","TextDecoder","argType","childType","staticLength","Math","ceil","Array","isArray","convertedTuple","toABITupleType","fill","encodedTuple","childTypes","argTypes","typeStrings","join","child","index","some","after","findBoolLR","boolNum","trunc","childByteSize","values","heads","tails","isDynamicIndex","Map","tupleType","before","min","compressedInt","compressMultipleBool","encodedTupleValue","headLength","headElement","tailLength","j","get","headValue","dynamicSegments","valuePartition","iterIndex","dynamicIndex","right","left","seg","boolIndex","boolMask","currLen","segIndex","returnValues","valueTi","tupleStrings","depth","word","char","valueList","res","boolVal","typeList","delta","until","curr"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\abi\\abi_type.ts"],"sourcesContent":["/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { encodeAddress, decodeAddress, Address } from '../encoding/address.js';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint.js';\nimport { concatArrays } from '../utils/utils.js';\n\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\n\ninterface Segment {\n  left: number;\n  right: number;\n}\n\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\n\nexport type ABIValue =\n  | boolean\n  | number\n  | bigint\n  | string\n  | Uint8Array\n  | ABIValue[]\n  | Address;\n\nexport abstract class ABIType {\n  // Converts a ABIType object to a string\n  abstract toString(): string;\n  // Checks if two ABIType objects are equal in value\n  abstract equals(other: ABIType): boolean;\n  // Checks if the ABIType object (or any of its child types) have dynamic length\n  abstract isDynamic(): boolean;\n  // Returns the size of the ABIType object in bytes\n  abstract byteLen(): number;\n  // Encodes a value for the ABIType object using the ABI specs\n  abstract encode(value: ABIValue): Uint8Array;\n  // Decodes a value for the ABIType object using the ABI specs\n  abstract decode(byteString: Uint8Array): ABIValue;\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str: string): ABIType {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (!stringMatches || stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = (s: string) =>\n        [...s].every((c) => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (!stringMatches || stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(\n        str.slice(1, str.length - 1)\n      );\n      const tupleTypes: ABIType[] = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\n\nexport class ABIUintType extends ABIType {\n  bitSize: number;\n\n  constructor(size: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIUfixedType extends ABIType {\n  bitSize: number;\n  precision: number;\n\n  constructor(size: number, denominator: number) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIUfixedType &&\n      this.bitSize === other.bitSize &&\n      this.precision === other.precision\n    );\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return this.bitSize / 8;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(\n        `${value} is not a non-negative int or too big to fit in size ${this.toString()}`\n      );\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(\n        `${value} should be converted into a BigInt before it is encoded`\n      );\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n\n  decode(byteString: Uint8Array): bigint {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\n\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIAddressType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n\n    if (value instanceof Address) {\n      return value.publicKey;\n    }\n\n    if (value instanceof Uint8Array) {\n      if (value.byteLength !== 32) {\n        throw new Error(`byte string must be 32 bytes long for an address`);\n      }\n\n      return value;\n    }\n\n    throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\n\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIBoolType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n\n  decode(byteString: Uint8Array): boolean {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\n\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIByteType;\n  }\n\n  isDynamic() {\n    return false;\n  }\n\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n\n  decode(byteString: Uint8Array): number {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\n\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n\n  equals(other: ABIType) {\n    return other instanceof ABIStringType;\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    let encodedBytes: Uint8Array;\n    if (typeof value === 'string') {\n      encodedBytes = new TextEncoder().encode(value);\n    } else {\n      encodedBytes = value;\n    }\n    const encodedLength = bigIntToBytes(\n      encodedBytes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = new Uint8Array(\n      encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE\n    );\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): string {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(\n        `byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`\n      );\n    }\n    const view = new DataView(\n      byteString.buffer,\n      byteString.byteOffset,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const byteLength = view.getUint16(0);\n    const byteValue = byteString.slice(\n      LENGTH_ENCODE_BYTE_SIZE,\n      byteString.length\n    );\n    if (byteLength !== byteValue.length) {\n      throw new Error(\n        `string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`\n      );\n    }\n    return new TextDecoder('utf-8').decode(byteValue);\n  }\n}\n\nexport class ABIArrayStaticType extends ABIType {\n  childType: ABIType;\n  staticLength: number;\n\n  constructor(argType: ABIType, arrayLength: number) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(\n        `static array must have a non negative length: ${arrayLength}`\n      );\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayStaticType &&\n      this.staticLength === other.staticLength &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(\n        `Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`\n      );\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\n\nexport class ABIArrayDynamicType extends ABIType {\n  childType: ABIType;\n\n  constructor(argType: ABIType) {\n    super();\n    this.childType = argType;\n  }\n\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABIArrayDynamicType &&\n      this.childType.equals(other.childType)\n    );\n  }\n\n  isDynamic() {\n    return true;\n  }\n\n  byteLen(): never {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(\n      convertedTuple.childTypes.length,\n      LENGTH_ENCODE_BYTE_SIZE\n    );\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const view = new DataView(byteString.buffer, 0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteLength = view.getUint16(0);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(\n      byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length)\n    );\n  }\n\n  toABITupleType(length: number) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\n\nexport class ABITupleType extends ABIType {\n  childTypes: ABIType[];\n\n  constructor(argTypes: ABIType[]) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error(\n        'tuple type child type number larger than maximum uint16 error'\n      );\n    }\n    this.childTypes = argTypes;\n  }\n\n  toString() {\n    const typeStrings: string[] = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n\n  equals(other: ABIType) {\n    return (\n      other instanceof ABITupleType &&\n      this.childTypes.length === other.childTypes.length &&\n      this.childTypes.every((child, index) =>\n        child.equals(other.childTypes[index])\n      )\n    );\n  }\n\n  isDynamic() {\n    const isDynamic = (child: ABIType) => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n\n  encode(value: ABIValue) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads: Uint8Array[] = [];\n    const tails: Uint8Array[] = [];\n    const isDynamicIndex = new Map<number, boolean>();\n    let i = 0;\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error(\n              'expected before index should have number of bool mod 8 equal 0'\n            );\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(\n            values.slice(i, i + after + 1)\n          );\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(\n            `byte length of ${headValue} should not exceed a uint16`\n          );\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n\n    return concatArrays(...heads, ...tails);\n  }\n\n  decode(byteString: Uint8Array): ABIValue[] {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments: Segment[] = [];\n    const valuePartition: Array<Uint8Array | null> = [];\n    let i = 0;\n    let iterIndex = 0;\n    const view = new DataView(byteString.buffer);\n\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (\n          byteString.slice(iterIndex, byteString.length).length <\n          LENGTH_ENCODE_BYTE_SIZE\n        ) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        // Since LENGTH_ENCODE_BYTE_SIZE is 2 and indices are at most 2 bytes,\n        // we can use getUint16 using the iterIndex offset.\n        const dynamicIndex = view.getUint16(iterIndex);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error(\n              'dynamic index segment miscalculation: left is greater than right index'\n            );\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg: Segment = {\n          left: dynamicIndex,\n          right: -1,\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error(\n          'dynamic segment should display a [l, r] space with l <= r'\n        );\n      }\n      if (\n        j !== dynamicSegments.length - 1 &&\n        seg.right !== dynamicSegments[j + 1].left\n      ) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(\n          dynamicSegments[segIndex].left,\n          dynamicSegments[segIndex].right\n        );\n        segIndex += 1;\n      }\n    }\n\n    // Decode each tuple element\n    const returnValues: ABIValue[] = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]!);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n\n  static parseTupleContent(str: string): string[] {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n\n    const tupleStrings: string[] = [];\n    let depth = 0;\n    let word = '';\n\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList: ABIValue[]): number {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << (7 - i);\n    }\n  }\n  return res;\n}\n\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList: ABIType[], index: number, delta: -1 | 1): number {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}