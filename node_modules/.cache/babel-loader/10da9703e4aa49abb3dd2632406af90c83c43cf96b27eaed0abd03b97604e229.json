{"ast":null,"code":"export function ensureUint8Array(buffer) {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\nexport function createDataView(buffer) {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n  var bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\nexport function compareUint8Arrays(a, b) {\n  var length = Math.min(a.length, b.length);\n  for (var i = 0; i < length; i++) {\n    var diff = a[i] - b[i];\n    if (diff !== 0) {\n      return diff;\n    }\n  }\n  return a.length - b.length;\n}\n/**\n * Represents a binary value that should be encoded as if it were a string.\n *\n * Effectively, this is a string that has already been UTF-8 encoded to a binary string. This is\n * useful if you need to encode a value as a string, but that value contains invalid UTF-8 sequences;\n * ideally this situation should be avoided and the value should be encoded as binary, not string,\n * but this may be necessary for compatibility with non-ideal systems.\n */\nvar RawBinaryString = /** @class */function () {\n  /**\n   * Create a new RawBinaryString from an ArrayBufferView.\n   */\n  function RawBinaryString(rawBinaryValue) {\n    this.rawBinaryValue = rawBinaryValue;\n    if (!ArrayBuffer.isView(rawBinaryValue)) {\n      throw new TypeError(\"RawBinaryString: rawBinaryValue must be an ArrayBufferView\");\n    }\n  }\n  return RawBinaryString;\n}();\nexport { RawBinaryString };","map":{"version":3,"names":["ensureUint8Array","buffer","Uint8Array","ArrayBuffer","isView","byteOffset","byteLength","from","createDataView","DataView","bufferView","compareUint8Arrays","a","b","length","Math","min","i","diff","RawBinaryString","rawBinaryValue","TypeError"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algorand-msgpack\\src\\utils\\typedArrays.ts"],"sourcesContent":["export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer): Uint8Array {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n\nexport function compareUint8Arrays(a: Uint8Array, b: Uint8Array): number {\n  const length = Math.min(a.length, b.length);\n  for (let i = 0; i < length; i++) {\n    const diff = a[i]! - b[i]!;\n    if (diff !== 0) {\n      return diff;\n    }\n  }\n  return a.length - b.length;\n}\n\n/**\n * Represents a binary value that should be encoded as if it were a string.\n *\n * Effectively, this is a string that has already been UTF-8 encoded to a binary string. This is\n * useful if you need to encode a value as a string, but that value contains invalid UTF-8 sequences;\n * ideally this situation should be avoided and the value should be encoded as binary, not string,\n * but this may be necessary for compatibility with non-ideal systems.\n */\nexport class RawBinaryString {\n  /**\n   * Create a new RawBinaryString from an ArrayBufferView.\n   */\n  public constructor(public readonly rawBinaryValue: ArrayBufferView) {\n    if (!ArrayBuffer.isView(rawBinaryValue)) {\n      throw new TypeError(\"RawBinaryString: rawBinaryValue must be an ArrayBufferView\");\n    }\n  }\n}\n"],"mappings":"AAAA,OAAM,SAAUA,gBAAgBA,CAACC,MAAsE;EACrG,IAAIA,MAAM,YAAYC,UAAU,EAAE;IAChC,OAAOD,MAAM;GACd,MAAM,IAAIE,WAAW,CAACC,MAAM,CAACH,MAAM,CAAC,EAAE;IACrC,OAAO,IAAIC,UAAU,CAACD,MAAM,CAACA,MAAM,EAAEA,MAAM,CAACI,UAAU,EAAEJ,MAAM,CAACK,UAAU,CAAC;GAC3E,MAAM,IAAIL,MAAM,YAAYE,WAAW,EAAE;IACxC,OAAO,IAAID,UAAU,CAACD,MAAM,CAAC;GAC9B,MAAM;IACL;IACA,OAAOC,UAAU,CAACK,IAAI,CAACN,MAAM,CAAC;;AAElC;AAEA,OAAM,SAAUO,cAAcA,CAACP,MAAyD;EACtF,IAAIA,MAAM,YAAYE,WAAW,EAAE;IACjC,OAAO,IAAIM,QAAQ,CAACR,MAAM,CAAC;;EAG7B,IAAMS,UAAU,GAAGV,gBAAgB,CAACC,MAAM,CAAC;EAC3C,OAAO,IAAIQ,QAAQ,CAACC,UAAU,CAACT,MAAM,EAAES,UAAU,CAACL,UAAU,EAAEK,UAAU,CAACJ,UAAU,CAAC;AACtF;AAEA,OAAM,SAAUK,kBAAkBA,CAACC,CAAa,EAAEC,CAAa;EAC7D,IAAMC,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACJ,CAAC,CAACE,MAAM,EAAED,CAAC,CAACC,MAAM,CAAC;EAC3C,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,MAAM,EAAEG,CAAC,EAAE,EAAE;IAC/B,IAAMC,IAAI,GAAGN,CAAC,CAACK,CAAC,CAAE,GAAGJ,CAAC,CAACI,CAAC,CAAE;IAC1B,IAAIC,IAAI,KAAK,CAAC,EAAE;MACd,OAAOA,IAAI;;;EAGf,OAAON,CAAC,CAACE,MAAM,GAAGD,CAAC,CAACC,MAAM;AAC5B;AAEA;;;;;;;;AAQA,IAAAK,eAAA;EACE;;;EAGA,SAAAA,gBAAmCC,cAA+B;IAA/B,KAAAA,cAAc,GAAdA,cAAc;IAC/C,IAAI,CAACjB,WAAW,CAACC,MAAM,CAACgB,cAAc,CAAC,EAAE;MACvC,MAAM,IAAIC,SAAS,CAAC,4DAA4D,CAAC;;EAErF;EACF,OAAAF,eAAC;AAAD,CAAC,CATD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}