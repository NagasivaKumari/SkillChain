{"ast":null,"code":"import * as nacl from './nacl/naclWrappers.js';\nimport { Address, ALGORAND_ADDRESS_BYTE_LENGTH, ALGORAND_CHECKSUM_BYTE_LENGTH } from './encoding/address.js';\nimport * as utils from './utils/utils.js';\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nconst INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nconst INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nconst INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nconst UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\nexport function pksFromAddresses(addrs) {\n  return addrs.map(addr => {\n    if (typeof addr === 'string') {\n      return Address.fromString(addr).publicKey;\n    }\n    return addr.publicKey;\n  });\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - array of typed array public keys\n */\nexport function addressFromMultisigPreImg({\n  version,\n  threshold,\n  pks\n}) {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Address(Uint8Array.from(nacl.genericHash(merged)));\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - array of encoded addresses\n */\nexport function addressFromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs\n}) {\n  const pks = pksFromAddresses(addrs);\n  return addressFromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  let pk;\n  try {\n    pk = addressFromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    }).publicKey;\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs\n}) {\n  return addressFromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}","map":{"version":3,"names":["nacl","Address","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","utils","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","INVALID_MSIG_VERSION_ERROR_MSG","INVALID_MSIG_THRESHOLD_ERROR_MSG","INVALID_MSIG_PK_ERROR_MSG","UNEXPECTED_PK_LEN_ERROR_MSG","pksFromAddresses","addrs","map","addr","fromString","publicKey","addressFromMultisigPreImg","version","threshold","pks","Error","length","pkLen","PUBLIC_KEY_LENGTH","merged","set","i","from","genericHash","addressFromMultisigPreImgAddrs","verifyMultisig","toBeVerified","msig","v","thr","subsigs","subsig","pk","e","arrayEqual","counter","s","undefined","verifiedCounter","verify","multisigAddress"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\multisig.ts"],"sourcesContent":["import * as nacl from './nacl/naclWrappers.js';\nimport {\n  Address,\n  ALGORAND_ADDRESS_BYTE_LENGTH,\n  ALGORAND_CHECKSUM_BYTE_LENGTH,\n} from './encoding/address.js';\nimport * as utils from './utils/utils.js';\nimport { EncodedMultisig } from './types/transactions/encoded.js';\n\n/**\n Utilities for manipulating multisig transaction blobs.\n */\n\n/**\n * Required options for creating a multisignature\n *\n * Documentation available at: https://developer.algorand.org/docs/get-details/transactions/signatures/#multisignatures\n */\nexport interface MultisigMetadata {\n  /**\n   * Multisig version\n   */\n  version: number;\n\n  /**\n   * Multisig threshold value. Authorization requires a subset of signatures,\n   * equal to or greater than the threshold value.\n   */\n  threshold: number;\n\n  /**\n   * A list of Algorand addresses representing possible signers for this multisig. Order is important.\n   */\n  addrs: Array<string | Address>;\n}\n\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([\n  77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114,\n]);\n\nconst INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nconst INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nconst INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nconst UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n\nexport function pksFromAddresses(addrs: Array<string | Address>): Uint8Array[] {\n  return addrs.map((addr) => {\n    if (typeof addr === 'string') {\n      return Address.fromString(addr).publicKey;\n    }\n    return addr.publicKey;\n  });\n}\n\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - array of typed array public keys\n */\nexport function addressFromMultisigPreImg({\n  version,\n  threshold,\n  pks,\n}: Omit<MultisigMetadata, 'addrs'> & {\n  pks: Uint8Array[];\n}): Address {\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (\n    threshold === 0 ||\n    pks.length === 0 ||\n    threshold > pks.length ||\n    threshold > 255\n  ) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(\n    MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length\n  );\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Address(Uint8Array.from(nacl.genericHash(merged)));\n}\n\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - array of encoded addresses\n */\nexport function addressFromMultisigPreImgAddrs({\n  version,\n  threshold,\n  addrs,\n}: MultisigMetadata): Address {\n  const pks = pksFromAddresses(addrs);\n  return addressFromMultisigPreImg({ version, threshold, pks });\n}\n\nexport function verifyMultisig(\n  toBeVerified: Uint8Array,\n  msig: EncodedMultisig,\n  publicKey: Uint8Array\n) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n\n  const pks = subsigs.map((subsig) => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n\n  let pk: Uint8Array;\n  try {\n    pk = addressFromMultisigPreImg({ version, threshold, pks }).publicKey;\n  } catch (e) {\n    return false;\n  }\n\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress({\n  version,\n  threshold,\n  addrs,\n}: MultisigMetadata): Address {\n  return addressFromMultisigPreImgAddrs({ version, threshold, addrs });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}