{"ast":null,"code":"/**\n * This file is a wrapper of msgpack.js.\n * The wrapper was written in order to ensure correct encoding of Algorand Transaction and other formats.\n * In particular, it matches go-algorand blockchain client, written in go (https://www.github.com/algorand/go-algorand.\n * Algorand's msgpack encoding follows to following rules -\n *  1. Every integer must be encoded to the smallest type possible (0-255-\\>8bit, 256-65535-\\>16bit, etx)\n *  2. All fields names must be sorted\n *  3. All empty and 0 fields should be omitted\n *  4. Every positive number must be encoded as uint\n *  5. Binary blob should be used for binary data and string for strings\n *  */\nimport { encode as msgpackEncode, decode as msgpackDecode, IntMode, RawBinaryString } from 'algorand-msgpack';\nimport { bytesToBase64, coerceToBytes } from './binarydata.js';\nimport IntDecoding from '../types/intDecoding.js';\nimport { stringifyJSON, parseJSON, arrayEqual } from '../utils/utils.js';\n// Errors\nexport const ERROR_CONTAINS_EMPTY_STRING = 'The object contains empty or 0 values. First empty or 0 value encountered during encoding: ';\n/**\n * containsEmpty returns true if any of the object's values are empty, false otherwise.\n * Empty arrays considered empty\n * @param obj - The object to check\n * @returns \\{true, empty key\\} if contains empty, \\{false, undefined\\} otherwise\n */\nfunction containsEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (!obj[key] || obj[key].length === 0) {\n        return {\n          containsEmpty: true,\n          firstEmptyKey: key\n        };\n      }\n    }\n  }\n  return {\n    containsEmpty: false,\n    firstEmptyKey: undefined\n  };\n}\n/**\n * msgpackRawEncode encodes objects using msgpack, regardless of whether there are\n * empty or 0 value fields.\n * @param obj - a dictionary to be encoded. May or may not contain empty or 0 values.\n * @returns msgpack representation of the object\n */\nexport function msgpackRawEncode(obj) {\n  // enable the canonical option\n  const options = {\n    sortKeys: true\n  };\n  return msgpackEncode(obj, options);\n}\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o - js object to be encoded. Must not contain empty or 0 values.\n * @returns Uint8Array binary representation\n * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values\n *\n * @deprecated Use {@link msgpackRawEncode} instead. Note that function does not\n *   check for empty values like this one does.\n */\nexport function encodeObj(obj) {\n  // Check for empty values\n  const emptyCheck = containsEmpty(obj);\n  if (emptyCheck.containsEmpty) {\n    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);\n  }\n  return msgpackRawEncode(obj);\n}\nfunction intDecodingToIntMode(intDecoding) {\n  switch (intDecoding) {\n    case IntDecoding.UNSAFE:\n      return IntMode.UNSAFE_NUMBER;\n    case IntDecoding.SAFE:\n      return IntMode.SAFE_NUMBER;\n    case IntDecoding.MIXED:\n      return IntMode.MIXED;\n    case IntDecoding.BIGINT:\n      return IntMode.BIGINT;\n    default:\n      throw new Error(`Invalid intDecoding: ${intDecoding}`);\n  }\n}\n/**\n * Decodes msgpack bytes into a plain JavaScript object.\n * @param buffer - The msgpack bytes to decode\n * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.\n * @returns The decoded object\n */\nexport function msgpackRawDecode(buffer, options) {\n  const decoderOptions = {\n    intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT\n  };\n  return msgpackDecode(buffer, decoderOptions);\n}\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o - Uint8Array to decode\n * @returns object\n *\n * @deprecated Use {@link msgpackRawDecode} instead. Note that this function uses `IntDecoding.MIXED`\n *   while `msgpackRawDecode` defaults to `IntDecoding.BIGINT` for int decoding, though it is\n *   configurable.\n */\nexport function decodeObj(o) {\n  return msgpackRawDecode(o, {\n    intDecoding: IntDecoding.MIXED\n  });\n}\n/**\n * Decodes msgpack bytes into a Map object. This supports decoding non-string map keys.\n * @param encoded - The msgpack bytes to decode\n * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.\n * @returns The decoded Map object\n */\nexport function msgpackRawDecodeAsMap(encoded, options) {\n  const decoderOptions = {\n    intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT,\n    useMap: true\n  };\n  return msgpackDecode(encoded, decoderOptions);\n}\nfunction msgpackRawDecodeAsMapWithRawStrings(encoded, options) {\n  const decoderOptions = {\n    intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT,\n    useMap: true,\n    rawBinaryStringKeys: true,\n    rawBinaryStringValues: true,\n    useRawBinaryStringClass: true\n  };\n  return msgpackDecode(encoded, decoderOptions);\n}\nexport function msgpackEncodingDataToJSONEncodingData(e) {\n  if (e === null || e === undefined) {\n    return e;\n  }\n  if (e instanceof Uint8Array) {\n    return bytesToBase64(e);\n  }\n  if (Array.isArray(e)) {\n    return e.map(msgpackEncodingDataToJSONEncodingData);\n  }\n  if (e instanceof Map) {\n    const obj = {};\n    for (const [k, v] of e) {\n      if (typeof k !== 'string') {\n        throw new Error(`JSON map key must be a string: ${k}`);\n      }\n      obj[k] = msgpackEncodingDataToJSONEncodingData(v);\n    }\n    return obj;\n  }\n  return e;\n}\nexport function jsonEncodingDataToMsgpackEncodingData(e) {\n  if (e === null || e === undefined) {\n    return e;\n  }\n  if (typeof e === 'string' ||\n  // Note, this will not convert base64 to Uint8Array\n  typeof e === 'number' || typeof e === 'bigint' || typeof e === 'boolean') {\n    return e;\n  }\n  if (Array.isArray(e)) {\n    return e.map(jsonEncodingDataToMsgpackEncodingData);\n  }\n  if (typeof e === 'object') {\n    const obj = new Map();\n    for (const [key, value] of Object.entries(e)) {\n      obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));\n    }\n    return obj;\n  }\n  throw new Error(`Invalid JSON encoding data: ${e}`);\n}\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-useless-constructor,no-empty-function */\nvar MsgpackObjectPathSegmentKind;\n(function (MsgpackObjectPathSegmentKind) {\n  MsgpackObjectPathSegmentKind[MsgpackObjectPathSegmentKind[\"MAP_VALUE\"] = 0] = \"MAP_VALUE\";\n  MsgpackObjectPathSegmentKind[MsgpackObjectPathSegmentKind[\"ARRAY_ELEMENT\"] = 1] = \"ARRAY_ELEMENT\";\n})(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));\n/**\n * This class is used to index into an encoded msgpack object and extract raw strings.\n */\nexport class MsgpackRawStringProvider {\n  constructor({\n    parent,\n    segment,\n    baseObjectBytes\n  }) {\n    this.resolvedCache = null;\n    this.resolvedCachePresent = false;\n    this.parent = parent;\n    this.segment = segment;\n    this.baseObjectBytes = baseObjectBytes;\n  }\n  /**\n   * Create a new provider that resolves to the current provider's map value at the given key.\n   */\n  withMapValue(key) {\n    return new MsgpackRawStringProvider({\n      parent: this,\n      segment: {\n        kind: MsgpackObjectPathSegmentKind.MAP_VALUE,\n        key\n      }\n    });\n  }\n  /**\n   * Create a new provider that resolves to the current provider's array element at the given index.\n   */\n  withArrayElement(index) {\n    return new MsgpackRawStringProvider({\n      parent: this,\n      segment: {\n        kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,\n        key: index\n      }\n    });\n  }\n  /**\n   * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.\n   */\n  getRawStringAtCurrentLocation() {\n    const resolved = this.resolve();\n    if (resolved instanceof RawBinaryString) {\n      // Decoded rawBinaryValue will always be a Uint8Array\n      return resolved.rawBinaryValue;\n    }\n    throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);\n  }\n  /**\n   * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.\n   */\n  getRawStringKeysAndValuesAtCurrentLocation() {\n    const resolved = this.resolve();\n    if (!(resolved instanceof Map)) {\n      throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);\n    }\n    const keysAndValues = new Map();\n    for (const [key, value] of resolved) {\n      if (key instanceof RawBinaryString) {\n        // Decoded rawBinaryValue will always be a Uint8Array\n        keysAndValues.set(key.rawBinaryValue, value);\n      } else {\n        throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);\n      }\n    }\n    return keysAndValues;\n  }\n  /**\n   * Resolve the provider by extracting the value it indicates from the base msgpack object.\n   */\n  resolve() {\n    if (this.resolvedCachePresent) {\n      return this.resolvedCache;\n    }\n    let parentResolved;\n    if (this.parent) {\n      parentResolved = this.parent.resolve();\n    } else {\n      // Need to parse baseObjectBytes\n      parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);\n    }\n    if (!this.segment) {\n      this.resolvedCache = parentResolved;\n      this.resolvedCachePresent = true;\n      return parentResolved;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {\n      if (!(parentResolved instanceof Map)) {\n        throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);\n      }\n      // All decoded map keys will be raw strings, and Map objects compare complex values by reference,\n      // so we must check all the values for value-equality.\n      if (typeof this.segment.key === 'string' || this.segment.key instanceof Uint8Array || this.segment.key instanceof RawBinaryString) {\n        const targetBytes = this.segment.key instanceof RawBinaryString ?\n        // Decoded rawBinaryValue will always be a Uint8Array\n        this.segment.key.rawBinaryValue : coerceToBytes(this.segment.key);\n        const targetIsRawString = typeof this.segment.key === 'string' || this.segment.key instanceof RawBinaryString;\n        for (const [key, value] of parentResolved) {\n          let potentialKeyBytes;\n          if (targetIsRawString) {\n            if (key instanceof RawBinaryString) {\n              // Decoded rawBinaryValue will always be a Uint8Array\n              potentialKeyBytes = key.rawBinaryValue;\n            }\n          } else if (key instanceof Uint8Array) {\n            potentialKeyBytes = key;\n          }\n          if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {\n            this.resolvedCache = value;\n            break;\n          }\n        }\n      } else {\n        this.resolvedCache = parentResolved.get(this.segment.key);\n      }\n      this.resolvedCachePresent = true;\n      return this.resolvedCache;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {\n      if (!Array.isArray(parentResolved)) {\n        throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);\n      }\n      this.resolvedCache = parentResolved[this.segment.key];\n      this.resolvedCachePresent = true;\n      return this.resolvedCache;\n    }\n    throw new Error(`Invalid segment kind: ${this.segment.kind}`);\n  }\n  /**\n   * Get the path string of the current location indicated by the provider. Useful for debugging.\n   */\n  getPathString() {\n    const parentPathString = this.parent ? this.parent.getPathString() : 'root';\n    if (!this.segment) {\n      return parentPathString;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {\n      return `${parentPathString} -> map key \"${this.segment.key}\" (${typeof this.segment.key})`;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {\n      return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;\n    }\n    return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;\n  }\n}\n/**\n * A Schema is used to prepare objects for encoding and decoding from msgpack and JSON.\n *\n * Schemas represent a specific type.\n */\nexport class Schema {}\n/**\n * Decode a msgpack byte array to an Encodable object.\n * @param encoded - The msgpack bytes to decode\n * @param c - The class of the object to decode. This class must match the object that was encoded.\n * @returns An instance of the class with the decoded data\n */\nexport function decodeMsgpack(encoded, c) {\n  const decoded = msgpackRawDecodeAsMap(encoded);\n  const rawStringProvider = new MsgpackRawStringProvider({\n    baseObjectBytes: encoded\n  });\n  return c.fromEncodingData(c.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));\n}\n/**\n * Encode an Encodable object to a msgpack byte array.\n * @param e - The object to encode\n * @returns A msgpack byte array encoding of the object\n */\nexport function encodeMsgpack(e) {\n  return msgpackRawEncode(e.getEncodingSchema().prepareMsgpack(e.toEncodingData()));\n}\n/**\n * Decode a JSON string to an Encodable object.\n * @param encoded - The JSON string to decode\n * @param c - The class of the object to decode. This class must match the object that was encoded.\n * @returns An instance of the class with the decoded data\n */\nexport function decodeJSON(encoded, c) {\n  const decoded = parseJSON(encoded, {\n    intDecoding: IntDecoding.BIGINT\n  });\n  return c.fromEncodingData(c.encodingSchema.fromPreparedJSON(decoded));\n}\n/**\n * Encode an Encodable object to a JSON string.\n * @param e - The object to encode\n * @param options - Optional encoding options. See {@link EncodeJSONOptions} for more information.\n * @returns A JSON string encoding of the object\n */\nexport function encodeJSON(e, options) {\n  const {\n    space,\n    ...prepareJSONOptions\n  } = options ?? {};\n  const prepared = e.getEncodingSchema().prepareJSON(e.toEncodingData(), prepareJSONOptions);\n  return stringifyJSON(prepared, undefined, space);\n}","map":{"version":3,"names":["encode","msgpackEncode","decode","msgpackDecode","IntMode","RawBinaryString","bytesToBase64","coerceToBytes","IntDecoding","stringifyJSON","parseJSON","arrayEqual","ERROR_CONTAINS_EMPTY_STRING","containsEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","firstEmptyKey","undefined","msgpackRawEncode","options","sortKeys","encodeObj","emptyCheck","Error","intDecodingToIntMode","intDecoding","UNSAFE","UNSAFE_NUMBER","SAFE","SAFE_NUMBER","MIXED","BIGINT","msgpackRawDecode","buffer","decoderOptions","intMode","decodeObj","o","msgpackRawDecodeAsMap","encoded","useMap","msgpackRawDecodeAsMapWithRawStrings","rawBinaryStringKeys","rawBinaryStringValues","useRawBinaryStringClass","msgpackEncodingDataToJSONEncodingData","e","Uint8Array","Array","isArray","map","Map","k","v","jsonEncodingDataToMsgpackEncodingData","value","entries","set","MsgpackObjectPathSegmentKind","MsgpackRawStringProvider","constructor","parent","segment","baseObjectBytes","resolvedCache","resolvedCachePresent","withMapValue","kind","MAP_VALUE","withArrayElement","index","ARRAY_ELEMENT","getRawStringAtCurrentLocation","resolved","resolve","rawBinaryValue","getRawStringKeysAndValuesAtCurrentLocation","keysAndValues","parentResolved","targetBytes","targetIsRawString","potentialKeyBytes","get","getPathString","parentPathString","Schema","decodeMsgpack","c","decoded","rawStringProvider","fromEncodingData","encodingSchema","fromPreparedMsgpack","encodeMsgpack","getEncodingSchema","prepareMsgpack","toEncodingData","decodeJSON","fromPreparedJSON","encodeJSON","space","prepareJSONOptions","prepared","prepareJSON"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\encoding\\encoding.ts"],"sourcesContent":["/**\n * This file is a wrapper of msgpack.js.\n * The wrapper was written in order to ensure correct encoding of Algorand Transaction and other formats.\n * In particular, it matches go-algorand blockchain client, written in go (https://www.github.com/algorand/go-algorand.\n * Algorand's msgpack encoding follows to following rules -\n *  1. Every integer must be encoded to the smallest type possible (0-255-\\>8bit, 256-65535-\\>16bit, etx)\n *  2. All fields names must be sorted\n *  3. All empty and 0 fields should be omitted\n *  4. Every positive number must be encoded as uint\n *  5. Binary blob should be used for binary data and string for strings\n *  */\n\nimport {\n  encode as msgpackEncode,\n  EncoderOptions,\n  decode as msgpackDecode,\n  DecoderOptions,\n  IntMode,\n  RawBinaryString,\n} from 'algorand-msgpack';\nimport { bytesToBase64, coerceToBytes } from './binarydata.js';\nimport IntDecoding from '../types/intDecoding.js';\nimport { stringifyJSON, parseJSON, arrayEqual } from '../utils/utils.js';\n\n// Errors\nexport const ERROR_CONTAINS_EMPTY_STRING =\n  'The object contains empty or 0 values. First empty or 0 value encountered during encoding: ';\n\n/**\n * containsEmpty returns true if any of the object's values are empty, false otherwise.\n * Empty arrays considered empty\n * @param obj - The object to check\n * @returns \\{true, empty key\\} if contains empty, \\{false, undefined\\} otherwise\n */\nfunction containsEmpty(obj: Record<string | number | symbol, any>) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      if (!obj[key] || obj[key].length === 0) {\n        return { containsEmpty: true, firstEmptyKey: key };\n      }\n    }\n  }\n  return { containsEmpty: false, firstEmptyKey: undefined };\n}\n\n/**\n * msgpackRawEncode encodes objects using msgpack, regardless of whether there are\n * empty or 0 value fields.\n * @param obj - a dictionary to be encoded. May or may not contain empty or 0 values.\n * @returns msgpack representation of the object\n */\nexport function msgpackRawEncode(obj: unknown) {\n  // enable the canonical option\n  const options: EncoderOptions = { sortKeys: true };\n  return msgpackEncode(obj, options);\n}\n\n/**\n * encodeObj takes a javascript object and returns its msgpack encoding\n * Note that the encoding sorts the fields alphabetically\n * @param o - js object to be encoded. Must not contain empty or 0 values.\n * @returns Uint8Array binary representation\n * @throws Error containing ERROR_CONTAINS_EMPTY_STRING if the object contains empty or zero values\n *\n * @deprecated Use {@link msgpackRawEncode} instead. Note that function does not\n *   check for empty values like this one does.\n */\nexport function encodeObj(obj: Record<string | number | symbol, any>) {\n  // Check for empty values\n  const emptyCheck = containsEmpty(obj);\n  if (emptyCheck.containsEmpty) {\n    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);\n  }\n  return msgpackRawEncode(obj);\n}\n\nfunction intDecodingToIntMode(intDecoding: IntDecoding): IntMode {\n  switch (intDecoding) {\n    case IntDecoding.UNSAFE:\n      return IntMode.UNSAFE_NUMBER;\n    case IntDecoding.SAFE:\n      return IntMode.SAFE_NUMBER;\n    case IntDecoding.MIXED:\n      return IntMode.MIXED;\n    case IntDecoding.BIGINT:\n      return IntMode.BIGINT;\n    default:\n      throw new Error(`Invalid intDecoding: ${intDecoding}`);\n  }\n}\n\n/**\n * Decodes msgpack bytes into a plain JavaScript object.\n * @param buffer - The msgpack bytes to decode\n * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.\n * @returns The decoded object\n */\nexport function msgpackRawDecode(\n  buffer: ArrayLike<number>,\n  options?: { intDecoding: IntDecoding }\n) {\n  const decoderOptions: DecoderOptions = {\n    intMode: options?.intDecoding\n      ? intDecodingToIntMode(options?.intDecoding)\n      : IntMode.BIGINT,\n  };\n  return msgpackDecode(buffer, decoderOptions);\n}\n\n/**\n * decodeObj takes a Uint8Array and returns its javascript obj\n * @param o - Uint8Array to decode\n * @returns object\n *\n * @deprecated Use {@link msgpackRawDecode} instead. Note that this function uses `IntDecoding.MIXED`\n *   while `msgpackRawDecode` defaults to `IntDecoding.BIGINT` for int decoding, though it is\n *   configurable.\n */\nexport function decodeObj(o: ArrayLike<number>) {\n  return msgpackRawDecode(o, { intDecoding: IntDecoding.MIXED });\n}\n\n/**\n * Decodes msgpack bytes into a Map object. This supports decoding non-string map keys.\n * @param encoded - The msgpack bytes to decode\n * @param options - Options for decoding, including int decoding mode. See {@link IntDecoding} for more information.\n * @returns The decoded Map object\n */\nexport function msgpackRawDecodeAsMap(\n  encoded: ArrayLike<number>,\n  options?: { intDecoding: IntDecoding }\n) {\n  const decoderOptions: DecoderOptions = {\n    intMode: options?.intDecoding\n      ? intDecodingToIntMode(options?.intDecoding)\n      : IntMode.BIGINT,\n    useMap: true,\n  };\n  return msgpackDecode(encoded, decoderOptions);\n}\n\nfunction msgpackRawDecodeAsMapWithRawStrings(\n  encoded: ArrayLike<number>,\n  options?: { intDecoding: IntDecoding }\n) {\n  const decoderOptions: DecoderOptions = {\n    intMode: options?.intDecoding\n      ? intDecodingToIntMode(options?.intDecoding)\n      : IntMode.BIGINT,\n    useMap: true,\n    rawBinaryStringKeys: true,\n    rawBinaryStringValues: true,\n    useRawBinaryStringClass: true,\n  };\n  return msgpackDecode(encoded, decoderOptions);\n}\n\nexport type MsgpackEncodingData =\n  | null\n  | undefined\n  | string\n  | number\n  | bigint\n  | boolean\n  | Uint8Array\n  | MsgpackEncodingData[]\n  | Map<string | number | bigint | Uint8Array, MsgpackEncodingData>;\n\nexport type JSONEncodingData =\n  | null\n  | undefined\n  | string\n  | number\n  | bigint\n  | boolean\n  | JSONEncodingData[]\n  | { [key: string]: JSONEncodingData };\n\nexport function msgpackEncodingDataToJSONEncodingData(\n  e: MsgpackEncodingData\n): JSONEncodingData {\n  if (e === null || e === undefined) {\n    return e;\n  }\n  if (e instanceof Uint8Array) {\n    return bytesToBase64(e);\n  }\n  if (Array.isArray(e)) {\n    return e.map(msgpackEncodingDataToJSONEncodingData);\n  }\n  if (e instanceof Map) {\n    const obj: { [key: string]: JSONEncodingData } = {};\n    for (const [k, v] of e) {\n      if (typeof k !== 'string') {\n        throw new Error(`JSON map key must be a string: ${k}`);\n      }\n      obj[k] = msgpackEncodingDataToJSONEncodingData(v);\n    }\n    return obj;\n  }\n  return e;\n}\n\nexport function jsonEncodingDataToMsgpackEncodingData(\n  e: JSONEncodingData\n): MsgpackEncodingData {\n  if (e === null || e === undefined) {\n    return e;\n  }\n  if (\n    typeof e === 'string' || // Note, this will not convert base64 to Uint8Array\n    typeof e === 'number' ||\n    typeof e === 'bigint' ||\n    typeof e === 'boolean'\n  ) {\n    return e;\n  }\n  if (Array.isArray(e)) {\n    return e.map(jsonEncodingDataToMsgpackEncodingData);\n  }\n  if (typeof e === 'object') {\n    const obj = new Map<string, MsgpackEncodingData>();\n    for (const [key, value] of Object.entries(e)) {\n      obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));\n    }\n    return obj;\n  }\n  throw new Error(`Invalid JSON encoding data: ${e}`);\n}\n\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-useless-constructor,no-empty-function */\n\nenum MsgpackObjectPathSegmentKind {\n  MAP_VALUE,\n  ARRAY_ELEMENT,\n}\n\ninterface MsgpackObjectPathSegment {\n  kind: MsgpackObjectPathSegmentKind;\n  key: string | number | bigint | Uint8Array | RawBinaryString;\n}\n\n/**\n * This class is used to index into an encoded msgpack object and extract raw strings.\n */\nexport class MsgpackRawStringProvider {\n  // eslint-disable-next-line no-use-before-define\n  private readonly parent?: MsgpackRawStringProvider;\n\n  private readonly baseObjectBytes?: ArrayLike<number>;\n\n  private readonly segment?: MsgpackObjectPathSegment;\n\n  private resolvedCache: MsgpackEncodingData = null;\n  private resolvedCachePresent = false;\n\n  public constructor({\n    parent,\n    segment,\n    baseObjectBytes,\n  }:\n    | {\n        parent: MsgpackRawStringProvider;\n        segment: MsgpackObjectPathSegment;\n        baseObjectBytes?: undefined;\n      }\n    | {\n        parent?: undefined;\n        segment?: undefined;\n        baseObjectBytes: ArrayLike<number>;\n      }) {\n    this.parent = parent;\n    this.segment = segment;\n    this.baseObjectBytes = baseObjectBytes;\n  }\n\n  /**\n   * Create a new provider that resolves to the current provider's map value at the given key.\n   */\n  public withMapValue(\n    key: string | number | bigint | Uint8Array | RawBinaryString\n  ): MsgpackRawStringProvider {\n    return new MsgpackRawStringProvider({\n      parent: this,\n      segment: {\n        kind: MsgpackObjectPathSegmentKind.MAP_VALUE,\n        key,\n      },\n    });\n  }\n\n  /**\n   * Create a new provider that resolves to the current provider's array element at the given index.\n   */\n  public withArrayElement(index: number): MsgpackRawStringProvider {\n    return new MsgpackRawStringProvider({\n      parent: this,\n      segment: {\n        kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,\n        key: index,\n      },\n    });\n  }\n\n  /**\n   * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.\n   */\n  public getRawStringAtCurrentLocation(): Uint8Array {\n    const resolved = this.resolve();\n    if (resolved instanceof RawBinaryString) {\n      // Decoded rawBinaryValue will always be a Uint8Array\n      return resolved.rawBinaryValue as Uint8Array;\n    }\n    throw new Error(\n      `Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`\n    );\n  }\n\n  /**\n   * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.\n   */\n  public getRawStringKeysAndValuesAtCurrentLocation(): Map<\n    Uint8Array,\n    MsgpackEncodingData\n  > {\n    const resolved = this.resolve();\n    if (!(resolved instanceof Map)) {\n      throw new Error(\n        `Invalid type. Expected Map, got ${resolved} (${typeof resolved})`\n      );\n    }\n    const keysAndValues = new Map<Uint8Array, MsgpackEncodingData>();\n    for (const [key, value] of resolved) {\n      if (key instanceof RawBinaryString) {\n        // Decoded rawBinaryValue will always be a Uint8Array\n        keysAndValues.set(key.rawBinaryValue as Uint8Array, value);\n      } else {\n        throw new Error(\n          `Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`\n        );\n      }\n    }\n    return keysAndValues;\n  }\n\n  /**\n   * Resolve the provider by extracting the value it indicates from the base msgpack object.\n   */\n  private resolve(): MsgpackEncodingData {\n    if (this.resolvedCachePresent) {\n      return this.resolvedCache;\n    }\n    let parentResolved: MsgpackEncodingData;\n    if (this.parent) {\n      parentResolved = this.parent.resolve();\n    } else {\n      // Need to parse baseObjectBytes\n      parentResolved = msgpackRawDecodeAsMapWithRawStrings(\n        this.baseObjectBytes!\n      ) as MsgpackEncodingData;\n    }\n    if (!this.segment) {\n      this.resolvedCache = parentResolved;\n      this.resolvedCachePresent = true;\n      return parentResolved;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {\n      if (!(parentResolved instanceof Map)) {\n        throw new Error(\n          `Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`\n        );\n      }\n      // All decoded map keys will be raw strings, and Map objects compare complex values by reference,\n      // so we must check all the values for value-equality.\n      if (\n        typeof this.segment.key === 'string' ||\n        this.segment.key instanceof Uint8Array ||\n        this.segment.key instanceof RawBinaryString\n      ) {\n        const targetBytes =\n          this.segment.key instanceof RawBinaryString\n            ? // Decoded rawBinaryValue will always be a Uint8Array\n              (this.segment.key.rawBinaryValue as Uint8Array)\n            : coerceToBytes(this.segment.key);\n        const targetIsRawString =\n          typeof this.segment.key === 'string' ||\n          this.segment.key instanceof RawBinaryString;\n        for (const [key, value] of parentResolved) {\n          let potentialKeyBytes: Uint8Array | undefined;\n          if (targetIsRawString) {\n            if (key instanceof RawBinaryString) {\n              // Decoded rawBinaryValue will always be a Uint8Array\n              potentialKeyBytes = key.rawBinaryValue as Uint8Array;\n            }\n          } else if (key instanceof Uint8Array) {\n            potentialKeyBytes = key;\n          }\n          if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {\n            this.resolvedCache = value;\n            break;\n          }\n        }\n      } else {\n        this.resolvedCache = parentResolved.get(this.segment.key);\n      }\n      this.resolvedCachePresent = true;\n      return this.resolvedCache;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {\n      if (!Array.isArray(parentResolved)) {\n        throw new Error(\n          `Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`\n        );\n      }\n      this.resolvedCache = parentResolved[this.segment.key as number];\n      this.resolvedCachePresent = true;\n      return this.resolvedCache;\n    }\n    throw new Error(`Invalid segment kind: ${this.segment.kind}`);\n  }\n\n  /**\n   * Get the path string of the current location indicated by the provider. Useful for debugging.\n   */\n  public getPathString(): string {\n    const parentPathString = this.parent ? this.parent.getPathString() : 'root';\n    if (!this.segment) {\n      return parentPathString;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {\n      return `${parentPathString} -> map key \"${this.segment.key}\" (${typeof this.segment.key})`;\n    }\n    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {\n      return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;\n    }\n    return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;\n  }\n}\n\n/**\n * Options for {@link Schema.prepareJSON}\n */\nexport interface PrepareJSONOptions {\n  /**\n   * If true, allows invalid UTF-8 binary strings to be converted to JSON strings.\n   *\n   * Otherwise, an error will be thrown if encoding a binary string to a JSON cannot be done losslessly.\n   */\n  lossyBinaryStringConversion?: boolean;\n}\n\n/**\n * A Schema is used to prepare objects for encoding and decoding from msgpack and JSON.\n *\n * Schemas represent a specific type.\n */\nexport abstract class Schema {\n  /**\n   * Get the default value for this type.\n   */\n  public abstract defaultValue(): unknown;\n\n  /**\n   * Checks if the value is the default value for this type.\n   * @param data - The value to check\n   * @returns True if the value is the default value, false otherwise\n   */\n  public abstract isDefaultValue(data: unknown): boolean;\n\n  /**\n   * Prepares the encoding data for encoding to msgpack.\n   * @param data - Encoding data to be prepared.\n   * @returns A value ready to be msgpack encoded.\n   */\n  public abstract prepareMsgpack(data: unknown): MsgpackEncodingData;\n\n  /**\n   * Restores the encoding data from a msgpack encoding object.\n   * @param encoded - The msgpack encoding object to restore.\n   * @param rawStringProvider - A provider for raw strings.\n   * @returns The original encoding data.\n   */\n  public abstract fromPreparedMsgpack(\n    encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): unknown;\n\n  /**\n   * Prepares the encoding data for encoding to JSON.\n   * @param data - The JSON encoding data to be prepared.\n   * @returns A value ready to be JSON encoded.\n   */\n  public abstract prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData;\n\n  /**\n   * Restores the encoding data from a JSON encoding object.\n   * @param encoded - The JSON encoding object to restore.\n   * @returns The original encoding data.\n   */\n  public abstract fromPreparedJSON(encoded: JSONEncodingData): unknown;\n}\n\n/**\n * An interface for objects that can be encoded and decoded to/from msgpack and JSON.\n */\nexport interface Encodable {\n  /**\n   * Extract the encoding data for this object. This data, after being prepared by the encoding\n   * Schema, can be encoded to msgpack or JSON.\n   */\n  toEncodingData(): unknown;\n  /**\n   * Get the encoding Schema for this object, used to prepare the encoding data for msgpack and JSON.\n   */\n  getEncodingSchema(): Schema;\n}\n\n/**\n * A type that represents the class of an Encodable object.\n */\nexport interface EncodableClass<T extends Encodable> {\n  /**\n   * Create a new instance of this class from the given encoding data.\n   * @param data - The encoding data to create the object from\n   */\n  fromEncodingData(data: unknown): T;\n  /**\n   * The encoding Schema for this class, used to prepare encoding data from msgpack and JSON.\n   */\n  readonly encodingSchema: Schema;\n}\n\n/**\n * Decode a msgpack byte array to an Encodable object.\n * @param encoded - The msgpack bytes to decode\n * @param c - The class of the object to decode. This class must match the object that was encoded.\n * @returns An instance of the class with the decoded data\n */\nexport function decodeMsgpack<T extends Encodable>(\n  encoded: ArrayLike<number>,\n  c: EncodableClass<T>\n): T {\n  const decoded = msgpackRawDecodeAsMap(encoded) as MsgpackEncodingData;\n  const rawStringProvider = new MsgpackRawStringProvider({\n    baseObjectBytes: encoded,\n  });\n  return c.fromEncodingData(\n    c.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider)\n  );\n}\n\n/**\n * Encode an Encodable object to a msgpack byte array.\n * @param e - The object to encode\n * @returns A msgpack byte array encoding of the object\n */\nexport function encodeMsgpack(e: Encodable): Uint8Array {\n  return msgpackRawEncode(\n    e.getEncodingSchema().prepareMsgpack(e.toEncodingData())\n  );\n}\n\n/**\n * Decode a JSON string to an Encodable object.\n * @param encoded - The JSON string to decode\n * @param c - The class of the object to decode. This class must match the object that was encoded.\n * @returns An instance of the class with the decoded data\n */\nexport function decodeJSON<T extends Encodable>(\n  encoded: string,\n  c: EncodableClass<T>\n): T {\n  const decoded: JSONEncodingData = parseJSON(encoded, {\n    intDecoding: IntDecoding.BIGINT,\n  });\n  return c.fromEncodingData(\n    c.encodingSchema.fromPreparedJSON(decoded) as JSONEncodingData\n  );\n}\n\nexport interface EncodeJSONOptions {\n  /**\n   * Adds indentation, white space, and line break characters to the return-value JSON text to make\n   * it easier to read.\n   */\n  space?: string | number;\n\n  /**\n   * If true, allows invalid UTF-8 binary strings to be converted to JSON strings.\n   *\n   * Otherwise, an error will be thrown if encoding a binary string to a JSON cannot be done losslessly.\n   */\n  lossyBinaryStringConversion?: boolean;\n}\n\n/**\n * Encode an Encodable object to a JSON string.\n * @param e - The object to encode\n * @param options - Optional encoding options. See {@link EncodeJSONOptions} for more information.\n * @returns A JSON string encoding of the object\n */\nexport function encodeJSON(e: Encodable, options?: EncodeJSONOptions): string {\n  const { space, ...prepareJSONOptions } = options ?? {};\n  const prepared = e\n    .getEncodingSchema()\n    .prepareJSON(e.toEncodingData(), prepareJSONOptions);\n  return stringifyJSON(prepared, undefined, space);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}