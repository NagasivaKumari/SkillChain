{"ast":null,"code":"/**\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\n * @param bi - The bigint to convert.\n * @param size - The size of the resulting byte array.\n * @returns A byte array containing the big-endian encoding of the input bigint\n */\nexport function bigIntToBytes(bi, size) {\n  let hex = bi.toString(16);\n  // Pad the hex with zeros so it matches the size in bytes\n  if (hex.length !== size * 2) {\n    hex = hex.padStart(size * 2, '0');\n  }\n  const byteArray = new Uint8Array(hex.length / 2);\n  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return byteArray;\n}\n/**\n * bytesToBigInt produces a bigint from a binary representation.\n *\n * @param bytes - The Uint8Array to convert.\n * @returns The bigint that was encoded in the input data.\n */\nexport function bytesToBigInt(bytes) {\n  let res = BigInt(0);\n  const buf = new DataView(bytes.buffer, bytes.byteOffset);\n  for (let i = 0; i < bytes.length; i++) {\n    res = BigInt(Number(buf.getUint8(i))) + res * BigInt(256);\n  }\n  return res;\n}","map":{"version":3,"names":["bigIntToBytes","bi","size","hex","toString","length","padStart","byteArray","Uint8Array","i","j","parseInt","slice","bytesToBigInt","bytes","res","BigInt","buf","DataView","buffer","byteOffset","Number","getUint8"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\encoding\\bigint.ts"],"sourcesContent":["/**\n * bigIntToBytes converts a BigInt to a big-endian Uint8Array for encoding.\n * @param bi - The bigint to convert.\n * @param size - The size of the resulting byte array.\n * @returns A byte array containing the big-endian encoding of the input bigint\n */\nexport function bigIntToBytes(bi: bigint | number, size: number) {\n  let hex = bi.toString(16);\n  // Pad the hex with zeros so it matches the size in bytes\n  if (hex.length !== size * 2) {\n    hex = hex.padStart(size * 2, '0');\n  }\n  const byteArray = new Uint8Array(hex.length / 2);\n  for (let i = 0, j = 0; i < hex.length / 2; i++, j += 2) {\n    byteArray[i] = parseInt(hex.slice(j, j + 2), 16);\n  }\n  return byteArray;\n}\n\n/**\n * bytesToBigInt produces a bigint from a binary representation.\n *\n * @param bytes - The Uint8Array to convert.\n * @returns The bigint that was encoded in the input data.\n */\nexport function bytesToBigInt(bytes: Uint8Array) {\n  let res = BigInt(0);\n  const buf = new DataView(bytes.buffer, bytes.byteOffset);\n  for (let i = 0; i < bytes.length; i++) {\n    res = BigInt(Number(buf.getUint8(i))) + res * BigInt(256);\n  }\n  return res;\n}\n"],"mappings":"AAAA;;;;;;AAMA,OAAM,SAAUA,aAAaA,CAACC,EAAmB,EAAEC,IAAY;EAC7D,IAAIC,GAAG,GAAGF,EAAE,CAACG,QAAQ,CAAC,EAAE,CAAC;EACzB;EACA,IAAID,GAAG,CAACE,MAAM,KAAKH,IAAI,GAAG,CAAC,EAAE;IAC3BC,GAAG,GAAGA,GAAG,CAACG,QAAQ,CAACJ,IAAI,GAAG,CAAC,EAAE,GAAG,CAAC;EACnC;EACA,MAAMK,SAAS,GAAG,IAAIC,UAAU,CAACL,GAAG,CAACE,MAAM,GAAG,CAAC,CAAC;EAChD,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGN,GAAG,CAACE,MAAM,GAAG,CAAC,EAAEI,CAAC,EAAE,EAAEC,CAAC,IAAI,CAAC,EAAE;IACtDH,SAAS,CAACE,CAAC,CAAC,GAAGE,QAAQ,CAACR,GAAG,CAACS,KAAK,CAACF,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;EAClD;EACA,OAAOH,SAAS;AAClB;AAEA;;;;;;AAMA,OAAM,SAAUM,aAAaA,CAACC,KAAiB;EAC7C,IAAIC,GAAG,GAAGC,MAAM,CAAC,CAAC,CAAC;EACnB,MAAMC,GAAG,GAAG,IAAIC,QAAQ,CAACJ,KAAK,CAACK,MAAM,EAAEL,KAAK,CAACM,UAAU,CAAC;EACxD,KAAK,IAAIX,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGK,KAAK,CAACT,MAAM,EAAEI,CAAC,EAAE,EAAE;IACrCM,GAAG,GAAGC,MAAM,CAACK,MAAM,CAACJ,GAAG,CAACK,QAAQ,CAACb,CAAC,CAAC,CAAC,CAAC,GAAGM,GAAG,GAAGC,MAAM,CAAC,GAAG,CAAC;EAC3D;EACA,OAAOD,GAAG;AACZ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}