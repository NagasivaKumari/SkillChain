{"ast":null,"code":"class URLTokenBaseHTTPError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n *\n * Additional fetch options can be configured by using the `customOptions` parameter on\n * get/post/delete requests.\n */\nexport class URLTokenBaseHTTPClient {\n  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {\n    this.defaultHeaders = defaultHeaders;\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n  /**\n   * Compute the URL for a path relative to the instance's address\n   * @param relativePath - A path string\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\n   *   relativePath already has query parameters on it, the additional parameters defined here will\n   *   be added to the URL without modifying those (unless a key collision occurs).\n   * @returns A URL string\n   */\n  getURL(relativePath, query) {\n    let fixedRelativePath;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value.toString());\n      }\n    }\n    return address.toString();\n  }\n  static formatFetchResponseHeaders(headers) {\n    const headersObj = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n  static async checkHttpError(res) {\n    if (res.ok) {\n      return;\n    }\n    let body;\n    let bodyErrorMessage;\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded = JSON.parse(new TextDecoder().decode(body));\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n    throw new URLTokenBaseHTTPError(message, {\n      body: body ?? new Uint8Array(),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    });\n  }\n  static async formatFetchResponse(res) {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    };\n  }\n  async get(relativePath, query, requestHeaders, customOptions) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {})\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      headers,\n      ...(customOptions ?? {})\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async post(relativePath, data, query, requestHeaders, customOptions) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {})\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      body: data,\n      headers,\n      ...(customOptions ?? {})\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async delete(relativePath, data, query, requestHeaders, customOptions) {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {})\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      body: data,\n      headers,\n      ...(customOptions ?? {})\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}","map":{"version":3,"names":["URLTokenBaseHTTPError","Error","constructor","message","response","name","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","fixedBaseServer","endsWith","baseServerURL","URL","toString","protocol","length","baseURL","getURL","relativePath","query","fixedRelativePath","startsWith","address","key","value","Object","entries","searchParams","set","formatFetchResponseHeaders","headers","headersObj","forEach","checkHttpError","res","ok","body","bodyErrorMessage","Uint8Array","arrayBuffer","decoded","JSON","parse","TextDecoder","decode","_","status","statusText","formatFetchResponse","get","requestHeaders","customOptions","fetch","post","data","method","delete"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\client\\urlTokenBaseHTTPClient.ts"],"sourcesContent":["import {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  BaseHTTPClientError,\n  Query,\n} from './baseHTTPClient.js';\n\nexport interface AlgodTokenHeader {\n  'X-Algo-API-Token': string;\n}\n\nexport interface IndexerTokenHeader {\n  'X-Indexer-API-Token': string;\n}\n\nexport interface KMDTokenHeader {\n  'X-KMD-API-Token': string;\n}\n\nexport interface CustomTokenHeader {\n  [headerName: string]: string;\n}\n\nclass URLTokenBaseHTTPError extends Error implements BaseHTTPClientError {\n  constructor(\n    message: string,\n    public response: BaseHTTPClientResponse\n  ) {\n    super(message);\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n\nexport type TokenHeader =\n  | AlgodTokenHeader\n  | IndexerTokenHeader\n  | KMDTokenHeader\n  | CustomTokenHeader;\n\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n *\n * Additional fetch options can be configured by using the `customOptions` parameter on\n * get/post/delete requests.\n */\nexport class URLTokenBaseHTTPClient implements BaseHTTPClient {\n  private readonly baseURL: URL;\n  private readonly tokenHeader: TokenHeader;\n\n  constructor(\n    tokenHeader: TokenHeader,\n    baseServer: string,\n    port?: string | number,\n    private defaultHeaders: Record<string, any> = {}\n  ) {\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/')\n      ? baseServer\n      : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n\n  /**\n   * Compute the URL for a path relative to the instance's address\n   * @param relativePath - A path string\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\n   *   relativePath already has query parameters on it, the additional parameters defined here will\n   *   be added to the URL without modifying those (unless a key collision occurs).\n   * @returns A URL string\n   */\n  private getURL(relativePath: string, query?: Query<string>): string {\n    let fixedRelativePath: string;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value.toString());\n      }\n    }\n    return address.toString();\n  }\n\n  private static formatFetchResponseHeaders(\n    headers: Headers\n  ): Record<string, string> {\n    const headersObj: Record<string, string> = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n\n  private static async checkHttpError(res: Response) {\n    if (res.ok) {\n      return;\n    }\n\n    let body: Uint8Array | undefined;\n    let bodyErrorMessage: string | undefined;\n\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded: Record<string, any> = JSON.parse(\n        new TextDecoder().decode(body)\n      );\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n\n    throw new URLTokenBaseHTTPError(message, {\n      body: body ?? new Uint8Array(),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n    });\n  }\n\n  private static async formatFetchResponse(\n    res: Response\n  ): Promise<BaseHTTPClientResponse> {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers),\n    };\n  }\n\n  async get(\n    relativePath: string,\n    query?: Query<string>,\n    requestHeaders?: Record<string, string>,\n    customOptions?: Record<string, unknown>\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {}),\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      headers,\n      ...(customOptions ?? {}),\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n\n  async post(\n    relativePath: string,\n    data: Uint8Array,\n    query?: Query<string>,\n    requestHeaders?: Record<string, string>,\n    customOptions?: Record<string, unknown>\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {}),\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      body: data,\n      headers,\n      ...(customOptions ?? {}),\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n\n  async delete(\n    relativePath: string,\n    data?: Uint8Array,\n    query?: Query<string>,\n    requestHeaders?: Record<string, string>,\n    customOptions?: Record<string, unknown>\n  ): Promise<BaseHTTPClientResponse> {\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...(requestHeaders ?? {}),\n    };\n\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      body: data,\n      headers,\n      ...(customOptions ?? {}),\n    });\n\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}