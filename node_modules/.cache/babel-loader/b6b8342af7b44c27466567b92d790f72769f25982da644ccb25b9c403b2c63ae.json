{"ast":null,"code":"import { base64ToBytes, bytesToBase64, coerceToBytes } from '../encoding/binarydata.js';\nimport IntDecoding from '../types/intDecoding.js';\nimport ServiceClient from './v2/serviceClient.js';\nexport class KmdClient extends ServiceClient {\n  constructor(token, baseServer = 'http://127.0.0.1', port = 7833, headers = {}) {\n    super('X-KMD-API-Token', token, baseServer, port, headers);\n  }\n  async get(relativePath) {\n    const res = await this.c.get({\n      relativePath\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE\n    });\n  }\n  async delete(relativePath, data) {\n    const res = await this.c.delete({\n      relativePath,\n      data\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE\n    });\n  }\n  async post(relativePath, data) {\n    const res = await this.c.post({\n      relativePath,\n      data\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE\n    });\n  }\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   */\n  async versions() {\n    return this.get('/versions');\n  }\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   */\n  async listWallets() {\n    return this.get('/v1/wallets');\n  }\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   */\n  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = 'sqlite') {\n    const req = {\n      wallet_name: walletName,\n      wallet_driver_name: walletDriverName,\n      wallet_password: walletPassword,\n      master_derivation_key: bytesToBase64(walletMDK)\n    };\n    return this.post('/v1/wallet', req);\n  }\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   */\n  async initWalletHandle(walletID, walletPassword) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword\n    };\n    return this.post('/v1/wallet/init', req);\n  }\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   */\n  async releaseWalletHandle(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    return this.post('/v1/wallet/release', req);\n  }\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   */\n  async renewWalletHandle(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    return this.post('/v1/wallet/renew', req);\n  }\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   */\n  async renameWallet(walletID, walletPassword, newWalletName) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n      wallet_name: newWalletName\n    };\n    return this.post('/v1/wallet/rename', req);\n  }\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   */\n  async getWallet(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    return this.post('/v1/wallet/info', req);\n  }\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   */\n  async exportMasterDerivationKey(walletHandle, walletPassword) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword\n    };\n    const res = await this.post('/v1/master-key/export', req);\n    return {\n      master_derivation_key: base64ToBytes(res.master_derivation_key)\n    };\n  }\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   */\n  async importKey(walletHandle, secretKey) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      private_key: bytesToBase64(secretKey)\n    };\n    return this.post('/v1/key/import', req);\n  }\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async exportKey(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    const res = await this.post('/v1/key/export', req);\n    return {\n      private_key: base64ToBytes(res.private_key)\n    };\n  }\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   */\n  async generateKey(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      display_mnemonic: false\n    };\n    return this.post('/v1/key', req);\n  }\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async deleteKey(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    return this.delete('/v1/key', req);\n  }\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   */\n  async listKeys(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    return this.post('/v1/key/list', req);\n  }\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   */\n  async signTransaction(walletHandle, walletPassword, transaction) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: bytesToBase64(transaction.toByte())\n    };\n    const res = await this.post('/v1/transaction/sign', req);\n    return base64ToBytes(res.signed_transaction);\n  }\n  /**\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * publicKey arg.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n   */\n  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {\n    const pk = coerceToBytes(publicKey);\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: bytesToBase64(transaction.toByte()),\n      public_key: bytesToBase64(pk)\n    };\n    const res = await this.post('/v1/transaction/sign', req);\n    return base64ToBytes(res.signed_transaction);\n  }\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   */\n  async listMultisig(walletHandle) {\n    const req = {\n      wallet_handle_token: walletHandle\n    };\n    return this.post('/v1/multisig/list', req);\n  }\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   */\n  async importMultisig(walletHandle, version, threshold, pks) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      multisig_version: version,\n      threshold,\n      pks\n    };\n    return this.post('/v1/multisig/import', req);\n  }\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async exportMultisig(walletHandle, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr\n    };\n    return this.post('/v1/multisig/export', req);\n  }\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   */\n  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {\n    const pubkey = coerceToBytes(pk);\n    const req = {\n      wallet_handle_token: walletHandle,\n      transaction: bytesToBase64(transaction.toByte()),\n      public_key: bytesToBase64(pubkey),\n      partial_multisig: partial,\n      wallet_password: pw\n    };\n    return this.post('/v1/multisig/sign', req);\n  }\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the\n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async deleteMultisig(walletHandle, walletPassword, addr) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword\n    };\n    return this.delete('/v1/multisig', req);\n  }\n}","map":{"version":3,"names":["base64ToBytes","bytesToBase64","coerceToBytes","IntDecoding","ServiceClient","KmdClient","constructor","token","baseServer","port","headers","get","relativePath","res","c","parseBodyAsJSON","intDecoding","SAFE","delete","data","post","versions","listWallets","createWallet","walletName","walletPassword","walletMDK","Uint8Array","walletDriverName","req","wallet_name","wallet_driver_name","wallet_password","master_derivation_key","initWalletHandle","walletID","wallet_id","releaseWalletHandle","walletHandle","wallet_handle_token","renewWalletHandle","renameWallet","newWalletName","getWallet","exportMasterDerivationKey","importKey","secretKey","private_key","exportKey","addr","address","generateKey","display_mnemonic","deleteKey","listKeys","signTransaction","transaction","toByte","signed_transaction","signTransactionWithSpecificPublicKey","publicKey","pk","public_key","listMultisig","importMultisig","version","threshold","pks","multisig_version","exportMultisig","signMultisigTransaction","pw","partial","pubkey","partial_multisig","deleteMultisig"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\client\\kmd.ts"],"sourcesContent":["import {\n  base64ToBytes,\n  bytesToBase64,\n  coerceToBytes,\n} from '../encoding/binarydata.js';\nimport IntDecoding from '../types/intDecoding.js';\nimport { Transaction } from '../transaction.js';\nimport { CustomTokenHeader, KMDTokenHeader } from './urlTokenBaseHTTPClient.js';\nimport ServiceClient from './v2/serviceClient.js';\n\nexport class KmdClient extends ServiceClient {\n  constructor(\n    token: string | KMDTokenHeader | CustomTokenHeader,\n    baseServer = 'http://127.0.0.1',\n    port: string | number = 7833,\n    headers = {}\n  ) {\n    super('X-KMD-API-Token', token, baseServer, port, headers);\n  }\n\n  private async get(relativePath: string): Promise<any> {\n    const res = await this.c.get({\n      relativePath,\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE,\n    });\n  }\n\n  private async delete(relativePath: string, data: any): Promise<any> {\n    const res = await this.c.delete({\n      relativePath,\n      data,\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE,\n    });\n  }\n\n  private async post(relativePath: string, data: any): Promise<any> {\n    const res = await this.c.post({\n      relativePath,\n      data,\n    });\n    return res.parseBodyAsJSON({\n      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big\n      intDecoding: IntDecoding.SAFE,\n    });\n  }\n\n  /**\n   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.\n   */\n  async versions() {\n    return this.get('/versions');\n  }\n\n  /**\n   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID\n   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle\n   */\n  async listWallets() {\n    return this.get('/v1/wallets');\n  }\n\n  /**\n   * createWallet creates a wallet with the specified name, password, driver,\n   * and master derivation key. If the master derivation key is blank, one is\n   * generated internally to kmd. CreateWallet returns a CreateWalletResponse\n   * containing information about the new wallet.\n   * @param walletName\n   * @param walletPassword\n   * @param walletDriverName\n   * @param walletMDK\n   */\n  async createWallet(\n    walletName: string,\n    walletPassword: string,\n    walletMDK: Uint8Array = new Uint8Array(),\n    walletDriverName = 'sqlite'\n  ) {\n    const req = {\n      wallet_name: walletName,\n      wallet_driver_name: walletDriverName,\n      wallet_password: walletPassword,\n      master_derivation_key: bytesToBase64(walletMDK),\n    };\n    return this.post('/v1/wallet', req);\n  }\n\n  /**\n   * initWalletHandle accepts a wallet ID and a wallet password, and returns an\n   * initWalletHandleResponse containing a wallet handle token. This wallet\n   * handle token can be used for subsequent operations on this wallet, like key\n   * generation, transaction signing, etc.. WalletHandleTokens expire after a\n   * configurable number of seconds, and must be renewed periodically with\n   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when\n   * you're done interacting with this wallet.\n   * @param walletID\n   * @param walletPassword\n   */\n  async initWalletHandle(walletID: string, walletPassword: string) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n    };\n    return this.post('/v1/wallet/init', req);\n  }\n\n  /**\n   * releaseWalletHandle invalidates the passed wallet handle token, making\n   * it unusuable for subsequent wallet operations.\n   * @param walletHandle\n   */\n  async releaseWalletHandle(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    return this.post('/v1/wallet/release', req);\n  }\n\n  /**\n   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving\n   * the expiration time to some number of seconds in the future. It returns a\n   * RenewWalletHandleResponse containing the walletHandle and the number of\n   * seconds until expiration\n   * @param walletHandle\n   */\n  async renewWalletHandle(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    return this.post('/v1/wallet/renew', req);\n  }\n\n  /**\n   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,\n   * and renames the underlying wallet.\n   * @param walletID\n   * @param walletPassword\n   * @param newWalletName\n   */\n  async renameWallet(\n    walletID: string,\n    walletPassword: string,\n    newWalletName: string\n  ) {\n    const req = {\n      wallet_id: walletID,\n      wallet_password: walletPassword,\n      wallet_name: newWalletName,\n    };\n    return this.post('/v1/wallet/rename', req);\n  }\n\n  /**\n   * getWallet accepts a wallet handle and returns high level information about\n   * this wallet in a GetWalletResponse.\n   * @param walletHandle\n   */\n  async getWallet(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    return this.post('/v1/wallet/info', req);\n  }\n\n  /**\n   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and\n   * returns an ExportMasterDerivationKeyResponse containing the master\n   * derivation key. This key can be used as an argument to CreateWallet in\n   * order to recover the keys generated by this wallet. The master derivation\n   * key can be encoded as a sequence of words using the mnemonic library, and\n   * @param walletHandle\n   * @param walletPassword\n   */\n  async exportMasterDerivationKey(\n    walletHandle: string,\n    walletPassword: string\n  ) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n    };\n    const res = await this.post('/v1/master-key/export', req);\n    return {\n      master_derivation_key: base64ToBytes(res.master_derivation_key),\n    };\n  }\n\n  /**\n   * importKey accepts a wallet handle and an ed25519 private key, and imports\n   * the key into the wallet. It returns an ImportKeyResponse containing the\n   * address corresponding to this private key.\n   * @param walletHandle\n   * @param secretKey\n   */\n  async importKey(walletHandle: string, secretKey: Uint8Array) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      private_key: bytesToBase64(secretKey),\n    };\n    return this.post('/v1/key/import', req);\n  }\n\n  /**\n   * exportKey accepts a wallet handle, wallet password, and address, and returns\n   * an ExportKeyResponse containing the ed25519 private key corresponding to the\n   * address stored in the wallet.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async exportKey(walletHandle: string, walletPassword: string, addr: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    const res = await this.post('/v1/key/export', req);\n    return { private_key: base64ToBytes(res.private_key) };\n  }\n\n  /**\n   * generateKey accepts a wallet handle, and then generates the next key in the\n   * wallet using its internal master derivation key. Two wallets with the same\n   * master derivation key will generate the same sequence of keys.\n   * @param walletHandle\n   */\n  async generateKey(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      display_mnemonic: false,\n    };\n    return this.post('/v1/key', req);\n  }\n\n  /**\n   * deleteKey accepts a wallet handle, wallet password, and address, and deletes\n   * the information about this address from the wallet (including address and\n   * secret key). If DeleteKey is called on a key generated using GenerateKey,\n   * the same key will not be generated again. However, if a wallet is recovered\n   * using the master derivation key, a key generated in this way can be\n   * recovered.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async deleteKey(walletHandle: string, walletPassword: string, addr: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    return this.delete('/v1/key', req);\n  }\n\n  /**\n   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing\n   * all of the addresses for which this wallet contains secret keys.\n   * @param walletHandle\n   */\n  async listKeys(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    return this.post('/v1/key/list', req);\n  }\n\n  /**\n   * signTransaction accepts a wallet handle, wallet password, and a transaction,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * Sender field.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   */\n  async signTransaction(\n    walletHandle: string,\n    walletPassword: string,\n    transaction: Transaction\n  ) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: bytesToBase64(transaction.toByte()),\n    };\n    const res = await this.post('/v1/transaction/sign', req);\n    return base64ToBytes(res.signed_transaction);\n  }\n\n  /**\n   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,\n   * and returns and SignTransactionResponse containing an encoded, signed\n   * transaction. The transaction is signed using the key corresponding to the\n   * publicKey arg.\n   * @param walletHandle\n   * @param walletPassword\n   * @param transaction\n   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)\n   */\n  async signTransactionWithSpecificPublicKey(\n    walletHandle: string,\n    walletPassword: string,\n    transaction: Transaction,\n    publicKey: Uint8Array | string\n  ) {\n    const pk = coerceToBytes(publicKey);\n\n    const req = {\n      wallet_handle_token: walletHandle,\n      wallet_password: walletPassword,\n      transaction: bytesToBase64(transaction.toByte()),\n      public_key: bytesToBase64(pk),\n    };\n    const res = await this.post('/v1/transaction/sign', req);\n    return base64ToBytes(res.signed_transaction);\n  }\n\n  /**\n   * listMultisig accepts a wallet handle and returns a ListMultisigResponse\n   * containing the multisig addresses whose preimages are stored in this wallet.\n   * A preimage is the information needed to reconstruct this multisig address,\n   * including multisig version information, threshold information, and a list\n   * of public keys.\n   * @param walletHandle\n   */\n  async listMultisig(walletHandle: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n    };\n    return this.post('/v1/multisig/list', req);\n  }\n\n  /**\n   * importMultisig accepts a wallet handle and the information required to\n   * generate a multisig address. It derives this address, and stores all of the\n   * information within the wallet. It returns a ImportMultisigResponse with the\n   * derived address.\n   * @param walletHandle\n   * @param version\n   * @param threshold\n   * @param pks\n   */\n  async importMultisig(\n    walletHandle: string,\n    version: number,\n    threshold: number,\n    pks: string[]\n  ) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      multisig_version: version,\n      threshold,\n      pks,\n    };\n    return this.post('/v1/multisig/import', req);\n  }\n\n  /**\n   * exportMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and returns an ExportMultisigResponse containing the stored\n   * multisig preimage. The preimage contains all of the information necessary\n   * to derive the multisig address, including version, threshold, and a list of\n   * public keys.\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async exportMultisig(walletHandle: string, addr: string) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n    };\n    return this.post('/v1/multisig/export', req);\n  }\n\n  /**\n   * signMultisigTransaction accepts a wallet handle, wallet password,\n   * transaction, public key (*not* an address), and an optional partial\n   * MultisigSig. It looks up the secret key corresponding to the public key, and\n   * returns a SignMultisigTransactionResponse containing a MultisigSig with a\n   * signature by the secret key included.\n   * @param walletHandle\n   * @param pw\n   * @param tx\n   * @param pk\n   * @param partial\n   */\n  async signMultisigTransaction(\n    walletHandle: string,\n    pw: string,\n    transaction: Transaction,\n    pk: Uint8Array | string,\n    partial: string\n  ) {\n    const pubkey = coerceToBytes(pk);\n    const req = {\n      wallet_handle_token: walletHandle,\n      transaction: bytesToBase64(transaction.toByte()),\n      public_key: bytesToBase64(pubkey),\n      partial_multisig: partial,\n      wallet_password: pw,\n    };\n    return this.post('/v1/multisig/sign', req);\n  }\n\n  /**\n   * deleteMultisig accepts a wallet handle, wallet password, and multisig\n   * address, and deletes the information about this multisig address from the\n   * wallet (including address and secret key).\n   * @param walletHandle\n   * @param walletPassword\n   * @param addr\n   */\n  async deleteMultisig(\n    walletHandle: string,\n    walletPassword: string,\n    addr: string\n  ) {\n    const req = {\n      wallet_handle_token: walletHandle,\n      address: addr,\n      wallet_password: walletPassword,\n    };\n    return this.delete('/v1/multisig', req);\n  }\n}\n"],"mappings":"AAAA,SACEA,aAAa,EACbC,aAAa,EACbC,aAAa,QACR,2BAA2B;AAClC,OAAOC,WAAW,MAAM,yBAAyB;AAGjD,OAAOC,aAAa,MAAM,uBAAuB;AAEjD,OAAM,MAAOC,SAAU,SAAQD,aAAa;EAC1CE,YACEC,KAAkD,EAClDC,UAAU,GAAG,kBAAkB,EAC/BC,IAAA,GAAwB,IAAI,EAC5BC,OAAO,GAAG,EAAE;IAEZ,KAAK,CAAC,iBAAiB,EAAEH,KAAK,EAAEC,UAAU,EAAEC,IAAI,EAAEC,OAAO,CAAC;EAC5D;EAEQ,MAAMC,GAAGA,CAACC,YAAoB;IACpC,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACC,CAAC,CAACH,GAAG,CAAC;MAC3BC;KACD,CAAC;IACF,OAAOC,GAAG,CAACE,eAAe,CAAC;MACzB;MACAC,WAAW,EAAEb,WAAW,CAACc;KAC1B,CAAC;EACJ;EAEQ,MAAMC,MAAMA,CAACN,YAAoB,EAAEO,IAAS;IAClD,MAAMN,GAAG,GAAG,MAAM,IAAI,CAACC,CAAC,CAACI,MAAM,CAAC;MAC9BN,YAAY;MACZO;KACD,CAAC;IACF,OAAON,GAAG,CAACE,eAAe,CAAC;MACzB;MACAC,WAAW,EAAEb,WAAW,CAACc;KAC1B,CAAC;EACJ;EAEQ,MAAMG,IAAIA,CAACR,YAAoB,EAAEO,IAAS;IAChD,MAAMN,GAAG,GAAG,MAAM,IAAI,CAACC,CAAC,CAACM,IAAI,CAAC;MAC5BR,YAAY;MACZO;KACD,CAAC;IACF,OAAON,GAAG,CAACE,eAAe,CAAC;MACzB;MACAC,WAAW,EAAEb,WAAW,CAACc;KAC1B,CAAC;EACJ;EAEA;;;EAGA,MAAMI,QAAQA,CAAA;IACZ,OAAO,IAAI,CAACV,GAAG,CAAC,WAAW,CAAC;EAC9B;EAEA;;;;EAIA,MAAMW,WAAWA,CAAA;IACf,OAAO,IAAI,CAACX,GAAG,CAAC,aAAa,CAAC;EAChC;EAEA;;;;;;;;;;EAUA,MAAMY,YAAYA,CAChBC,UAAkB,EAClBC,cAAsB,EACtBC,SAAA,GAAwB,IAAIC,UAAU,EAAE,EACxCC,gBAAgB,GAAG,QAAQ;IAE3B,MAAMC,GAAG,GAAG;MACVC,WAAW,EAAEN,UAAU;MACvBO,kBAAkB,EAAEH,gBAAgB;MACpCI,eAAe,EAAEP,cAAc;MAC/BQ,qBAAqB,EAAEhC,aAAa,CAACyB,SAAS;KAC/C;IACD,OAAO,IAAI,CAACN,IAAI,CAAC,YAAY,EAAES,GAAG,CAAC;EACrC;EAEA;;;;;;;;;;;EAWA,MAAMK,gBAAgBA,CAACC,QAAgB,EAAEV,cAAsB;IAC7D,MAAMI,GAAG,GAAG;MACVO,SAAS,EAAED,QAAQ;MACnBH,eAAe,EAAEP;KAClB;IACD,OAAO,IAAI,CAACL,IAAI,CAAC,iBAAiB,EAAES,GAAG,CAAC;EAC1C;EAEA;;;;;EAKA,MAAMQ,mBAAmBA,CAACC,YAAoB;IAC5C,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED;KACtB;IACD,OAAO,IAAI,CAAClB,IAAI,CAAC,oBAAoB,EAAES,GAAG,CAAC;EAC7C;EAEA;;;;;;;EAOA,MAAMW,iBAAiBA,CAACF,YAAoB;IAC1C,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED;KACtB;IACD,OAAO,IAAI,CAAClB,IAAI,CAAC,kBAAkB,EAAES,GAAG,CAAC;EAC3C;EAEA;;;;;;;EAOA,MAAMY,YAAYA,CAChBN,QAAgB,EAChBV,cAAsB,EACtBiB,aAAqB;IAErB,MAAMb,GAAG,GAAG;MACVO,SAAS,EAAED,QAAQ;MACnBH,eAAe,EAAEP,cAAc;MAC/BK,WAAW,EAAEY;KACd;IACD,OAAO,IAAI,CAACtB,IAAI,CAAC,mBAAmB,EAAES,GAAG,CAAC;EAC5C;EAEA;;;;;EAKA,MAAMc,SAASA,CAACL,YAAoB;IAClC,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED;KACtB;IACD,OAAO,IAAI,CAAClB,IAAI,CAAC,iBAAiB,EAAES,GAAG,CAAC;EAC1C;EAEA;;;;;;;;;EASA,MAAMe,yBAAyBA,CAC7BN,YAAoB,EACpBb,cAAsB;IAEtB,MAAMI,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCN,eAAe,EAAEP;KAClB;IACD,MAAMZ,GAAG,GAAG,MAAM,IAAI,CAACO,IAAI,CAAC,uBAAuB,EAAES,GAAG,CAAC;IACzD,OAAO;MACLI,qBAAqB,EAAEjC,aAAa,CAACa,GAAG,CAACoB,qBAAqB;KAC/D;EACH;EAEA;;;;;;;EAOA,MAAMY,SAASA,CAACP,YAAoB,EAAEQ,SAAqB;IACzD,MAAMjB,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCS,WAAW,EAAE9C,aAAa,CAAC6C,SAAS;KACrC;IACD,OAAO,IAAI,CAAC1B,IAAI,CAAC,gBAAgB,EAAES,GAAG,CAAC;EACzC;EAEA;;;;;;;;EAQA,MAAMmB,SAASA,CAACV,YAAoB,EAAEb,cAAsB,EAAEwB,IAAY;IACxE,MAAMpB,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCY,OAAO,EAAED,IAAI;MACbjB,eAAe,EAAEP;KAClB;IACD,MAAMZ,GAAG,GAAG,MAAM,IAAI,CAACO,IAAI,CAAC,gBAAgB,EAAES,GAAG,CAAC;IAClD,OAAO;MAAEkB,WAAW,EAAE/C,aAAa,CAACa,GAAG,CAACkC,WAAW;IAAC,CAAE;EACxD;EAEA;;;;;;EAMA,MAAMI,WAAWA,CAACb,YAAoB;IACpC,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCc,gBAAgB,EAAE;KACnB;IACD,OAAO,IAAI,CAAChC,IAAI,CAAC,SAAS,EAAES,GAAG,CAAC;EAClC;EAEA;;;;;;;;;;;EAWA,MAAMwB,SAASA,CAACf,YAAoB,EAAEb,cAAsB,EAAEwB,IAAY;IACxE,MAAMpB,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCY,OAAO,EAAED,IAAI;MACbjB,eAAe,EAAEP;KAClB;IACD,OAAO,IAAI,CAACP,MAAM,CAAC,SAAS,EAAEW,GAAG,CAAC;EACpC;EAEA;;;;;EAKA,MAAMyB,QAAQA,CAAChB,YAAoB;IACjC,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED;KACtB;IACD,OAAO,IAAI,CAAClB,IAAI,CAAC,cAAc,EAAES,GAAG,CAAC;EACvC;EAEA;;;;;;;;;EASA,MAAM0B,eAAeA,CACnBjB,YAAoB,EACpBb,cAAsB,EACtB+B,WAAwB;IAExB,MAAM3B,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCN,eAAe,EAAEP,cAAc;MAC/B+B,WAAW,EAAEvD,aAAa,CAACuD,WAAW,CAACC,MAAM,EAAE;KAChD;IACD,MAAM5C,GAAG,GAAG,MAAM,IAAI,CAACO,IAAI,CAAC,sBAAsB,EAAES,GAAG,CAAC;IACxD,OAAO7B,aAAa,CAACa,GAAG,CAAC6C,kBAAkB,CAAC;EAC9C;EAEA;;;;;;;;;;EAUA,MAAMC,oCAAoCA,CACxCrB,YAAoB,EACpBb,cAAsB,EACtB+B,WAAwB,EACxBI,SAA8B;IAE9B,MAAMC,EAAE,GAAG3D,aAAa,CAAC0D,SAAS,CAAC;IAEnC,MAAM/B,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCN,eAAe,EAAEP,cAAc;MAC/B+B,WAAW,EAAEvD,aAAa,CAACuD,WAAW,CAACC,MAAM,EAAE,CAAC;MAChDK,UAAU,EAAE7D,aAAa,CAAC4D,EAAE;KAC7B;IACD,MAAMhD,GAAG,GAAG,MAAM,IAAI,CAACO,IAAI,CAAC,sBAAsB,EAAES,GAAG,CAAC;IACxD,OAAO7B,aAAa,CAACa,GAAG,CAAC6C,kBAAkB,CAAC;EAC9C;EAEA;;;;;;;;EAQA,MAAMK,YAAYA,CAACzB,YAAoB;IACrC,MAAMT,GAAG,GAAG;MACVU,mBAAmB,EAAED;KACtB;IACD,OAAO,IAAI,CAAClB,IAAI,CAAC,mBAAmB,EAAES,GAAG,CAAC;EAC5C;EAEA;;;;;;;;;;EAUA,MAAMmC,cAAcA,CAClB1B,YAAoB,EACpB2B,OAAe,EACfC,SAAiB,EACjBC,GAAa;IAEb,MAAMtC,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjC8B,gBAAgB,EAAEH,OAAO;MACzBC,SAAS;MACTC;KACD;IACD,OAAO,IAAI,CAAC/C,IAAI,CAAC,qBAAqB,EAAES,GAAG,CAAC;EAC9C;EAEA;;;;;;;;;;EAUA,MAAMwC,cAAcA,CAAC/B,YAAoB,EAAEW,IAAY;IACrD,MAAMpB,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCY,OAAO,EAAED;KACV;IACD,OAAO,IAAI,CAAC7B,IAAI,CAAC,qBAAqB,EAAES,GAAG,CAAC;EAC9C;EAEA;;;;;;;;;;;;EAYA,MAAMyC,uBAAuBA,CAC3BhC,YAAoB,EACpBiC,EAAU,EACVf,WAAwB,EACxBK,EAAuB,EACvBW,OAAe;IAEf,MAAMC,MAAM,GAAGvE,aAAa,CAAC2D,EAAE,CAAC;IAChC,MAAMhC,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCkB,WAAW,EAAEvD,aAAa,CAACuD,WAAW,CAACC,MAAM,EAAE,CAAC;MAChDK,UAAU,EAAE7D,aAAa,CAACwE,MAAM,CAAC;MACjCC,gBAAgB,EAAEF,OAAO;MACzBxC,eAAe,EAAEuC;KAClB;IACD,OAAO,IAAI,CAACnD,IAAI,CAAC,mBAAmB,EAAES,GAAG,CAAC;EAC5C;EAEA;;;;;;;;EAQA,MAAM8C,cAAcA,CAClBrC,YAAoB,EACpBb,cAAsB,EACtBwB,IAAY;IAEZ,MAAMpB,GAAG,GAAG;MACVU,mBAAmB,EAAED,YAAY;MACjCY,OAAO,EAAED,IAAI;MACbjB,eAAe,EAAEP;KAClB;IACD,OAAO,IAAI,CAACP,MAAM,CAAC,cAAc,EAAEW,GAAG,CAAC;EACzC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}