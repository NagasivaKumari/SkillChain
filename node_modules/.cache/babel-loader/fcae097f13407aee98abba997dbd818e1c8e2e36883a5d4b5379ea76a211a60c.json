{"ast":null,"code":"import * as vlq from 'vlq';\n/**\n * Contains a mapping from TEAL program PC to source file location.\n */\nexport class ProgramSourceMap {\n  constructor({\n    version,\n    sources,\n    names,\n    mappings\n  }) {\n    this.version = version;\n    this.sources = sources;\n    this.names = names;\n    this.mappings = mappings;\n    if (this.version !== 3) throw new Error(`Only version 3 is supported, got ${this.version}`);\n    if (this.mappings === undefined) throw new Error('mapping undefined, cannot build source map without `mapping`');\n    const pcList = this.mappings.split(';').map(vlq.decode);\n    this.pcToLocation = new Map();\n    this.sourceAndLineToPc = new Map();\n    const lastLocation = {\n      line: 0,\n      column: 0,\n      sourceIndex: 0,\n      nameIndex: 0\n    };\n    for (const [pc, data] of pcList.entries()) {\n      if (data.length < 4) continue;\n      const nameDelta = data.length > 4 ? data[4] : undefined;\n      const [, sourceDelta, lineDelta, columnDelta] = data;\n      lastLocation.sourceIndex += sourceDelta;\n      lastLocation.line += lineDelta;\n      lastLocation.column += columnDelta;\n      if (typeof nameDelta !== 'undefined') {\n        lastLocation.nameIndex += nameDelta;\n      }\n      const sourceAndLineKey = `${lastLocation.sourceIndex}:${lastLocation.line}`;\n      let pcsForSourceAndLine = this.sourceAndLineToPc.get(sourceAndLineKey);\n      if (pcsForSourceAndLine === undefined) {\n        pcsForSourceAndLine = [];\n        this.sourceAndLineToPc.set(sourceAndLineKey, pcsForSourceAndLine);\n      }\n      const pcInLine = {\n        pc,\n        column: lastLocation.column\n      };\n      const pcLocation = {\n        line: lastLocation.line,\n        column: lastLocation.column,\n        sourceIndex: lastLocation.sourceIndex\n      };\n      if (typeof nameDelta !== 'undefined') {\n        pcInLine.nameIndex = lastLocation.nameIndex;\n        pcLocation.nameIndex = lastLocation.nameIndex;\n      }\n      pcsForSourceAndLine.push(pcInLine);\n      this.pcToLocation.set(pc, pcLocation);\n    }\n  }\n  getPcs() {\n    return Array.from(this.pcToLocation.keys());\n  }\n  getLocationForPc(pc) {\n    return this.pcToLocation.get(pc);\n  }\n  getPcsOnSourceLine(sourceIndex, line) {\n    const pcs = this.sourceAndLineToPc.get(`${sourceIndex}:${line}`);\n    if (pcs === undefined) return [];\n    return pcs;\n  }\n}","map":{"version":3,"names":["vlq","ProgramSourceMap","constructor","version","sources","names","mappings","Error","undefined","pcList","split","map","decode","pcToLocation","Map","sourceAndLineToPc","lastLocation","line","column","sourceIndex","nameIndex","pc","data","entries","length","nameDelta","sourceDelta","lineDelta","columnDelta","sourceAndLineKey","pcsForSourceAndLine","get","set","pcInLine","pcLocation","push","getPcs","Array","from","keys","getLocationForPc","getPcsOnSourceLine","pcs"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\logic\\sourcemap.ts"],"sourcesContent":["import * as vlq from 'vlq';\n\n/**\n * Represents a location in a source file.\n */\nexport interface SourceLocation {\n  line: number;\n  column: number;\n  sourceIndex: number;\n  nameIndex?: number;\n}\n\n/**\n * Represents the location of a specific PC in a source line.\n */\nexport interface PcLineLocation {\n  pc: number;\n  column: number;\n  nameIndex?: number;\n}\n\n/**\n * Contains a mapping from TEAL program PC to source file location.\n */\nexport class ProgramSourceMap {\n  public readonly version: number;\n  /**\n   * A list of original sources used by the \"mappings\" entry.\n   */\n  public readonly sources: string[];\n  /**\n   * A list of symbol names used by the \"mappings\" entry.\n   */\n  public readonly names: string[];\n  /**\n   * A string with the encoded mapping data.\n   */\n  public readonly mappings: string;\n\n  private pcToLocation: Map<number, SourceLocation>;\n\n  // Key is `${sourceIndex}:${line}`\n  private sourceAndLineToPc: Map<string, PcLineLocation[]>;\n\n  constructor({\n    version,\n    sources,\n    names,\n    mappings,\n  }: {\n    version: number;\n    sources: string[];\n    names: string[];\n    mappings: string;\n  }) {\n    this.version = version;\n    this.sources = sources;\n    this.names = names;\n    this.mappings = mappings;\n\n    if (this.version !== 3)\n      throw new Error(`Only version 3 is supported, got ${this.version}`);\n\n    if (this.mappings === undefined)\n      throw new Error(\n        'mapping undefined, cannot build source map without `mapping`'\n      );\n\n    const pcList = this.mappings.split(';').map(vlq.decode);\n\n    this.pcToLocation = new Map();\n    this.sourceAndLineToPc = new Map();\n\n    const lastLocation = {\n      line: 0,\n      column: 0,\n      sourceIndex: 0,\n      nameIndex: 0,\n    } satisfies SourceLocation;\n    for (const [pc, data] of pcList.entries()) {\n      if (data.length < 4) continue;\n\n      const nameDelta = data.length > 4 ? data[4] : undefined;\n      const [, sourceDelta, lineDelta, columnDelta] = data;\n\n      lastLocation.sourceIndex += sourceDelta;\n      lastLocation.line += lineDelta;\n      lastLocation.column += columnDelta;\n      if (typeof nameDelta !== 'undefined') {\n        lastLocation.nameIndex += nameDelta;\n      }\n\n      const sourceAndLineKey = `${lastLocation.sourceIndex}:${lastLocation.line}`;\n      let pcsForSourceAndLine = this.sourceAndLineToPc.get(sourceAndLineKey);\n      if (pcsForSourceAndLine === undefined) {\n        pcsForSourceAndLine = [];\n        this.sourceAndLineToPc.set(sourceAndLineKey, pcsForSourceAndLine);\n      }\n\n      const pcInLine: PcLineLocation = {\n        pc,\n        column: lastLocation.column,\n      };\n      const pcLocation: SourceLocation = {\n        line: lastLocation.line,\n        column: lastLocation.column,\n        sourceIndex: lastLocation.sourceIndex,\n      };\n      if (typeof nameDelta !== 'undefined') {\n        pcInLine.nameIndex = lastLocation.nameIndex;\n        pcLocation.nameIndex = lastLocation.nameIndex;\n      }\n\n      pcsForSourceAndLine.push(pcInLine);\n      this.pcToLocation.set(pc, pcLocation);\n    }\n  }\n\n  getPcs(): number[] {\n    return Array.from(this.pcToLocation.keys());\n  }\n\n  getLocationForPc(pc: number): SourceLocation | undefined {\n    return this.pcToLocation.get(pc);\n  }\n\n  getPcsOnSourceLine(sourceIndex: number, line: number): PcLineLocation[] {\n    const pcs = this.sourceAndLineToPc.get(`${sourceIndex}:${line}`);\n    if (pcs === undefined) return [];\n    return pcs;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}