{"ast":null,"code":"import { RawBinaryString } from 'algorand-msgpack';\nimport { Schema } from '../encoding.js';\nimport { coerceToBytes, bytesToString, bytesToBase64 } from '../binarydata.js';\nimport { arrayEqual } from '../../utils/utils.js';\n/* eslint-disable class-methods-use-this */\n/**\n * SpecialCaseBinaryStringSchema is a schema for byte arrays which are encoded\n * as strings in msgpack and JSON.\n *\n * This schema allows lossless conversion between the in memory representation\n * and the msgpack encoded representation, but NOT between the in memory and\n * JSON encoded representations if the byte array contains invalid UTF-8\n * sequences.\n */\nexport class SpecialCaseBinaryStringSchema extends Schema {\n  defaultValue() {\n    return new Uint8Array();\n  }\n  isDefaultValue(data) {\n    return data instanceof Uint8Array && data.byteLength === 0;\n  }\n  prepareMsgpack(data) {\n    if (data instanceof Uint8Array) {\n      // Cast is needed because RawBinaryString is not part of the standard MsgpackEncodingData\n      return new RawBinaryString(data);\n    }\n    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);\n  }\n  fromPreparedMsgpack(_encoded, rawStringProvider) {\n    return rawStringProvider.getRawStringAtCurrentLocation();\n  }\n  prepareJSON(data, options) {\n    if (data instanceof Uint8Array) {\n      // Not safe to convert to string for all binary data\n      const stringValue = bytesToString(data);\n      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(stringValue), data)) {\n        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`);\n      }\n      return stringValue;\n    }\n    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);\n  }\n  fromPreparedJSON(encoded) {\n    if (typeof encoded === 'string') {\n      return coerceToBytes(encoded);\n    }\n    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);\n  }\n}","map":{"version":3,"names":["RawBinaryString","Schema","coerceToBytes","bytesToString","bytesToBase64","arrayEqual","SpecialCaseBinaryStringSchema","defaultValue","Uint8Array","isDefaultValue","data","byteLength","prepareMsgpack","Error","fromPreparedMsgpack","_encoded","rawStringProvider","getRawStringAtCurrentLocation","prepareJSON","options","stringValue","lossyBinaryStringConversion","fromPreparedJSON","encoded"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\encoding\\schema\\binarystring.ts"],"sourcesContent":["import { RawBinaryString } from 'algorand-msgpack';\nimport {\n  Schema,\n  MsgpackEncodingData,\n  MsgpackRawStringProvider,\n  JSONEncodingData,\n  PrepareJSONOptions,\n} from '../encoding.js';\nimport { coerceToBytes, bytesToString, bytesToBase64 } from '../binarydata.js';\nimport { arrayEqual } from '../../utils/utils.js';\n\n/* eslint-disable class-methods-use-this */\n\n/**\n * SpecialCaseBinaryStringSchema is a schema for byte arrays which are encoded\n * as strings in msgpack and JSON.\n *\n * This schema allows lossless conversion between the in memory representation\n * and the msgpack encoded representation, but NOT between the in memory and\n * JSON encoded representations if the byte array contains invalid UTF-8\n * sequences.\n */\nexport class SpecialCaseBinaryStringSchema extends Schema {\n  public defaultValue(): Uint8Array {\n    return new Uint8Array();\n  }\n\n  public isDefaultValue(data: unknown): boolean {\n    return data instanceof Uint8Array && data.byteLength === 0;\n  }\n\n  public prepareMsgpack(data: unknown): MsgpackEncodingData {\n    if (data instanceof Uint8Array) {\n      // Cast is needed because RawBinaryString is not part of the standard MsgpackEncodingData\n      return new RawBinaryString(data) as unknown as MsgpackEncodingData;\n    }\n    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);\n  }\n\n  public fromPreparedMsgpack(\n    _encoded: MsgpackEncodingData,\n    rawStringProvider: MsgpackRawStringProvider\n  ): Uint8Array {\n    return rawStringProvider.getRawStringAtCurrentLocation();\n  }\n\n  public prepareJSON(\n    data: unknown,\n    options: PrepareJSONOptions\n  ): JSONEncodingData {\n    if (data instanceof Uint8Array) {\n      // Not safe to convert to string for all binary data\n      const stringValue = bytesToString(data);\n      if (\n        !options.lossyBinaryStringConversion &&\n        !arrayEqual(coerceToBytes(stringValue), data)\n      ) {\n        throw new Error(\n          `Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`\n        );\n      }\n      return stringValue;\n    }\n    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);\n  }\n\n  public fromPreparedJSON(encoded: JSONEncodingData): Uint8Array {\n    if (typeof encoded === 'string') {\n      return coerceToBytes(encoded);\n    }\n    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);\n  }\n}\n"],"mappings":"AAAA,SAASA,eAAe,QAAQ,kBAAkB;AAClD,SACEC,MAAM,QAKD,gBAAgB;AACvB,SAASC,aAAa,EAAEC,aAAa,EAAEC,aAAa,QAAQ,kBAAkB;AAC9E,SAASC,UAAU,QAAQ,sBAAsB;AAEjD;AAEA;;;;;;;;;AASA,OAAM,MAAOC,6BAA8B,SAAQL,MAAM;EAChDM,YAAYA,CAAA;IACjB,OAAO,IAAIC,UAAU,EAAE;EACzB;EAEOC,cAAcA,CAACC,IAAa;IACjC,OAAOA,IAAI,YAAYF,UAAU,IAAIE,IAAI,CAACC,UAAU,KAAK,CAAC;EAC5D;EAEOC,cAAcA,CAACF,IAAa;IACjC,IAAIA,IAAI,YAAYF,UAAU,EAAE;MAC9B;MACA,OAAO,IAAIR,eAAe,CAACU,IAAI,CAAmC;IACpE;IACA,MAAM,IAAIG,KAAK,CAAC,wBAAwB,OAAOH,IAAI,KAAKA,IAAI,EAAE,CAAC;EACjE;EAEOI,mBAAmBA,CACxBC,QAA6B,EAC7BC,iBAA2C;IAE3C,OAAOA,iBAAiB,CAACC,6BAA6B,EAAE;EAC1D;EAEOC,WAAWA,CAChBR,IAAa,EACbS,OAA2B;IAE3B,IAAIT,IAAI,YAAYF,UAAU,EAAE;MAC9B;MACA,MAAMY,WAAW,GAAGjB,aAAa,CAACO,IAAI,CAAC;MACvC,IACE,CAACS,OAAO,CAACE,2BAA2B,IACpC,CAAChB,UAAU,CAACH,aAAa,CAACkB,WAAW,CAAC,EAAEV,IAAI,CAAC,EAC7C;QACA,MAAM,IAAIG,KAAK,CACb,6HAA6HT,aAAa,CAACM,IAAI,CAAC,EAAE,CACnJ;MACH;MACA,OAAOU,WAAW;IACpB;IACA,MAAM,IAAIP,KAAK,CAAC,wBAAwB,OAAOH,IAAI,KAAKA,IAAI,EAAE,CAAC;EACjE;EAEOY,gBAAgBA,CAACC,OAAyB;IAC/C,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE;MAC/B,OAAOrB,aAAa,CAACqB,OAAO,CAAC;IAC/B;IACA,MAAM,IAAIV,KAAK,CAAC,wBAAwB,OAAOU,OAAO,KAAKA,OAAO,EAAE,CAAC;EACvE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}