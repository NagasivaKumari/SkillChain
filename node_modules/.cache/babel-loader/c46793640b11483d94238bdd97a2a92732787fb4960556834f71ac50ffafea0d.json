{"ast":null,"code":"import * as utils from '../utils/utils.js';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient.js';\nexport class HTTPClientResponse {\n  constructor(options) {\n    this.body = options.body;\n    this.text = options.text;\n    this.format = options.format;\n    this.headers = options.headers;\n    this.status = options.status;\n    this.ok = options.ok;\n  }\n  /**\n   * Returns the response body as a string, ready to be parsed as JSON.\n   */\n  getJSONText() {\n    if (this.text === undefined) {\n      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);\n    }\n    return this.text;\n  }\n  /**\n   * Parses the response body as JSON with the given options.\n   */\n  parseBodyAsJSON(jsonOptions) {\n    if (this.text === undefined) {\n      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);\n    }\n    // eslint-disable-next-line no-use-before-define\n    return HTTPClient.parseJSON(this.text, this.status, jsonOptions);\n  }\n}\n/**\n * Remove falsy values or values with a length of 0 from an object.\n */\nfunction removeFalsyOrEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n/**\n * Create a new object with lower-case keys\n * See https://codereview.stackexchange.com/a/162418\n * Used to ensure all headers are lower-case and to work more easily with them\n */\nfunction tolowerCaseKeys(o) {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n/**\n * getAcceptFormat returns the correct Accept header depending on the\n * requested format.\n */\nfunction getAcceptFormat(query) {\n  if (query !== undefined && Object.prototype.hasOwnProperty.call(query, 'format')) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n/**\n * HTTPClient is a wrapper around a BaseHTTPClient\n * It takes care of setting the proper \"Accept\" header and of\n * decoding the JSON outputs.\n */\nexport class HTTPClient {\n  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);\n    } else {\n      this.bc = bcOrTokenHeader;\n    }\n  }\n  /**\n   * Parse JSON using utils.parseJSON\n   *\n   * @param text - JSON data\n   * @param status - Status of the response (used in case parseJSON fails)\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   */\n  static parseJSON(text, status, jsonOptions) {\n    try {\n      if (!text) {\n        return null;\n      }\n      return utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err = err_;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n  /**\n   * Serialize the data according to the requestHeaders\n   * Assumes that requestHeaders contain a key \"content-type\"\n   * If the content-type is \"application/json\", data is JSON serialized\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\n   * or an Uint8Array\n   * @private\n   */\n  static serializeData(data, requestHeaders) {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new TextEncoder().encode(utils.stringifyJSON(data));\n    }\n    if (typeof data === 'string') {\n      return new TextEncoder().encode(data);\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error('provided data is neither a string nor a Uint8Array and content-type is not application/json');\n  }\n  /**\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\n   * Parse the body in\n   * Modifies in place res and return the result\n   */\n  static prepareResponse(res, format) {\n    const {\n      body\n    } = res;\n    let text;\n    if (format !== 'application/msgpack') {\n      text = body && new TextDecoder().decode(body) || '';\n    }\n    return new HTTPClientResponse({\n      ...res,\n      format,\n      text,\n      ok: Math.trunc(res.status / 100) === 2\n    });\n  }\n  /**\n   * Prepare an error with a response\n   * (the type of errors BaseHTTPClient are supposed to throw)\n   * by adding the status and preparing the internal response\n   * @private\n   */\n  static prepareResponseError(err) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(err.response, 'application/json');\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n  /**\n   * Send a GET request.\n   *\n   * @param options - The options to use for the request.\n   * @param options.relativePath - The path of the request.\n   * @param options.query - An object containing the query parameters of the request.\n   * @param options.requestHeaders - An object containing additional request headers to use.\n   *   or not.\n   * @param options.customOptions - An object containing additional options to pass to the\n   *   underlying BaseHTTPClient instance.\n   * @returns Response object.\n   */\n  async get({\n    relativePath,\n    query,\n    requestHeaders,\n    customOptions\n  }) {\n    const format = getAcceptFormat(query);\n    const fullHeaders = {\n      ...(requestHeaders ?? {}),\n      accept: format\n    };\n    try {\n      const res = await this.bc.get(relativePath, query ? removeFalsyOrEmpty(query) : undefined, fullHeaders, customOptions);\n      return HTTPClient.prepareResponse(res, format);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a POST request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   * @param options - The options to use for the request.\n   */\n  async post({\n    relativePath,\n    data,\n    query,\n    requestHeaders,\n    customOptions\n  }) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders ?? {})\n    };\n    try {\n      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders, customOptions);\n      return HTTPClient.prepareResponse(res, 'application/json');\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a DELETE request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   * @param options - The options to use for the request.\n   */\n  async delete({\n    relativePath,\n    data,\n    requestHeaders,\n    customOptions\n  }) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders ?? {})\n    };\n    try {\n      const res = await this.bc.delete(relativePath, typeof data !== 'undefined' ? HTTPClient.serializeData(data, fullHeaders) : undefined, undefined, fullHeaders, customOptions);\n      return HTTPClient.prepareResponse(res, 'application/json');\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n}","map":{"version":3,"names":["utils","URLTokenBaseHTTPClient","HTTPClientResponse","constructor","options","body","text","format","headers","status","ok","getJSONText","undefined","Error","parseBodyAsJSON","jsonOptions","HTTPClient","parseJSON","removeFalsyOrEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","tolowerCaseKeys","o","keys","reduce","c","k","toLowerCase","getAcceptFormat","query","bcOrTokenHeader","baseServer","port","defaultHeaders","bc","err_","err","rawResponse","statusCode","serializeData","data","requestHeaders","Uint8Array","TextEncoder","encode","stringifyJSON","prepareResponse","res","TextDecoder","decode","Math","trunc","prepareResponseError","response","get","relativePath","customOptions","fullHeaders","accept","post","delete"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\client\\client.ts"],"sourcesContent":["import * as utils from '../utils/utils.js';\nimport {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  Query,\n} from './baseHTTPClient.js';\nimport {\n  TokenHeader,\n  URLTokenBaseHTTPClient,\n} from './urlTokenBaseHTTPClient.js';\n\ninterface ErrorWithAdditionalInfo extends Error {\n  rawResponse: string | null;\n  statusCode: number;\n}\n\nexport class HTTPClientResponse {\n  /**\n   * The raw response bytes\n   */\n  body: Uint8Array;\n  /**\n   * If the expected response type is JSON, this is the response bytes converted to a string.\n   */\n  text?: string;\n  format: 'application/msgpack' | 'application/json';\n  headers: Record<string, string>;\n  status: number;\n  ok: boolean;\n\n  constructor(options: {\n    body: Uint8Array;\n    text?: string;\n    format: 'application/msgpack' | 'application/json';\n    headers: Record<string, string>;\n    status: number;\n    ok: boolean;\n  }) {\n    this.body = options.body;\n    this.text = options.text;\n    this.format = options.format;\n    this.headers = options.headers;\n    this.status = options.status;\n    this.ok = options.ok;\n  }\n\n  /**\n   * Returns the response body as a string, ready to be parsed as JSON.\n   */\n  getJSONText(): string {\n    if (this.text === undefined) {\n      throw new Error(\n        `Response body does not contain JSON data. Format is ${this.format}`\n      );\n    }\n    return this.text;\n  }\n\n  /**\n   * Parses the response body as JSON with the given options.\n   */\n  parseBodyAsJSON(jsonOptions: utils.ParseJSONOptions) {\n    if (this.text === undefined) {\n      throw new Error(\n        `Response body does not contain JSON data. Format is ${this.format}`\n      );\n    }\n    // eslint-disable-next-line no-use-before-define\n    return HTTPClient.parseJSON(this.text, this.status, jsonOptions);\n  }\n}\n\n/**\n * Remove falsy values or values with a length of 0 from an object.\n */\nfunction removeFalsyOrEmpty(obj: Record<string, any>) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n\n/**\n * Create a new object with lower-case keys\n * See https://codereview.stackexchange.com/a/162418\n * Used to ensure all headers are lower-case and to work more easily with them\n */\nfunction tolowerCaseKeys(o: Record<string, any>): Record<string, any> {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce(\n    (c, k) => ((c[k.toLowerCase()] = o[k]), c),\n    {} as Record<string, any>\n  );\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n\n/**\n * getAcceptFormat returns the correct Accept header depending on the\n * requested format.\n */\nfunction getAcceptFormat(\n  query?: Query<'msgpack' | 'json'>\n): 'application/msgpack' | 'application/json' {\n  if (\n    query !== undefined &&\n    Object.prototype.hasOwnProperty.call(query, 'format')\n  ) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n\n/**\n * HTTPClient is a wrapper around a BaseHTTPClient\n * It takes care of setting the proper \"Accept\" header and of\n * decoding the JSON outputs.\n */\nexport class HTTPClient {\n  private bc: BaseHTTPClient;\n\n  /**\n   * Construct an HTTPClient from a BaseHTTPClient\n   * @param bc - the BaseHTTPClient used\n   */\n  constructor(bc: BaseHTTPClient);\n  /**\n   * Construct an HTTPClient from a URL (baseServer+port) and a token\n   */\n  constructor(\n    tokenHeader: TokenHeader,\n    baseServer: string,\n    port?: string | number,\n    defaultHeaders?: Record<string, string>\n  );\n\n  constructor(\n    bcOrTokenHeader: BaseHTTPClient | TokenHeader,\n    baseServer?: string,\n    port?: string | number,\n    defaultHeaders: Record<string, string> = {}\n  ) {\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(\n        bcOrTokenHeader as TokenHeader,\n        baseServer,\n        port,\n        defaultHeaders\n      );\n    } else {\n      this.bc = bcOrTokenHeader as BaseHTTPClient;\n    }\n  }\n\n  /**\n   * Parse JSON using utils.parseJSON\n   *\n   * @param text - JSON data\n   * @param status - Status of the response (used in case parseJSON fails)\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   */\n  public static parseJSON(\n    text: string,\n    status: number,\n    jsonOptions: utils.ParseJSONOptions\n  ) {\n    try {\n      if (!text) {\n        return null;\n      }\n      return utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err = err_ as ErrorWithAdditionalInfo;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n\n  /**\n   * Serialize the data according to the requestHeaders\n   * Assumes that requestHeaders contain a key \"content-type\"\n   * If the content-type is \"application/json\", data is JSON serialized\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\n   * or an Uint8Array\n   * @private\n   */\n  private static serializeData(\n    data: object,\n    requestHeaders: Record<string, string>\n  ): Uint8Array {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new TextEncoder().encode(utils.stringifyJSON(data));\n    }\n    if (typeof data === 'string') {\n      return new TextEncoder().encode(data);\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error(\n      'provided data is neither a string nor a Uint8Array and content-type is not application/json'\n    );\n  }\n\n  /**\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\n   * Parse the body in\n   * Modifies in place res and return the result\n   */\n  private static prepareResponse(\n    res: BaseHTTPClientResponse,\n    format: 'application/msgpack' | 'application/json'\n  ): HTTPClientResponse {\n    const { body } = res;\n    let text: string | undefined;\n\n    if (format !== 'application/msgpack') {\n      text = (body && new TextDecoder().decode(body)) || '';\n    }\n\n    return new HTTPClientResponse({\n      ...res,\n      format,\n      text,\n      ok: Math.trunc(res.status / 100) === 2,\n    });\n  }\n\n  /**\n   * Prepare an error with a response\n   * (the type of errors BaseHTTPClient are supposed to throw)\n   * by adding the status and preparing the internal response\n   * @private\n   */\n  private static prepareResponseError(err: any) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(\n        err.response,\n        'application/json'\n      );\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n\n  /**\n   * Send a GET request.\n   *\n   * @param options - The options to use for the request.\n   * @param options.relativePath - The path of the request.\n   * @param options.query - An object containing the query parameters of the request.\n   * @param options.requestHeaders - An object containing additional request headers to use.\n   *   or not.\n   * @param options.customOptions - An object containing additional options to pass to the\n   *   underlying BaseHTTPClient instance.\n   * @returns Response object.\n   */\n  async get({\n    relativePath,\n    query,\n    requestHeaders,\n    customOptions,\n  }: {\n    relativePath: string;\n    query?: Query<any>;\n    requestHeaders?: Record<string, string>;\n    customOptions?: Record<string, unknown>;\n  }): Promise<HTTPClientResponse> {\n    const format = getAcceptFormat(query);\n    const fullHeaders = { ...(requestHeaders ?? {}), accept: format };\n\n    try {\n      const res = await this.bc.get(\n        relativePath,\n        query ? removeFalsyOrEmpty(query) : undefined,\n        fullHeaders,\n        customOptions\n      );\n\n      return HTTPClient.prepareResponse(res, format);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n\n  /**\n   * Send a POST request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   * @param options - The options to use for the request.\n   */\n  async post({\n    relativePath,\n    data,\n    query,\n    requestHeaders,\n    customOptions,\n  }: {\n    relativePath: string;\n    data: any;\n    query?: Query<any>;\n    requestHeaders?: Record<string, string>;\n    customOptions?: Record<string, unknown>;\n  }): Promise<HTTPClientResponse> {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders ?? {}),\n    };\n\n    try {\n      const res = await this.bc.post(\n        relativePath,\n        HTTPClient.serializeData(data, fullHeaders),\n        query,\n        fullHeaders,\n        customOptions\n      );\n\n      return HTTPClient.prepareResponse(res, 'application/json');\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n\n  /**\n   * Send a DELETE request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   * @param options - The options to use for the request.\n   */\n  async delete({\n    relativePath,\n    data,\n    requestHeaders,\n    customOptions,\n  }: {\n    relativePath: string;\n    data: any;\n    requestHeaders?: Record<string, string>;\n    customOptions?: Record<string, unknown>;\n  }) {\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders ?? {}),\n    };\n\n    try {\n      const res = await this.bc.delete(\n        relativePath,\n        typeof data !== 'undefined'\n          ? HTTPClient.serializeData(data, fullHeaders)\n          : undefined,\n        undefined,\n        fullHeaders,\n        customOptions\n      );\n\n      return HTTPClient.prepareResponse(res, 'application/json');\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}