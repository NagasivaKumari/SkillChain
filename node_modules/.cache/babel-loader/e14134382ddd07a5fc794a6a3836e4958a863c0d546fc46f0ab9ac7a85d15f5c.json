{"ast":null,"code":"import base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers.js';\nimport * as utils from '../utils/utils.js';\nimport { encodeUint64 } from './uint64.js';\nimport { bytesToHex } from './binarydata.js';\nexport const ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nexport const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nexport const ALGORAND_ADDRESS_LENGTH = 58;\nexport const ALGORAND_ZERO_ADDRESS_STRING = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nfunction checksumFromPublicKey(pk) {\n  return Uint8Array.from(nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH));\n}\n/**\n * Represents an Algorand address\n */\nexport class Address {\n  /**\n   * Create a new Address object from its binary form.\n   * @param publicKey - The binary form of the address. Must be 32 bytes.\n   */\n  constructor(publicKey) {\n    if (!(publicKey instanceof Uint8Array)) {\n      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`);\n    }\n    if (publicKey.length !== ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH) throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`);\n    this.publicKey = publicKey;\n  }\n  /**\n   * Check if the address is equal to another address.\n   */\n  equals(other) {\n    return other instanceof Address && utils.arrayEqual(this.publicKey, other.publicKey);\n  }\n  /**\n   * Compute the 4 byte checksum of the address.\n   */\n  checksum() {\n    return checksumFromPublicKey(this.publicKey);\n  }\n  /**\n   * Encode the address into a string form.\n   */\n  toString() {\n    const addr = base32.encode(utils.concatArrays(this.publicKey, this.checksum()));\n    return addr.slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n  }\n  /**\n   * Decode an address from a string.\n   * @param address - The address to decode. Must be 58 bytes long.\n   * @returns An Address object corresponding to the input string.\n   */\n  static fromString(address) {\n    if (typeof address !== 'string') throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`);\n    if (address.length !== ALGORAND_ADDRESS_LENGTH) throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`);\n    // try to decode\n    const decoded = base32.decode.asBytes(address);\n    // Sanity check\n    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`);\n    // Find publickey and checksum\n    const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n    const cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n    const checksum = checksumFromPublicKey(pk);\n    // Check if the checksum and the address are equal\n    if (!utils.arrayEqual(checksum, cs)) throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n    return new Address(pk);\n  }\n  /**\n   * Get the zero address.\n   */\n  static zeroAddress() {\n    return new Address(new Uint8Array(ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  }\n}\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n */\nexport function decodeAddress(address) {\n  return Address.fromString(address);\n}\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param address - an Algorand address with checksum.\n * @returns true if valid, false otherwise\n */\nexport function isValidAddress(address) {\n  // Try to decode\n  try {\n    Address.fromString(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param address - a raw Algorand address\n * @returns the address and checksum encoded as a string.\n */\nexport function encodeAddress(address) {\n  return new Address(address).toString();\n}\nconst APP_ID_PREFIX = new TextEncoder().encode('appID');\n/**\n * Get the escrow address of an application.\n * @param appID - The ID of the application.\n * @returns The address corresponding to that application's escrow account.\n */\nexport function getApplicationAddress(appID) {\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  const hash = nacl.genericHash(toBeSigned);\n  return new Address(Uint8Array.from(hash));\n}","map":{"version":3,"names":["base32","nacl","utils","encodeUint64","bytesToHex","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MALFORMED_ADDRESS_ERROR_MSG","CHECKSUM_ADDRESS_ERROR_MSG","checksumFromPublicKey","pk","Uint8Array","from","genericHash","slice","HASH_BYTES_LENGTH","Address","constructor","publicKey","Error","length","equals","other","arrayEqual","checksum","toString","addr","encode","concatArrays","fromString","address","decoded","decode","asBytes","cs","PUBLIC_KEY_LENGTH","zeroAddress","decodeAddress","isValidAddress","e","encodeAddress","APP_ID_PREFIX","TextEncoder","getApplicationAddress","appID","toBeSigned","hash"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\encoding\\address.ts"],"sourcesContent":["import base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers.js';\nimport * as utils from '../utils/utils.js';\nimport { encodeUint64 } from './uint64.js';\nimport { bytesToHex } from './binarydata.js';\n\nexport const ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nexport const ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nexport const ALGORAND_ADDRESS_LENGTH = 58;\nexport const ALGORAND_ZERO_ADDRESS_STRING =\n  'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\n\nfunction checksumFromPublicKey(pk: Uint8Array): Uint8Array {\n  return Uint8Array.from(\n    nacl\n      .genericHash(pk)\n      .slice(\n        nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH,\n        nacl.HASH_BYTES_LENGTH\n      )\n  );\n}\n\n/**\n * Represents an Algorand address\n */\nexport class Address {\n  /**\n   * The binary form of the address. For standard accounts, this is the public key.\n   */\n  public readonly publicKey: Uint8Array;\n\n  /**\n   * Create a new Address object from its binary form.\n   * @param publicKey - The binary form of the address. Must be 32 bytes.\n   */\n  constructor(publicKey: Uint8Array) {\n    if (!(publicKey instanceof Uint8Array)) {\n      throw new Error(\n        `${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`\n      );\n    }\n    if (\n      publicKey.length !==\n      ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\n    )\n      throw new Error(\n        `${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`\n      );\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Check if the address is equal to another address.\n   */\n  equals(other: Address): boolean {\n    return (\n      other instanceof Address &&\n      utils.arrayEqual(this.publicKey, other.publicKey)\n    );\n  }\n\n  /**\n   * Compute the 4 byte checksum of the address.\n   */\n  checksum(): Uint8Array {\n    return checksumFromPublicKey(this.publicKey);\n  }\n\n  /**\n   * Encode the address into a string form.\n   */\n  toString(): string {\n    const addr = base32.encode(\n      utils.concatArrays(this.publicKey, this.checksum())\n    );\n    return addr.slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n  }\n\n  /**\n   * Decode an address from a string.\n   * @param address - The address to decode. Must be 58 bytes long.\n   * @returns An Address object corresponding to the input string.\n   */\n  static fromString(address: string): Address {\n    if (typeof address !== 'string')\n      throw new Error(\n        `${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`\n      );\n    if (address.length !== ALGORAND_ADDRESS_LENGTH)\n      throw new Error(\n        `${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`\n      );\n\n    // try to decode\n    const decoded = base32.decode.asBytes(address);\n    // Sanity check\n    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)\n      throw new Error(\n        `${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`\n      );\n\n    // Find publickey and checksum\n    const pk = new Uint8Array(\n      decoded.slice(\n        0,\n        ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\n      )\n    );\n    const cs = new Uint8Array(\n      decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH)\n    );\n    const checksum = checksumFromPublicKey(pk);\n    // Check if the checksum and the address are equal\n    if (!utils.arrayEqual(checksum, cs))\n      throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n\n    return new Address(pk);\n  }\n\n  /**\n   * Get the zero address.\n   */\n  static zeroAddress(): Address {\n    return new Address(\n      new Uint8Array(\n        ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH\n      )\n    );\n  }\n}\n\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n */\nexport function decodeAddress(address: string): Address {\n  return Address.fromString(address);\n}\n\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param address - an Algorand address with checksum.\n * @returns true if valid, false otherwise\n */\nexport function isValidAddress(address: string): boolean {\n  // Try to decode\n  try {\n    Address.fromString(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param address - a raw Algorand address\n * @returns the address and checksum encoded as a string.\n */\nexport function encodeAddress(address: Uint8Array): string {\n  return new Address(address).toString();\n}\n\nconst APP_ID_PREFIX = new TextEncoder().encode('appID');\n\n/**\n * Get the escrow address of an application.\n * @param appID - The ID of the application.\n * @returns The address corresponding to that application's escrow account.\n */\nexport function getApplicationAddress(appID: number | bigint): Address {\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  const hash = nacl.genericHash(toBeSigned);\n  return new Address(Uint8Array.from(hash));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}