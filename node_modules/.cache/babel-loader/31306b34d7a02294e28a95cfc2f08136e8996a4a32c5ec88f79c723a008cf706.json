{"ast":null,"code":"import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport * as convert from './convert.js';\nimport * as utils from './utils/utils.js';\nconst SIGN_BYTES_PREFIX = Uint8Array.from([77, 88]); // \"MX\"\n// Errors\nexport const MULTISIG_BAD_SENDER_ERROR_MSG = 'The transaction sender address and multisig preimage do not match.';\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstValid, lastValid, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstValid, lastValid, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn - object with either payment or key registration fields\n * @param sk - Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nexport function signTransaction(txn, sk) {\n  return {\n    txID: txn.txID(),\n    blob: txn.signTxn(sk)\n  };\n}\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes - Uint8array\n * @param sk - Algorand secret key\n * @returns binary signature\n */\nexport function signBytes(bytes, sk) {\n  const toBeSigned = utils.concatArrays(SIGN_BYTES_PREFIX, bytes);\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes - Uint8Array\n * @param signature - binary signature\n * @param addr - string address\n * @returns bool\n */\nexport function verifyBytes(bytes, signature, addr) {\n  const toBeVerified = utils.concatArrays(SIGN_BYTES_PREFIX, bytes);\n  const addrObj = typeof addr === 'string' ? Address.fromString(addr) : addr;\n  return nacl.verify(toBeVerified, signature, addrObj.publicKey);\n}\nexport const ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);\nexport const ERROR_INVALID_MICROALGOS = new Error(convert.INVALID_MICROALGOS_ERROR_MSG);\nexport { AlgodClient as Algodv2 } from './client/v2/algod/algod.js';\nexport { KmdClient as Kmd } from './client/kmd.js';\nexport { default as IntDecoding } from './types/intDecoding.js';\nexport { IndexerClient as Indexer } from './client/v2/indexer/indexer.js';\nexport { waitForConfirmation } from './wait.js';\nexport { encodeObj, decodeObj, msgpackRawEncode, msgpackRawDecode, msgpackRawDecodeAsMap, encodeMsgpack, decodeMsgpack, encodeJSON, decodeJSON } from './encoding/encoding.js';\nexport { Address, isValidAddress, encodeAddress, decodeAddress, getApplicationAddress, ALGORAND_ZERO_ADDRESS_STRING } from './encoding/address.js';\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint.js';\nexport { base64ToBytes, bytesToBase64, bytesToString, coerceToBytes, bytesToHex, hexToBytes } from './encoding/binarydata.js';\nexport { encodeUint64, decodeUint64 } from './encoding/uint64.js';\nexport { parseJSON, stringifyJSON } from './utils/utils.js';\nexport { default as generateAccount } from './account.js';\nexport * from './types/block.js';\nexport * from './types/statedelta.js';\nexport * from './stateproof.js';\nexport { UntypedValue } from './client/v2/untypedmodel.js';\nimport * as modelsv2_1 from './client/v2/algod/models/types.js';\nexport { modelsv2_1 as modelsv2 };\nimport * as indexerModels_1 from './client/v2/indexer/models/types.js';\nexport { indexerModels_1 as indexerModels };\nexport { mnemonicToMasterDerivationKey, masterDerivationKeyToMnemonic, secretKeyToMnemonic, mnemonicToSecretKey, seedFromMnemonic, mnemonicFromSeed } from './mnemonic/mnemonic.js';\nexport { microalgosToAlgos, algosToMicroalgos, INVALID_MICROALGOS_ERROR_MSG } from './convert.js';\nexport { computeGroupID, assignGroupID } from './group.js';\nexport { SignedTransaction, decodeSignedTransaction, encodeUnsignedSimulateTransaction } from './signedTransaction.js';\nexport { signLogicSigTransaction, signLogicSigTransactionObject } from './signing.js';\nexport { LogicSig, LogicSigAccount, logicSigFromByte, tealSign, tealSignFromProgram, verifyTealSign } from './logicsig.js';\nexport { verifyMultisig, multisigAddress } from './multisig.js';\nexport { signMultisigTransaction, mergeMultisigTransactions, appendSignMultisigTransaction, createMultisigTransaction, appendSignRawMultisigSignature } from './multisigSigning.js';\nexport { ProgramSourceMap } from './logic/sourcemap.js';\nexport * from './dryrun.js';\nexport * from './makeTxn.js';\nexport * from './transaction.js';\nexport * from './signer.js';\nexport * from './composer.js';\nexport * from './types/transactions/index.js';\nexport * from './abi/index.js';","map":{"version":3,"names":["nacl","Address","convert","utils","SIGN_BYTES_PREFIX","Uint8Array","from","MULTISIG_BAD_SENDER_ERROR_MSG","signTransaction","txn","sk","txID","blob","signTxn","signBytes","bytes","toBeSigned","concatArrays","sig","sign","verifyBytes","signature","addr","toBeVerified","addrObj","fromString","verify","publicKey","ERROR_MULTISIG_BAD_SENDER","Error","ERROR_INVALID_MICROALGOS","INVALID_MICROALGOS_ERROR_MSG","AlgodClient","Algodv2","KmdClient","Kmd","default","IntDecoding","IndexerClient","Indexer","waitForConfirmation","encodeObj","decodeObj","msgpackRawEncode","msgpackRawDecode","msgpackRawDecodeAsMap","encodeMsgpack","decodeMsgpack","encodeJSON","decodeJSON","isValidAddress","encodeAddress","decodeAddress","getApplicationAddress","ALGORAND_ZERO_ADDRESS_STRING","bytesToBigInt","bigIntToBytes","base64ToBytes","bytesToBase64","bytesToString","coerceToBytes","bytesToHex","hexToBytes","encodeUint64","decodeUint64","parseJSON","stringifyJSON","generateAccount","UntypedValue","modelsv2","indexerModels","mnemonicToMasterDerivationKey","masterDerivationKeyToMnemonic","secretKeyToMnemonic","mnemonicToSecretKey","seedFromMnemonic","mnemonicFromSeed","microalgosToAlgos","algosToMicroalgos","computeGroupID","assignGroupID","SignedTransaction","decodeSignedTransaction","encodeUnsignedSimulateTransaction","signLogicSigTransaction","signLogicSigTransactionObject","LogicSig","LogicSigAccount","logicSigFromByte","tealSign","tealSignFromProgram","verifyTealSign","verifyMultisig","multisigAddress","signMultisigTransaction","mergeMultisigTransactions","appendSignMultisigTransaction","createMultisigTransaction","appendSignRawMultisigSignature","ProgramSourceMap"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\main.ts"],"sourcesContent":["import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport { Transaction } from './transaction.js';\nimport * as convert from './convert.js';\nimport * as utils from './utils/utils.js';\n\nconst SIGN_BYTES_PREFIX = Uint8Array.from([77, 88]); // \"MX\"\n\n// Errors\nexport const MULTISIG_BAD_SENDER_ERROR_MSG =\n  'The transaction sender address and multisig preimage do not match.';\n\n/**\n * signTransaction takes an object with either payment or key registration fields and\n * a secret key and returns a signed blob.\n *\n * Payment transaction fields: from, to, amount, fee, firstValid, lastValid, genesisHash,\n * note(optional), GenesisID(optional), closeRemainderTo(optional)\n *\n * Key registration fields: fee, firstValid, lastValid, voteKey, selectionKey, voteFirst,\n * voteLast, voteKeyDilution, genesisHash, note(optional), GenesisID(optional)\n *\n * If flatFee is not set and the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n * @param txn - object with either payment or key registration fields\n * @param sk - Algorand Secret Key\n * @returns object contains the binary signed transaction and its txID\n */\nexport function signTransaction(txn: Transaction, sk: Uint8Array) {\n  return {\n    txID: txn.txID(),\n    blob: txn.signTxn(sk),\n  };\n}\n\n/**\n * signBytes takes arbitrary bytes and a secret key, prepends the bytes with \"MX\" for domain separation, signs the bytes\n * with the private key, and returns the signature.\n * @param bytes - Uint8array\n * @param sk - Algorand secret key\n * @returns binary signature\n */\nexport function signBytes(bytes: Uint8Array, sk: Uint8Array) {\n  const toBeSigned = utils.concatArrays(SIGN_BYTES_PREFIX, bytes);\n  const sig = nacl.sign(toBeSigned, sk);\n  return sig;\n}\n\n/**\n * verifyBytes takes array of bytes, an address, and a signature and verifies if the signature is correct for the public\n * key and the bytes (the bytes should have been signed with \"MX\" prepended for domain separation).\n * @param bytes - Uint8Array\n * @param signature - binary signature\n * @param addr - string address\n * @returns bool\n */\nexport function verifyBytes(\n  bytes: Uint8Array,\n  signature: Uint8Array,\n  addr: string | Address\n) {\n  const toBeVerified = utils.concatArrays(SIGN_BYTES_PREFIX, bytes);\n  const addrObj = typeof addr === 'string' ? Address.fromString(addr) : addr;\n  return nacl.verify(toBeVerified, signature, addrObj.publicKey);\n}\n\nexport const ERROR_MULTISIG_BAD_SENDER = new Error(\n  MULTISIG_BAD_SENDER_ERROR_MSG\n);\nexport const ERROR_INVALID_MICROALGOS = new Error(\n  convert.INVALID_MICROALGOS_ERROR_MSG\n);\n\nexport { AlgodClient as Algodv2 } from './client/v2/algod/algod.js';\nexport { KmdClient as Kmd } from './client/kmd.js';\nexport { default as IntDecoding } from './types/intDecoding.js';\nexport { default as Account } from './types/account.js';\nexport { IndexerClient as Indexer } from './client/v2/indexer/indexer.js';\nexport {\n  BaseHTTPClient,\n  BaseHTTPClientResponse,\n  BaseHTTPClientError,\n} from './client/baseHTTPClient.js';\nexport {\n  AlgodTokenHeader,\n  IndexerTokenHeader,\n  KMDTokenHeader,\n  CustomTokenHeader,\n  TokenHeader,\n} from './client/urlTokenBaseHTTPClient.js';\nexport { waitForConfirmation } from './wait.js';\nexport {\n  MsgpackEncodingData,\n  JSONEncodingData,\n  Encodable,\n  EncodableClass,\n  encodeObj,\n  decodeObj,\n  msgpackRawEncode,\n  msgpackRawDecode,\n  msgpackRawDecodeAsMap,\n  encodeMsgpack,\n  decodeMsgpack,\n  encodeJSON,\n  decodeJSON,\n} from './encoding/encoding.js';\nexport {\n  Address,\n  isValidAddress,\n  encodeAddress,\n  decodeAddress,\n  getApplicationAddress,\n  ALGORAND_ZERO_ADDRESS_STRING,\n} from './encoding/address.js';\nexport { bytesToBigInt, bigIntToBytes } from './encoding/bigint.js';\nexport {\n  base64ToBytes,\n  bytesToBase64,\n  bytesToString,\n  coerceToBytes,\n  bytesToHex,\n  hexToBytes,\n} from './encoding/binarydata.js';\nexport { encodeUint64, decodeUint64 } from './encoding/uint64.js';\nexport { parseJSON, ParseJSONOptions, stringifyJSON } from './utils/utils.js';\nexport { default as generateAccount } from './account.js';\nexport * from './types/block.js';\nexport * from './types/statedelta.js';\nexport * from './stateproof.js';\nexport { UntypedValue } from './client/v2/untypedmodel.js';\nexport * as modelsv2 from './client/v2/algod/models/types.js';\nexport * as indexerModels from './client/v2/indexer/models/types.js';\nexport {\n  mnemonicToMasterDerivationKey,\n  masterDerivationKeyToMnemonic,\n  secretKeyToMnemonic,\n  mnemonicToSecretKey,\n  seedFromMnemonic,\n  mnemonicFromSeed,\n} from './mnemonic/mnemonic.js';\nexport {\n  microalgosToAlgos,\n  algosToMicroalgos,\n  INVALID_MICROALGOS_ERROR_MSG,\n} from './convert.js';\nexport { computeGroupID, assignGroupID } from './group.js';\nexport {\n  SignedTransaction,\n  decodeSignedTransaction,\n  encodeUnsignedSimulateTransaction,\n} from './signedTransaction.js';\nexport {\n  signLogicSigTransaction,\n  signLogicSigTransactionObject,\n} from './signing.js';\nexport {\n  LogicSig,\n  LogicSigAccount,\n  logicSigFromByte,\n  tealSign,\n  tealSignFromProgram,\n  verifyTealSign,\n} from './logicsig.js';\nexport {\n  MultisigMetadata,\n  verifyMultisig,\n  multisigAddress,\n} from './multisig.js';\nexport {\n  signMultisigTransaction,\n  mergeMultisigTransactions,\n  appendSignMultisigTransaction,\n  createMultisigTransaction,\n  appendSignRawMultisigSignature,\n} from './multisigSigning.js';\nexport {\n  ProgramSourceMap,\n  SourceLocation,\n  PcLineLocation,\n} from './logic/sourcemap.js';\n\nexport * from './dryrun.js';\nexport * from './makeTxn.js';\nexport * from './transaction.js';\nexport * from './signer.js';\nexport * from './composer.js';\nexport * from './types/transactions/index.js';\nexport * from './abi/index.js';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}