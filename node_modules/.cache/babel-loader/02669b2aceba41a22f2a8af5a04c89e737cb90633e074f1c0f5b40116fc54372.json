{"ast":null,"code":"// Integer Utility\n/**\n * An enum of different options for decoding integers.\n */\nexport var IntMode;\n(function (IntMode) {\n  /**\n   * Always returns the value as a number. Be aware that there will be a loss of precision if the\n   * value is outside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  IntMode[IntMode[\"UNSAFE_NUMBER\"] = 0] = \"UNSAFE_NUMBER\";\n  /**\n   * Always returns the value as a number, but throws an error if the value is outside of the range\n   * of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  IntMode[IntMode[\"SAFE_NUMBER\"] = 1] = \"SAFE_NUMBER\";\n  /**\n   * Returns all values encoded as int64/uint64 as bigints and all other integers as numbers.\n   */\n  IntMode[IntMode[\"AS_ENCODED\"] = 2] = \"AS_ENCODED\";\n  /**\n   * Returns all values inside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER as\n   * numbers and all values outside that range as bigints.\n   */\n  IntMode[IntMode[\"MIXED\"] = 3] = \"MIXED\";\n  /**\n   * Always returns the value as a bigint, even if it is small enough to safely fit in a number.\n   */\n  IntMode[IntMode[\"BIGINT\"] = 4] = \"BIGINT\";\n})(IntMode || (IntMode = {}));\nexport var UINT32_MAX = 4294967295;\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\nexport function setUint64(view, offset, value) {\n  var high = value / 4294967296;\n  var low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\nexport function setInt64(view, offset, value) {\n  var high = Math.floor(value / 4294967296);\n  var low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\nexport function getInt64(view, offset, mode) {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigInt64 if the user hasn't told us to use BigInts\n    var high = view.getInt32(offset);\n    var low = view.getUint32(offset + 4);\n    if (mode === IntMode.SAFE_NUMBER && (high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0 || high > (Number.MAX_SAFE_INTEGER - low) / 4294967296)) {\n      var hexValue = \"\".concat(high < 0 ? \"-\" : \"\", \"0x\").concat(Math.abs(high).toString(16)).concat(low.toString(16).padStart(8, \"0\"));\n      throw new Error(\"Mode is IntMode.SAFE_NUMBER and value is not a safe integer: \".concat(hexValue));\n    }\n    return high * 4294967296 + low;\n  }\n  var value = view.getBigInt64(offset);\n  if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  return value;\n}\nexport function getUint64(view, offset, mode) {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigUint64 if the user hasn't told us to use BigInts\n    var high = view.getUint32(offset);\n    var low = view.getUint32(offset + 4);\n    if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 4294967296) {\n      var hexValue = \"0x\".concat(high.toString(16)).concat(low.toString(16).padStart(8, \"0\"));\n      throw new Error(\"Mode is IntMode.SAFE_NUMBER and value is not a safe integer: \".concat(hexValue));\n    }\n    return high * 4294967296 + low;\n  }\n  var value = view.getBigUint64(offset);\n  if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n  return value;\n}\n/**\n * Convert a safe integer Number (i.e. in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER)\n * with respect to the given IntMode. For all modes except IntMode.BIGINT, this returns the original\n * Number unmodified.\n */\nexport function convertSafeIntegerToMode(value, mode) {\n  if (mode === IntMode.BIGINT) {\n    return BigInt(value);\n  }\n  return Number(value);\n}","map":{"version":3,"names":["IntMode","UINT32_MAX","setUint64","view","offset","value","high","low","setUint32","setInt64","Math","floor","getInt64","mode","UNSAFE_NUMBER","SAFE_NUMBER","getInt32","getUint32","Number","MIN_SAFE_INTEGER","MAX_SAFE_INTEGER","hexValue","concat","abs","toString","padStart","Error","getBigInt64","MIXED","getUint64","getBigUint64","convertSafeIntegerToMode","BIGINT","BigInt"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algorand-msgpack\\src\\utils\\int.ts"],"sourcesContent":["// Integer Utility\n\n/**\n * An enum of different options for decoding integers.\n */\nexport enum IntMode {\n  /**\n   * Always returns the value as a number. Be aware that there will be a loss of precision if the\n   * value is outside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  UNSAFE_NUMBER,\n  /**\n   * Always returns the value as a number, but throws an error if the value is outside of the range\n   * of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER.\n   */\n  SAFE_NUMBER,\n  /**\n   * Returns all values encoded as int64/uint64 as bigints and all other integers as numbers.\n   */\n  AS_ENCODED,\n  /**\n   * Returns all values inside the range of Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER as\n   * numbers and all values outside that range as bigints.\n   */\n  MIXED,\n  /**\n   * Always returns the value as a bigint, even if it is small enough to safely fit in a number.\n   */\n  BIGINT,\n}\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number, mode: IntMode.UNSAFE_NUMBER | IntMode.SAFE_NUMBER): number;\nexport function getInt64(view: DataView, offset: number, mode: IntMode.BIGINT): bigint;\nexport function getInt64(view: DataView, offset: number, mode: IntMode): number | bigint;\nexport function getInt64(view: DataView, offset: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigInt64 if the user hasn't told us to use BigInts\n    const high = view.getInt32(offset);\n    const low = view.getUint32(offset + 4);\n\n    if (\n      mode === IntMode.SAFE_NUMBER &&\n      (high < Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) ||\n        (high === Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) && low === 0) ||\n        high > (Number.MAX_SAFE_INTEGER - low) / 0x1_0000_0000)\n    ) {\n      const hexValue = `${high < 0 ? \"-\" : \"\"}0x${Math.abs(high).toString(16)}${low.toString(16).padStart(8, \"0\")}`;\n      throw new Error(`Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ${hexValue}`);\n    }\n\n    return high * 0x1_0000_0000 + low;\n  }\n\n  const value = view.getBigInt64(offset);\n\n  if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n\n  return value;\n}\n\nexport function getUint64(view: DataView, offset: number, mode: IntMode.UNSAFE_NUMBER | IntMode.SAFE_NUMBER): number;\nexport function getUint64(view: DataView, offset: number, mode: IntMode.BIGINT): bigint;\nexport function getUint64(view: DataView, offset: number, mode: IntMode): number | bigint;\nexport function getUint64(view: DataView, offset: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {\n    // for compatibility, don't use view.getBigUint64 if the user hasn't told us to use BigInts\n    const high = view.getUint32(offset);\n    const low = view.getUint32(offset + 4);\n\n    if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 0x1_0000_0000) {\n      const hexValue = `0x${high.toString(16)}${low.toString(16).padStart(8, \"0\")}`;\n      throw new Error(`Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ${hexValue}`);\n    }\n\n    return high * 0x1_0000_0000 + low;\n  }\n\n  const value = view.getBigUint64(offset);\n\n  if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value);\n  }\n\n  return value;\n}\n\n/**\n * Convert a safe integer Number (i.e. in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER)\n * with respect to the given IntMode. For all modes except IntMode.BIGINT, this returns the original\n * Number unmodified.\n */\nexport function convertSafeIntegerToMode(value: number, mode: IntMode): number | bigint {\n  if (mode === IntMode.BIGINT) {\n    return BigInt(value);\n  }\n\n  return Number(value);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}