{"ast":null,"code":"export function utf8Count(str) {\n  var strLength = str.length;\n  var byteLength = 0;\n  var pos = 0;\n  while (pos < strLength) {\n    var value = str.charCodeAt(pos++);\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          var extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\nexport function utf8EncodeJs(str, output, outputOffset) {\n  var strLength = str.length;\n  var offset = outputOffset;\n  var pos = 0;\n  while (pos < strLength) {\n    var value = str.charCodeAt(pos++);\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = value >> 6 & 0x1f | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          var extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = value >> 12 & 0x0f | 0xe0;\n        output[offset++] = value >> 6 & 0x3f | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = value >> 18 & 0x07 | 0xf0;\n        output[offset++] = value >> 12 & 0x3f | 0x80;\n        output[offset++] = value >> 6 & 0x3f | 0x80;\n      }\n    }\n    output[offset++] = value & 0x3f | 0x80;\n  }\n}\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\nvar sharedTextEncoder = new TextEncoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nvar TEXT_ENCODER_THRESHOLD = 50;\nexport function utf8EncodeTE(str, output, outputOffset) {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\nexport function utf8Encode(str, output, outputOffset) {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\nvar CHUNK_SIZE = 4096;\nexport function utf8DecodeJs(bytes, inputOffset, byteLength) {\n  var offset = inputOffset;\n  var end = offset + byteLength;\n  var units = [];\n  var result = \"\";\n  while (offset < end) {\n    var byte1 = bytes[offset++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      units.push((byte1 & 0x1f) << 6 | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      var byte3 = bytes[offset++] & 0x3f;\n      units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      var byte2 = bytes[offset++] & 0x3f;\n      var byte3 = bytes[offset++] & 0x3f;\n      var byte4 = bytes[offset++] & 0x3f;\n      var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(unit >>> 10 & 0x3ff | 0xd800);\n        unit = 0xdc00 | unit & 0x3ff;\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode.apply(String, units);\n      units.length = 0;\n    }\n  }\n  if (units.length > 0) {\n    result += String.fromCharCode.apply(String, units);\n  }\n  return result;\n}\nvar sharedTextDecoder = new TextDecoder();\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nvar TEXT_DECODER_THRESHOLD = 200;\nexport function utf8DecodeTD(bytes, inputOffset, byteLength) {\n  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\nexport function utf8Decode(bytes, inputOffset, byteLength) {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}","map":{"version":3,"names":["utf8Count","str","strLength","length","byteLength","pos","value","charCodeAt","extra","utf8EncodeJs","output","outputOffset","offset","sharedTextEncoder","TextEncoder","TEXT_ENCODER_THRESHOLD","utf8EncodeTE","encodeInto","subarray","utf8Encode","CHUNK_SIZE","utf8DecodeJs","bytes","inputOffset","end","units","result","byte1","push","byte2","byte3","byte4","unit","String","fromCharCode","apply","sharedTextDecoder","TextDecoder","TEXT_DECODER_THRESHOLD","utf8DecodeTD","stringBytes","decode","utf8Decode"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algorand-msgpack\\src\\utils\\utf8.ts"],"sourcesContent":["export function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}