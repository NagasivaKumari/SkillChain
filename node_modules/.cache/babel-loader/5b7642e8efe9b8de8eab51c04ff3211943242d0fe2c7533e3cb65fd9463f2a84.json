{"ast":null,"code":"/**\n * Wait until a transaction has been confirmed or rejected by the network, or\n * until 'waitRounds' number of rounds have passed.\n * @param client - An Algodv2 client\n * @param txid - The ID of the transaction to wait for.\n * @param waitRounds - The maximum number of rounds to wait for.\n * @returns A promise that, upon success, will resolve to the output of the\n *   `pendingTransactionInformation` call for the confirmed transaction.\n */\nexport async function waitForConfirmation(client, txid, waitRounds) {\n  // Wait until the transaction is confirmed or rejected, or until 'waitRounds'\n  // number of rounds have passed.\n  const status = await client.status().do();\n  if (typeof status === 'undefined') {\n    throw new Error('Unable to get node status');\n  }\n  const startRound = status.lastRound + BigInt(1);\n  const stopRound = startRound + BigInt(waitRounds);\n  let currentRound = startRound;\n  /* eslint-disable no-await-in-loop */\n  while (currentRound < stopRound) {\n    let poolError = false;\n    try {\n      const pendingInfo = await client.pendingTransactionInformation(txid).do();\n      if (pendingInfo.confirmedRound) {\n        // Got the completed Transaction\n        return pendingInfo;\n      }\n      if (pendingInfo.poolError) {\n        // If there was a pool error, then the transaction has been rejected\n        poolError = true;\n        throw new Error(`Transaction Rejected: ${pendingInfo.poolError}`);\n      }\n    } catch (err) {\n      // Ignore errors from PendingTransactionInformation, since it may return 404 if the algod\n      // instance is behind a load balancer and the request goes to a different algod than the\n      // one we submitted the transaction to\n      if (poolError) {\n        // Rethrow error only if it's because the transaction was rejected\n        throw err;\n      }\n    }\n    await client.statusAfterBlock(currentRound).do();\n    currentRound += BigInt(1);\n  }\n  /* eslint-enable no-await-in-loop */\n  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);\n}","map":{"version":3,"names":["waitForConfirmation","client","txid","waitRounds","status","do","Error","startRound","lastRound","BigInt","stopRound","currentRound","poolError","pendingInfo","pendingTransactionInformation","confirmedRound","err","statusAfterBlock"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\wait.ts"],"sourcesContent":["import { AlgodClient } from './client/v2/algod/algod.js';\nimport { PendingTransactionResponse } from './client/v2/algod/models/types.js';\n\n/**\n * Wait until a transaction has been confirmed or rejected by the network, or\n * until 'waitRounds' number of rounds have passed.\n * @param client - An Algodv2 client\n * @param txid - The ID of the transaction to wait for.\n * @param waitRounds - The maximum number of rounds to wait for.\n * @returns A promise that, upon success, will resolve to the output of the\n *   `pendingTransactionInformation` call for the confirmed transaction.\n */\nexport async function waitForConfirmation(\n  client: AlgodClient,\n  txid: string,\n  waitRounds: number\n): Promise<PendingTransactionResponse> {\n  // Wait until the transaction is confirmed or rejected, or until 'waitRounds'\n  // number of rounds have passed.\n\n  const status = await client.status().do();\n  if (typeof status === 'undefined') {\n    throw new Error('Unable to get node status');\n  }\n  const startRound = status.lastRound + BigInt(1);\n  const stopRound = startRound + BigInt(waitRounds);\n  let currentRound = startRound;\n\n  /* eslint-disable no-await-in-loop */\n  while (currentRound < stopRound) {\n    let poolError = false;\n    try {\n      const pendingInfo = await client.pendingTransactionInformation(txid).do();\n\n      if (pendingInfo.confirmedRound) {\n        // Got the completed Transaction\n        return pendingInfo;\n      }\n\n      if (pendingInfo.poolError) {\n        // If there was a pool error, then the transaction has been rejected\n        poolError = true;\n        throw new Error(`Transaction Rejected: ${pendingInfo.poolError}`);\n      }\n    } catch (err) {\n      // Ignore errors from PendingTransactionInformation, since it may return 404 if the algod\n      // instance is behind a load balancer and the request goes to a different algod than the\n      // one we submitted the transaction to\n      if (poolError) {\n        // Rethrow error only if it's because the transaction was rejected\n        throw err;\n      }\n    }\n\n    await client.statusAfterBlock(currentRound).do();\n    currentRound += BigInt(1);\n  }\n  /* eslint-enable no-await-in-loop */\n  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);\n}\n"],"mappings":"AAGA;;;;;;;;;AASA,OAAO,eAAeA,mBAAmBA,CACvCC,MAAmB,EACnBC,IAAY,EACZC,UAAkB;EAElB;EACA;EAEA,MAAMC,MAAM,GAAG,MAAMH,MAAM,CAACG,MAAM,EAAE,CAACC,EAAE,EAAE;EACzC,IAAI,OAAOD,MAAM,KAAK,WAAW,EAAE;IACjC,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EACA,MAAMC,UAAU,GAAGH,MAAM,CAACI,SAAS,GAAGC,MAAM,CAAC,CAAC,CAAC;EAC/C,MAAMC,SAAS,GAAGH,UAAU,GAAGE,MAAM,CAACN,UAAU,CAAC;EACjD,IAAIQ,YAAY,GAAGJ,UAAU;EAE7B;EACA,OAAOI,YAAY,GAAGD,SAAS,EAAE;IAC/B,IAAIE,SAAS,GAAG,KAAK;IACrB,IAAI;MACF,MAAMC,WAAW,GAAG,MAAMZ,MAAM,CAACa,6BAA6B,CAACZ,IAAI,CAAC,CAACG,EAAE,EAAE;MAEzE,IAAIQ,WAAW,CAACE,cAAc,EAAE;QAC9B;QACA,OAAOF,WAAW;MACpB;MAEA,IAAIA,WAAW,CAACD,SAAS,EAAE;QACzB;QACAA,SAAS,GAAG,IAAI;QAChB,MAAM,IAAIN,KAAK,CAAC,yBAAyBO,WAAW,CAACD,SAAS,EAAE,CAAC;MACnE;IACF,CAAC,CAAC,OAAOI,GAAG,EAAE;MACZ;MACA;MACA;MACA,IAAIJ,SAAS,EAAE;QACb;QACA,MAAMI,GAAG;MACX;IACF;IAEA,MAAMf,MAAM,CAACgB,gBAAgB,CAACN,YAAY,CAAC,CAACN,EAAE,EAAE;IAChDM,YAAY,IAAIF,MAAM,CAAC,CAAC,CAAC;EAC3B;EACA;EACA,MAAM,IAAIH,KAAK,CAAC,mCAAmCH,UAAU,SAAS,CAAC;AACzE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}