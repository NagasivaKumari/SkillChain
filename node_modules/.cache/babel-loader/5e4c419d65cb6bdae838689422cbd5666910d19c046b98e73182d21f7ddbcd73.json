{"ast":null,"code":"import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport * as utils from './utils/utils.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport { addressFromMultisigPreImg, pksFromAddresses } from './multisig.js';\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}) {\n  // construct the appendable multisigned transaction format\n  const pks = pksFromAddresses(addrs);\n  const subsigs = pks.map(pk => ({\n    pk\n  }));\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = addressFromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  let sgnr;\n  if (!txn.sender.equals(msigAddr)) {\n    sgnr = msigAddr;\n  }\n  const signedTxn = new SignedTransaction({\n    txn,\n    msig,\n    sgnr\n  });\n  return encoding.encodeMsgpack(signedTxn);\n}\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Uint8Array raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(txn, {\n  rawSig,\n  myPk\n}, {\n  version,\n  threshold,\n  pks\n}) {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map(pk => new Address(pk))\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decodeMsgpack(encodedMsig, SignedTransaction);\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (!keyExist) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  return encoding.encodeMsgpack(signedTxn);\n}\n/**\n * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n * encoded with msgpack as a typed array.\n * @param transaction - The transaction to sign\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - multisig public key list, order is important.\n * @param sk - an Algorand secret key to sign with.\n * @returns an encoded, partially signed multisig transaction.\n */\nfunction partialSignTxn(transaction, {\n  version,\n  threshold,\n  pks\n}, sk) {\n  // get signature verifier\n  const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n  return createMultisigTransactionWithSignature(transaction, {\n    rawSig: transaction.rawSignTxn(sk),\n    myPk\n  }, {\n    version,\n    threshold,\n    pks\n  });\n}\n/**\n * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n * @param transaction - The transaction to sign\n * @param metadata - multisig metadata\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns an encoded, partially signed multisig transaction.\n */\nfunction partialSignWithMultisigSignature(transaction, metadata, signerAddr, signature) {\n  if (!nacl.isValidSignatureLength(signature.length)) {\n    throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n  }\n  const signerAddressObj = typeof signerAddr === 'string' ? Address.fromString(signerAddr) : signerAddr;\n  return createMultisigTransactionWithSignature(transaction, {\n    rawSig: signature,\n    myPk: signerAddressObj.publicKey\n  }, metadata);\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decodeMsgpack(multisigTxnBlobs[0], SignedTransaction);\n  if (!refSigTx.msig) {\n    throw new Error('Invalid multisig transaction, multisig structure missing at index 0');\n  }\n  const refTxID = refSigTx.txn.txID();\n  const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(subsig => subsig.pk)\n  };\n  const refMsigAddr = addressFromMultisigPreImg(refPreImage);\n  const newSubsigs = refSigTx.msig.subsig.map(sig => ({\n    ...sig\n  }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decodeMsgpack(multisigTxnBlobs[i], SignedTransaction);\n    if (!unisig.msig) {\n      throw new Error(`Invalid multisig transaction, multisig structure missing at index ${i}`);\n    }\n    if (unisig.txn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    const authAddr = unisig.sgnr ? unisig.sgnr.toString() : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n    const msgigAddr = addressFromMultisigPreImg(preimg);\n    if (!refMsigAddr.equals(msgigAddr)) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      if (current.s && !utils.arrayEqual(uniSubsig.s, current.s)) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const refSgnr = typeof refAuthAddr !== 'undefined' ? refSigTx.sgnr : undefined;\n  const signedTxn = new SignedTransaction({\n    msig,\n    txn: refSigTx.txn,\n    sgnr: refSgnr\n  });\n  return encoding.encodeMsgpack(signedTxn);\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(txn, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  // build pks for partialSign\n  const pks = pksFromAddresses(addrs);\n  const blob = partialSignTxn(txn, {\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: txn.txID(),\n    blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, sk) {\n  const pks = pksFromAddresses(addrs);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decodeMsgpack(multisigTxnBlob, SignedTransaction);\n  const partialSignedBlob = partialSignTxn(multisigTxObj.txn, {\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: multisigTxObj.txn.txID(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, {\n  version,\n  threshold,\n  addrs\n}, signerAddr, signature) {\n  const pks = pksFromAddresses(addrs);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decodeMsgpack(multisigTxnBlob, SignedTransaction);\n  const partialSignedBlob = partialSignWithMultisigSignature(multisigTxObj.txn, {\n    version,\n    threshold,\n    pks\n  }, signerAddr, signature);\n  return {\n    txID: multisigTxObj.txn.txID(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}","map":{"version":3,"names":["nacl","Address","encoding","utils","SignedTransaction","addressFromMultisigPreImg","pksFromAddresses","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","createMultisigTransaction","txn","version","threshold","addrs","pks","subsigs","map","pk","msig","v","thr","subsig","msigAddr","sgnr","sender","equals","signedTxn","encodeMsgpack","createMultisigTransactionWithSignature","rawSig","myPk","encodedMsig","decodeMsgpack","keyExist","forEach","i","bytesEqual","s","Error","partialSignTxn","transaction","sk","keyPairFromSecretKey","publicKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","signerAddressObj","fromString","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","toString","undefined","refPreImage","refMsigAddr","newSubsigs","sig","unisig","authAddr","preimg","msgigAddr","uniSubsig","index","current","arrayEqual","refSgnr","signMultisigTransaction","blob","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","partialSignedBlob","appendSignRawMultisigSignature"],"sources":["C:\\Users\\naga shiva kumari\\OneDrive\\node_modules\\algosdk\\src\\multisigSigning.ts"],"sourcesContent":["import * as nacl from './nacl/naclWrappers.js';\nimport { Address } from './encoding/address.js';\nimport * as encoding from './encoding/encoding.js';\nimport { Transaction } from './transaction.js';\nimport * as utils from './utils/utils.js';\nimport { EncodedMultisig } from './types/transactions/encoded.js';\nimport { SignedTransaction } from './signedTransaction.js';\nimport {\n  MultisigMetadata,\n  addressFromMultisigPreImg,\n  pksFromAddresses,\n} from './multisig.js';\n\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG =\n  'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG =\n  'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG =\n  'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG =\n  'Cannot merge txs. subsigs are mismatched.';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG =\n  'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG =\n  'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG =\n  'Cannot add multisig signature. Signature is not of the correct length.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\n\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(\n  txn: Transaction,\n  { version, threshold, addrs }: MultisigMetadata\n) {\n  // construct the appendable multisigned transaction format\n  const pks = pksFromAddresses(addrs);\n  const subsigs = pks.map((pk) => ({ pk }));\n\n  const msig: EncodedMultisig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs,\n  };\n\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = addressFromMultisigPreImg({\n    version,\n    threshold,\n    pks,\n  });\n  let sgnr: Address | undefined;\n  if (!txn.sender.equals(msigAddr)) {\n    sgnr = msigAddr;\n  }\n\n  const signedTxn = new SignedTransaction({\n    txn,\n    msig,\n    sgnr,\n  });\n\n  return encoding.encodeMsgpack(signedTxn);\n}\n\ninterface MultisigOptions {\n  rawSig: Uint8Array;\n  myPk: Uint8Array;\n}\n\ninterface MultisigMetadataWithPks extends Omit<MultisigMetadata, 'addrs'> {\n  pks: Uint8Array[];\n}\n\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Uint8Array raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(\n  txn: Transaction,\n  { rawSig, myPk }: MultisigOptions,\n  { version, threshold, pks }: MultisigMetadataWithPks\n): Uint8Array {\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map((pk) => new Address(pk)),\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decodeMsgpack(encodedMsig, SignedTransaction);\n\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig!.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig!.subsig[i].s = rawSig;\n    }\n  });\n  if (!keyExist) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n\n  return encoding.encodeMsgpack(signedTxn);\n}\n\n/**\n * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n * encoded with msgpack as a typed array.\n * @param transaction - The transaction to sign\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - multisig public key list, order is important.\n * @param sk - an Algorand secret key to sign with.\n * @returns an encoded, partially signed multisig transaction.\n */\nfunction partialSignTxn(\n  transaction: Transaction,\n  { version, threshold, pks }: MultisigMetadataWithPks,\n  sk: Uint8Array\n) {\n  // get signature verifier\n  const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n  return createMultisigTransactionWithSignature(\n    transaction,\n    { rawSig: transaction.rawSignTxn(sk), myPk },\n    { version, threshold, pks }\n  );\n}\n\n/**\n * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n * @param transaction - The transaction to sign\n * @param metadata - multisig metadata\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns an encoded, partially signed multisig transaction.\n */\nfunction partialSignWithMultisigSignature(\n  transaction: Transaction,\n  metadata: MultisigMetadataWithPks,\n  signerAddr: string | Address,\n  signature: Uint8Array\n) {\n  if (!nacl.isValidSignatureLength(signature.length)) {\n    throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n  }\n  const signerAddressObj =\n    typeof signerAddr === 'string'\n      ? Address.fromString(signerAddr)\n      : signerAddr;\n  return createMultisigTransactionWithSignature(\n    transaction,\n    {\n      rawSig: signature,\n      myPk: signerAddressObj.publicKey,\n    },\n    metadata\n  );\n}\n\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs: Uint8Array[]) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decodeMsgpack(\n    multisigTxnBlobs[0],\n    SignedTransaction\n  );\n  if (!refSigTx.msig) {\n    throw new Error(\n      'Invalid multisig transaction, multisig structure missing at index 0'\n    );\n  }\n  const refTxID = refSigTx.txn.txID();\n  const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk),\n  };\n  const refMsigAddr = addressFromMultisigPreImg(refPreImage);\n\n  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decodeMsgpack(\n      multisigTxnBlobs[i],\n      SignedTransaction\n    );\n    if (!unisig.msig) {\n      throw new Error(\n        `Invalid multisig transaction, multisig structure missing at index ${i}`\n      );\n    }\n\n    if (unisig.txn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n\n    const authAddr = unisig.sgnr ? unisig.sgnr.toString() : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg: MultisigMetadataWithPks = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map((subsig) => subsig.pk),\n    };\n    const msgigAddr = addressFromMultisigPreImg(preimg);\n    if (!refMsigAddr.equals(msgigAddr)) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      if (current.s && !utils.arrayEqual(uniSubsig.s, current.s)) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig: EncodedMultisig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs,\n  };\n  const refSgnr =\n    typeof refAuthAddr !== 'undefined' ? refSigTx.sgnr : undefined;\n  const signedTxn = new SignedTransaction({\n    msig,\n    txn: refSigTx.txn,\n    sgnr: refSgnr,\n  });\n  return encoding.encodeMsgpack(signedTxn);\n}\n\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(\n  txn: Transaction,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  // build pks for partialSign\n  const pks = pksFromAddresses(addrs);\n  const blob = partialSignTxn(txn, { version, threshold, pks }, sk);\n  return {\n    txID: txn.txID(),\n    blob,\n  };\n}\n\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  sk: Uint8Array\n) {\n  const pks = pksFromAddresses(addrs);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decodeMsgpack(\n    multisigTxnBlob,\n    SignedTransaction\n  );\n  const partialSignedBlob = partialSignTxn(\n    multisigTxObj.txn,\n    { version, threshold, pks },\n    sk\n  );\n  return {\n    txID: multisigTxObj.txn.txID(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(\n  multisigTxnBlob: Uint8Array,\n  { version, threshold, addrs }: MultisigMetadata,\n  signerAddr: string | Address,\n  signature: Uint8Array\n) {\n  const pks = pksFromAddresses(addrs);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decodeMsgpack(\n    multisigTxnBlob,\n    SignedTransaction\n  );\n  const partialSignedBlob = partialSignWithMultisigSignature(\n    multisigTxObj.txn,\n    { version, threshold, pks },\n    signerAddr,\n    signature\n  );\n  return {\n    txID: multisigTxObj.txn.txID(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob]),\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}